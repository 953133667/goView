{"version":3,"sources":["raw.js"],"names":[],"mappings":"AAAA;;AAEA,IAAI,MAAJ,C,CAAY;AACZ,IAAI,kBAAkB,OAAO,YAAP,KAAwB,UAA9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,OAAP,GAAiB,OAAjB;AACA,SAAS,OAAT,CAAiB,IAAjB,EAAuB;AACnB,QAAI,CAAC,MAAM,MAAX,EAAmB;AACf;AACA,mBAAW,IAAX;AACH;AACD;AACA,UAAM,MAAM,MAAZ,IAAsB,IAAtB;AACH;;AAED,IAAI,QAAQ,EAAZ;AACA;AACA;AACA,IAAI,WAAW,KAAf;AACA;AACA;AACA;AACA,IAAI,QAAQ,CAAZ;AACA;AACA;AACA;AACA,IAAI,WAAW,IAAf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,KAAT,GAAiB;AACb,WAAO,QAAQ,MAAM,MAArB,EAA6B;AACzB,YAAI,eAAe,KAAnB;AACA;AACA;AACA,gBAAQ,QAAQ,CAAhB;AACA,cAAM,YAAN,EAAoB,IAApB;AACA;AACA;AACA;AACA;AACA;AACA,YAAI,QAAQ,QAAZ,EAAsB;AAClB;AACA;AACA,iBAAK,IAAI,OAAO,CAAX,EAAc,YAAY,MAAM,MAAN,GAAe,KAA9C,EAAqD,OAAO,SAA5D,EAAuE,MAAvE,EAA+E;AAC3E,sBAAM,IAAN,IAAc,MAAM,OAAO,KAAb,CAAd;AACH;AACD,kBAAM,MAAN,IAAgB,KAAhB;AACA,oBAAQ,CAAR;AACH;AACJ;AACD,UAAM,MAAN,GAAe,CAAf;AACA,YAAQ,CAAR;AACA,eAAW,KAAX;AACH;;AAED,QAAQ,YAAR,GAAuB,YAAvB;AACA,SAAS,YAAT,GAAwB;AACpB;AACA;AACA;AACA,QAAI,eAAe,QAAQ,MAA3B;AACA,QAAI,YAAJ,EAAkB;AACd,YAAI,CAAC,MAAL,EAAa;AACT;AACA;AACA,qBAAS,QAAQ,QAAR,CAAT;AACH;AACD,eAAO,MAAP,GAAgB,QAAQ,MAAR,GAAiB,IAAjC;AACH;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,QAAI,YAAY,eAAhB,EAAiC;AAC7B,qBAAa,KAAb;AACH,KAFD,MAEO;AACH,gBAAQ,QAAR,CAAiB,KAAjB;AACH;;AAED,QAAI,YAAJ,EAAkB;AACd,eAAO,MAAP,GAAgB,QAAQ,MAAR,GAAiB,YAAjC;AACH;AACJ","file":"raw-compiled.js","sourcesContent":["\"use strict\";\n\nvar domain; // The domain module is executed on demand\nvar hasSetImmediate = typeof setImmediate === \"function\";\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including network IO events in Node.js.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Avoids a function call\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory excaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\nrawAsap.requestFlush = requestFlush;\nfunction requestFlush() {\n    // Ensure flushing is not bound to any domain.\n    // It is not sufficient to exit the domain, because domains exist on a stack.\n    // To execute code outside of any domain, the following dance is necessary.\n    var parentDomain = process.domain;\n    if (parentDomain) {\n        if (!domain) {\n            // Lazy execute the domain module.\n            // Only employed if the user elects to use domains.\n            domain = require(\"domain\");\n        }\n        domain.active = process.domain = null;\n    }\n\n    // `setImmediate` is slower that `process.nextTick`, but `process.nextTick`\n    // cannot handle recursion.\n    // `requestFlush` will only be called recursively from `asap.js`, to resume\n    // flushing after an error is thrown into a domain.\n    // Conveniently, `setImmediate` was introduced in the same version\n    // `process.nextTick` started throwing recursion errors.\n    if (flushing && hasSetImmediate) {\n        setImmediate(flush);\n    } else {\n        process.nextTick(flush);\n    }\n\n    if (parentDomain) {\n        domain.active = process.domain = parentDomain;\n    }\n}\n"]}