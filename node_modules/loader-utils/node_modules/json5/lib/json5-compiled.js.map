{"version":3,"sources":["json5.js"],"names":[],"mappings":"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","file":"json5-compiled.js","sourcesContent":["// json5.js\n// Modern JSON. See README.md for details.\n//\n// This file is based directly off of Douglas Crockford's json_parse.js:\n// https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js\n\nvar JSON5 = (typeof exports === 'object' ? exports : {});\n\nJSON5.parse = (function () {\n    \"use strict\";\n\n// This is a function that can parse a JSON5 text, producing a JavaScript\n// data structure. It is a simple, recursive descent parser. It does not use\n// eval or regular expressions, so it can be used as a model for implementing\n// a JSON5 parser in other languages.\n\n// We are defining the function inside of another function to avoid creating\n// global variables.\n\n    var at,           // The index of the current character\n        lineNumber,   // The current line number\n        columnNumber, // The current column number\n        ch,           // The current character\n        escapee = {\n            \"'\":  \"'\",\n            '\"':  '\"',\n            '\\\\': '\\\\',\n            '/':  '/',\n            '\\n': '',       // Replace escaped newlines in strings w/ empty string\n            b:    '\\b',\n            f:    '\\f',\n            n:    '\\n',\n            r:    '\\r',\n            t:    '\\t'\n        },\n        ws = [\n            ' ',\n            '\\t',\n            '\\r',\n            '\\n',\n            '\\v',\n            '\\f',\n            '\\xA0',\n            '\\uFEFF'\n        ],\n        text,\n\n        renderChar = function (chr) {\n            return chr === '' ? 'EOF' : \"'\" + chr + \"'\";\n        },\n\n        error = function (m) {\n\n// Call error when something is wrong.\n\n            var error = new SyntaxError();\n            // beginning of message suffix to agree with that provided by Gecko - see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse\n            error.message = m + \" at line \" + lineNumber + \" column \" + columnNumber + \" of the JSON5 data. Still to read: \" + JSON.stringify(text.substring(at - 1, at + 19));\n            error.at = at;\n            // These two property names have been chosen to agree with the ones in Gecko, the only popular\n            // environment which seems to supply this info on JSON.parse\n            error.lineNumber = lineNumber;\n            error.columnNumber = columnNumber;\n            throw error;\n        },\n\n        next = function (c) {\n\n// If a c parameter is provided, verify that it matches the current character.\n\n            if (c && c !== ch) {\n                error(\"Expected \" + renderChar(c) + \" instead of \" + renderChar(ch));\n            }\n\n// Get the next character. When there are no more characters,\n// return the empty string.\n\n            ch = text.charAt(at);\n            at++;\n            columnNumber++;\n            if (ch === '\\n' || ch === '\\r' && peek() !== '\\n') {\n                lineNumber++;\n                columnNumber = 0;\n            }\n            return ch;\n        },\n\n        peek = function () {\n\n// Get the next character without consuming it or\n// assigning it to the ch varaible.\n\n            return text.charAt(at);\n        },\n\n        identifier = function () {\n\n// Parse an identifier. Normally, reserved words are disallowed here, but we\n// only use this for unquoted object keys, where reserved words are allowed,\n// so we don't check for those here. References:\n// - http://es5.github.com/#x7.6\n// - https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Variables\n// - http://docstore.mik.ua/orelly/webprog/jscript/ch02_07.htm\n// TODO Identifiers can have Unicode \"letters\" in them; add support for those.\n\n            var key = ch;\n\n            // Identifiers must start with a letter, _ or $.\n            if ((ch !== '_' && ch !== '$') &&\n                    (ch < 'a' || ch > 'z') &&\n                    (ch < 'A' || ch > 'Z')) {\n                error(\"Bad identifier as unquoted key\");\n            }\n\n            // Subsequent characters can contain digits.\n            while (next() && (\n                    ch === '_' || ch === '$' ||\n                    (ch >= 'a' && ch <= 'z') ||\n                    (ch >= 'A' && ch <= 'Z') ||\n                    (ch >= '0' && ch <= '9'))) {\n                key += ch;\n            }\n\n            return key;\n        },\n\n        number = function () {\n\n// Parse a number value.\n\n            var number,\n                sign = '',\n                string = '',\n                base = 10;\n\n            if (ch === '-' || ch === '+') {\n                sign = ch;\n                next(ch);\n            }\n\n            // support for Infinity (could tweak to allow other words):\n            if (ch === 'I') {\n                number = word();\n                if (typeof number !== 'number' || isNaN(number)) {\n                    error('Unexpected word for number');\n                }\n                return (sign === '-') ? -number : number;\n            }\n\n            // support for NaN\n            if (ch === 'N' ) {\n              number = word();\n              if (!isNaN(number)) {\n                error('expected word to be NaN');\n              }\n              // ignore sign as -NaN also is NaN\n              return number;\n            }\n\n            if (ch === '0') {\n                string += ch;\n                next();\n                if (ch === 'x' || ch === 'X') {\n                    string += ch;\n                    next();\n                    base = 16;\n                } else if (ch >= '0' && ch <= '9') {\n                    error('Octal literal');\n                }\n            }\n\n            switch (base) {\n            case 10:\n                while (ch >= '0' && ch <= '9' ) {\n                    string += ch;\n                    next();\n                }\n                if (ch === '.') {\n                    string += '.';\n                    while (next() && ch >= '0' && ch <= '9') {\n                        string += ch;\n                    }\n                }\n                if (ch === 'e' || ch === 'E') {\n                    string += ch;\n                    next();\n                    if (ch === '-' || ch === '+') {\n                        string += ch;\n                        next();\n                    }\n                    while (ch >= '0' && ch <= '9') {\n                        string += ch;\n                        next();\n                    }\n                }\n                break;\n            case 16:\n                while (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') {\n                    string += ch;\n                    next();\n                }\n                break;\n            }\n\n            if(sign === '-') {\n                number = -string;\n            } else {\n                number = +string;\n            }\n\n            if (!isFinite(number)) {\n                error(\"Bad number\");\n            } else {\n                return number;\n            }\n        },\n\n        string = function () {\n\n// Parse a string value.\n\n            var hex,\n                i,\n                string = '',\n                delim,      // double quote or single quote\n                uffff;\n\n// When parsing for string values, we must look for ' or \" and \\ characters.\n\n            if (ch === '\"' || ch === \"'\") {\n                delim = ch;\n                while (next()) {\n                    if (ch === delim) {\n                        next();\n                        return string;\n                    } else if (ch === '\\\\') {\n                        next();\n                        if (ch === 'u') {\n                            uffff = 0;\n                            for (i = 0; i < 4; i += 1) {\n                                hex = parseInt(next(), 16);\n                                if (!isFinite(hex)) {\n                                    break;\n                                }\n                                uffff = uffff * 16 + hex;\n                            }\n                            string += String.fromCharCode(uffff);\n                        } else if (ch === '\\r') {\n                            if (peek() === '\\n') {\n                                next();\n                            }\n                        } else if (typeof escapee[ch] === 'string') {\n                            string += escapee[ch];\n                        } else {\n                            break;\n                        }\n                    } else if (ch === '\\n') {\n                        // unescaped newlines are invalid; see:\n                        // https://github.com/aseemk/json5/issues/24\n                        // TODO this feels special-cased; are there other\n                        // invalid unescaped chars?\n                        break;\n                    } else {\n                        string += ch;\n                    }\n                }\n            }\n            error(\"Bad string\");\n        },\n\n        inlineComment = function () {\n\n// Skip an inline comment, assuming this is one. The current character should\n// be the second / character in the // pair that begins this inline comment.\n// To finish the inline comment, we look for a newline or the end of the text.\n\n            if (ch !== '/') {\n                error(\"Not an inline comment\");\n            }\n\n            do {\n                next();\n                if (ch === '\\n' || ch === '\\r') {\n                    next();\n                    return;\n                }\n            } while (ch);\n        },\n\n        blockComment = function () {\n\n// Skip a block comment, assuming this is one. The current character should be\n// the * character in the /* pair that begins this block comment.\n// To finish the block comment, we look for an ending */ pair of characters,\n// but we also watch for the end of text before the comment is terminated.\n\n            if (ch !== '*') {\n                error(\"Not a block comment\");\n            }\n\n            do {\n                next();\n                while (ch === '*') {\n                    next('*');\n                    if (ch === '/') {\n                        next('/');\n                        return;\n                    }\n                }\n            } while (ch);\n\n            error(\"Unterminated block comment\");\n        },\n\n        comment = function () {\n\n// Skip a comment, whether inline or block-level, assuming this is one.\n// Comments always begin with a / character.\n\n            if (ch !== '/') {\n                error(\"Not a comment\");\n            }\n\n            next('/');\n\n            if (ch === '/') {\n                inlineComment();\n            } else if (ch === '*') {\n                blockComment();\n            } else {\n                error(\"Unrecognized comment\");\n            }\n        },\n\n        white = function () {\n\n// Skip whitespace and comments.\n// Note that we're detecting comments by only a single / character.\n// This works since regular expressions are not valid JSON(5), but this will\n// break if there are other valid values that begin with a / character!\n\n            while (ch) {\n                if (ch === '/') {\n                    comment();\n                } else if (ws.indexOf(ch) >= 0) {\n                    next();\n                } else {\n                    return;\n                }\n            }\n        },\n\n        word = function () {\n\n// true, false, or null.\n\n            switch (ch) {\n            case 't':\n                next('t');\n                next('r');\n                next('u');\n                next('e');\n                return true;\n            case 'f':\n                next('f');\n                next('a');\n                next('l');\n                next('s');\n                next('e');\n                return false;\n            case 'n':\n                next('n');\n                next('u');\n                next('l');\n                next('l');\n                return null;\n            case 'I':\n                next('I');\n                next('n');\n                next('f');\n                next('i');\n                next('n');\n                next('i');\n                next('t');\n                next('y');\n                return Infinity;\n            case 'N':\n              next( 'N' );\n              next( 'a' );\n              next( 'N' );\n              return NaN;\n            }\n            error(\"Unexpected \" + renderChar(ch));\n        },\n\n        value,  // Place holder for the value function.\n\n        array = function () {\n\n// Parse an array value.\n\n            var array = [];\n\n            if (ch === '[') {\n                next('[');\n                white();\n                while (ch) {\n                    if (ch === ']') {\n                        next(']');\n                        return array;   // Potentially empty array\n                    }\n                    // ES5 allows omitting elements in arrays, e.g. [,] and\n                    // [,null]. We don't allow this in JSON5.\n                    if (ch === ',') {\n                        error(\"Missing array element\");\n                    } else {\n                        array.push(value());\n                    }\n                    white();\n                    // If there's no comma after this value, this needs to\n                    // be the end of the array.\n                    if (ch !== ',') {\n                        next(']');\n                        return array;\n                    }\n                    next(',');\n                    white();\n                }\n            }\n            error(\"Bad array\");\n        },\n\n        object = function () {\n\n// Parse an object value.\n\n            var key,\n                object = {};\n\n            if (ch === '{') {\n                next('{');\n                white();\n                while (ch) {\n                    if (ch === '}') {\n                        next('}');\n                        return object;   // Potentially empty object\n                    }\n\n                    // Keys can be unquoted. If they are, they need to be\n                    // valid JS identifiers.\n                    if (ch === '\"' || ch === \"'\") {\n                        key = string();\n                    } else {\n                        key = identifier();\n                    }\n\n                    white();\n                    next(':');\n                    object[key] = value();\n                    white();\n                    // If there's no comma after this pair, this needs to be\n                    // the end of the object.\n                    if (ch !== ',') {\n                        next('}');\n                        return object;\n                    }\n                    next(',');\n                    white();\n                }\n            }\n            error(\"Bad object\");\n        };\n\n    value = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n        white();\n        switch (ch) {\n        case '{':\n            return object();\n        case '[':\n            return array();\n        case '\"':\n        case \"'\":\n            return string();\n        case '-':\n        case '+':\n        case '.':\n            return number();\n        default:\n            return ch >= '0' && ch <= '9' ? number() : word();\n        }\n    };\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\n    return function (source, reviver) {\n        var result;\n\n        text = String(source);\n        at = 0;\n        lineNumber = 1;\n        columnNumber = 1;\n        ch = ' ';\n        result = value();\n        white();\n        if (ch) {\n            error(\"Syntax error\");\n        }\n\n// If there is a reviver function, we recursively walk the new structure,\n// passing each name/value pair to the reviver function for possible\n// transformation, starting with a temporary root object that holds the result\n// in an empty key. If there is not a reviver function, we simply return the\n// result.\n\n        return typeof reviver === 'function' ? (function walk(holder, key) {\n            var k, v, value = holder[key];\n            if (value && typeof value === 'object') {\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = walk(value, k);\n                        if (v !== undefined) {\n                            value[k] = v;\n                        } else {\n                            delete value[k];\n                        }\n                    }\n                }\n            }\n            return reviver.call(holder, key, value);\n        }({'': result}, '')) : result;\n    };\n}());\n\n// JSON5 stringify will not quote keys where appropriate\nJSON5.stringify = function (obj, replacer, space) {\n    if (replacer && (typeof(replacer) !== \"function\" && !isArray(replacer))) {\n        throw new Error('Replacer must be a function or an array');\n    }\n    var getReplacedValueOrUndefined = function(holder, key, isTopLevel) {\n        var value = holder[key];\n\n        // Replace the value with its toJSON value first, if possible\n        if (value && value.toJSON && typeof value.toJSON === \"function\") {\n            value = value.toJSON();\n        }\n\n        // If the user-supplied replacer if a function, call it. If it's an array, check objects' string keys for\n        // presence in the array (removing the key/value pair from the resulting JSON if the key is missing).\n        if (typeof(replacer) === \"function\") {\n            return replacer.call(holder, key, value);\n        } else if(replacer) {\n            if (isTopLevel || isArray(holder) || replacer.indexOf(key) >= 0) {\n                return value;\n            } else {\n                return undefined;\n            }\n        } else {\n            return value;\n        }\n    };\n\n    function isWordChar(c) {\n        return (c >= 'a' && c <= 'z') ||\n            (c >= 'A' && c <= 'Z') ||\n            (c >= '0' && c <= '9') ||\n            c === '_' || c === '$';\n    }\n\n    function isWordStart(c) {\n        return (c >= 'a' && c <= 'z') ||\n            (c >= 'A' && c <= 'Z') ||\n            c === '_' || c === '$';\n    }\n\n    function isWord(key) {\n        if (typeof key !== 'string') {\n            return false;\n        }\n        if (!isWordStart(key[0])) {\n            return false;\n        }\n        var i = 1, length = key.length;\n        while (i < length) {\n            if (!isWordChar(key[i])) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    }\n\n    // export for use in tests\n    JSON5.isWord = isWord;\n\n    // polyfills\n    function isArray(obj) {\n        if (Array.isArray) {\n            return Array.isArray(obj);\n        } else {\n            return Object.prototype.toString.call(obj) === '[object Array]';\n        }\n    }\n\n    function isDate(obj) {\n        return Object.prototype.toString.call(obj) === '[object Date]';\n    }\n\n    var objStack = [];\n    function checkForCircular(obj) {\n        for (var i = 0; i < objStack.length; i++) {\n            if (objStack[i] === obj) {\n                throw new TypeError(\"Converting circular structure to JSON\");\n            }\n        }\n    }\n\n    function makeIndent(str, num, noNewLine) {\n        if (!str) {\n            return \"\";\n        }\n        // indentation no more than 10 chars\n        if (str.length > 10) {\n            str = str.substring(0, 10);\n        }\n\n        var indent = noNewLine ? \"\" : \"\\n\";\n        for (var i = 0; i < num; i++) {\n            indent += str;\n        }\n\n        return indent;\n    }\n\n    var indentStr;\n    if (space) {\n        if (typeof space === \"string\") {\n            indentStr = space;\n        } else if (typeof space === \"number\" && space >= 0) {\n            indentStr = makeIndent(\" \", space, true);\n        } else {\n            // ignore space parameter\n        }\n    }\n\n    // Copied from Crokford's implementation of JSON\n    // See https://github.com/douglascrockford/JSON-js/blob/e39db4b7e6249f04a195e7dd0840e610cc9e941e/json2.js#L195\n    // Begin\n    var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n        escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n        meta = { // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    };\n    function escapeString(string) {\n\n// If the string contains no control characters, no quote characters, and no\n// backslash characters, then we can safely slap some quotes around it.\n// Otherwise we must also replace the offending characters with safe escape\n// sequences.\n        escapable.lastIndex = 0;\n        return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n            var c = meta[a];\n            return typeof c === 'string' ?\n                c :\n                '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n        }) + '\"' : '\"' + string + '\"';\n    }\n    // End\n\n    function internalStringify(holder, key, isTopLevel) {\n        var buffer, res;\n\n        // Replace the value, if necessary\n        var obj_part = getReplacedValueOrUndefined(holder, key, isTopLevel);\n\n        if (obj_part && !isDate(obj_part)) {\n            // unbox objects\n            // don't unbox dates, since will turn it into number\n            obj_part = obj_part.valueOf();\n        }\n        switch(typeof obj_part) {\n            case \"boolean\":\n                return obj_part.toString();\n\n            case \"number\":\n                if (isNaN(obj_part) || !isFinite(obj_part)) {\n                    return \"null\";\n                }\n                return obj_part.toString();\n\n            case \"string\":\n                return escapeString(obj_part.toString());\n\n            case \"object\":\n                if (obj_part === null) {\n                    return \"null\";\n                } else if (isArray(obj_part)) {\n                    checkForCircular(obj_part);\n                    buffer = \"[\";\n                    objStack.push(obj_part);\n\n                    for (var i = 0; i < obj_part.length; i++) {\n                        res = internalStringify(obj_part, i, false);\n                        buffer += makeIndent(indentStr, objStack.length);\n                        if (res === null || typeof res === \"undefined\") {\n                            buffer += \"null\";\n                        } else {\n                            buffer += res;\n                        }\n                        if (i < obj_part.length-1) {\n                            buffer += \",\";\n                        } else if (indentStr) {\n                            buffer += \"\\n\";\n                        }\n                    }\n                    objStack.pop();\n                    buffer += makeIndent(indentStr, objStack.length, true) + \"]\";\n                } else {\n                    checkForCircular(obj_part);\n                    buffer = \"{\";\n                    var nonEmpty = false;\n                    objStack.push(obj_part);\n                    for (var prop in obj_part) {\n                        if (obj_part.hasOwnProperty(prop)) {\n                            var value = internalStringify(obj_part, prop, false);\n                            isTopLevel = false;\n                            if (typeof value !== \"undefined\" && value !== null) {\n                                buffer += makeIndent(indentStr, objStack.length);\n                                nonEmpty = true;\n                                key = isWord(prop) ? prop : escapeString(prop);\n                                buffer += key + \":\" + (indentStr ? ' ' : '') + value + \",\";\n                            }\n                        }\n                    }\n                    objStack.pop();\n                    if (nonEmpty) {\n                        buffer = buffer.substring(0, buffer.length-1) + makeIndent(indentStr, objStack.length) + \"}\";\n                    } else {\n                        buffer = '{}';\n                    }\n                }\n                return buffer;\n            default:\n                // functions and undefined should be ignored\n                return undefined;\n        }\n    }\n\n    // special case...when undefined is used inside of\n    // a compound object/array, return null.\n    // but when top-level, return undefined\n    var topLevelHolder = {\"\":obj};\n    if (obj === undefined) {\n        return getReplacedValueOrUndefined(topLevelHolder, '', true);\n    }\n    return internalStringify(topLevelHolder, '', true);\n};\n"]}