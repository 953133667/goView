{"version":3,"sources":["quick-sort.js"],"names":[],"mappings":"AAAA;AACA;;;;;AAKA,IAAI,OAAO,MAAP,KAAkB,UAAtB,EAAkC;AAC9B,MAAI,SAAS,QAAQ,UAAR,EAAoB,MAApB,EAA4B,OAA5B,CAAb;AACH;AACD,OAAO,UAAU,OAAV,EAAmB,OAAnB,EAA4B,MAA5B,EAAoC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;AAUA,WAAS,IAAT,CAAc,GAAd,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB;AACvB,QAAI,OAAO,IAAI,CAAJ,CAAX;AACA,QAAI,CAAJ,IAAS,IAAI,CAAJ,CAAT;AACA,QAAI,CAAJ,IAAS,IAAT;AACD;;AAED;;;;;;;;AAQA,WAAS,gBAAT,CAA0B,GAA1B,EAA+B,IAA/B,EAAqC;AACnC,WAAO,KAAK,KAAL,CAAW,MAAO,KAAK,MAAL,MAAiB,OAAO,GAAxB,CAAlB,CAAP;AACD;;AAED;;;;;;;;;;;;AAYA,WAAS,WAAT,CAAqB,GAArB,EAA0B,UAA1B,EAAsC,CAAtC,EAAyC,CAAzC,EAA4C;AAC1C;AACA;AACA;;AAEA,QAAI,IAAI,CAAR,EAAW;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAI,aAAa,iBAAiB,CAAjB,EAAoB,CAApB,CAAjB;AACA,UAAI,IAAI,IAAI,CAAZ;;AAEA,WAAK,GAAL,EAAU,UAAV,EAAsB,CAAtB;AACA,UAAI,QAAQ,IAAI,CAAJ,CAAZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,CAApB,EAAuB,GAAvB,EAA4B;AAC1B,YAAI,WAAW,IAAI,CAAJ,CAAX,EAAmB,KAAnB,KAA6B,CAAjC,EAAoC;AAClC,eAAK,CAAL;AACA,eAAK,GAAL,EAAU,CAAV,EAAa,CAAb;AACD;AACF;;AAED,WAAK,GAAL,EAAU,IAAI,CAAd,EAAiB,CAAjB;AACA,UAAI,IAAI,IAAI,CAAZ;;AAEA;;AAEA,kBAAY,GAAZ,EAAiB,UAAjB,EAA6B,CAA7B,EAAgC,IAAI,CAApC;AACA,kBAAY,GAAZ,EAAiB,UAAjB,EAA6B,IAAI,CAAjC,EAAoC,CAApC;AACD;AACF;;AAED;;;;;;;;AAQA,UAAQ,SAAR,GAAoB,UAAU,GAAV,EAAe,UAAf,EAA2B;AAC7C,gBAAY,GAAZ,EAAiB,UAAjB,EAA6B,CAA7B,EAAgC,IAAI,MAAJ,GAAa,CAA7C;AACD,GAFD;AAID,CA9GD","file":"quick-sort-compiled.js","sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n}\ndefine(function (require, exports, module) {\n\n  // It turns out that some (most?) JavaScript engines don't self-host\n  // `Array.prototype.sort`. This makes sense because C++ will likely remain\n  // faster than JS when doing raw CPU-intensive sorting. However, when using a\n  // custom comparator function, calling back and forth between the VM's C++ and\n  // JIT'd JS is rather slow *and* loses JIT type information, resulting in\n  // worse generated code for the comparator function than would be optimal. In\n  // fact, when sorting with a comparator, these costs outweigh the benefits of\n  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n  // a ~3500ms mean speed-up in `bench/bench.html`.\n\n  /**\n   * Swap the elements indexed by `x` and `y` in the array `ary`.\n   *\n   * @param {Array} ary\n   *        The array.\n   * @param {Number} x\n   *        The index of the first item.\n   * @param {Number} y\n   *        The index of the second item.\n   */\n  function swap(ary, x, y) {\n    var temp = ary[x];\n    ary[x] = ary[y];\n    ary[y] = temp;\n  }\n\n  /**\n   * Returns a random integer within the range `low .. high` inclusive.\n   *\n   * @param {Number} low\n   *        The lower bound on the range.\n   * @param {Number} high\n   *        The upper bound on the range.\n   */\n  function randomIntInRange(low, high) {\n    return Math.round(low + (Math.random() * (high - low)));\n  }\n\n  /**\n   * The Quick Sort algorithm.\n   *\n   * @param {Array} ary\n   *        An array to sort.\n   * @param {function} comparator\n   *        Function to use to compare two items.\n   * @param {Number} p\n   *        Start index of the array\n   * @param {Number} r\n   *        End index of the array\n   */\n  function doQuickSort(ary, comparator, p, r) {\n    // If our lower bound is less than our upper bound, we (1) partition the\n    // array into two pieces and (2) recurse on each half. If it is not, this is\n    // the empty array and our base case.\n\n    if (p < r) {\n      // (1) Partitioning.\n      //\n      // The partitioning chooses a pivot between `p` and `r` and moves all\n      // elements that are less than or equal to the pivot to the before it, and\n      // all the elements that are greater than it after it. The effect is that\n      // once partition is done, the pivot is in the exact place it will be when\n      // the array is put in sorted order, and it will not need to be moved\n      // again. This runs in O(n) time.\n\n      // Always choose a random pivot so that an input array which is reverse\n      // sorted does not cause O(n^2) running time.\n      var pivotIndex = randomIntInRange(p, r);\n      var i = p - 1;\n\n      swap(ary, pivotIndex, r);\n      var pivot = ary[r];\n\n      // Immediately after `j` is incremented in this loop, the following hold\n      // true:\n      //\n      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n      //\n      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n      for (var j = p; j < r; j++) {\n        if (comparator(ary[j], pivot) <= 0) {\n          i += 1;\n          swap(ary, i, j);\n        }\n      }\n\n      swap(ary, i + 1, j);\n      var q = i + 1;\n\n      // (2) Recurse on each half.\n\n      doQuickSort(ary, comparator, p, q - 1);\n      doQuickSort(ary, comparator, q + 1, r);\n    }\n  }\n\n  /**\n   * Sort the given array in-place with the given comparator function.\n   *\n   * @param {Array} ary\n   *        An array to sort.\n   * @param {function} comparator\n   *        Function to use to compare two items.\n   */\n  exports.quickSort = function (ary, comparator) {\n    doQuickSort(ary, comparator, 0, ary.length - 1);\n  };\n\n});\n"]}