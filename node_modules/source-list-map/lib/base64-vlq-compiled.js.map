{"version":3,"sources":["base64-vlq.js"],"names":[],"mappings":"AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA;;AAEA,IAAI,eAAe,EAAnB;AACA,IAAI,eAAe,EAAnB;;AAEA,mEACG,KADH,CACS,EADT,EAEG,OAFH,CAEW,UAAU,EAAV,EAAc,KAAd,EAAqB;AAC5B,eAAa,EAAb,IAAmB,KAAnB;AACA,eAAa,KAAb,IAAsB,EAAtB;AACD,CALH;;AAOA,IAAI,SAAS,EAAb;AACA;;;AAGA,OAAO,MAAP,GAAgB,SAAS,aAAT,CAAuB,OAAvB,EAAgC;AAC9C,MAAI,WAAW,YAAf,EAA6B;AAC3B,WAAO,aAAa,OAAb,CAAP;AACD;AACD,QAAM,IAAI,SAAJ,CAAc,+BAA+B,OAA7C,CAAN;AACD,CALD;;AAOA;;;AAGA,OAAO,MAAP,GAAgB,SAAS,aAAT,CAAuB,KAAvB,EAA8B;AAC5C,MAAI,SAAS,YAAb,EAA2B;AACzB,WAAO,aAAa,KAAb,CAAP;AACD;AACD,QAAM,IAAI,SAAJ,CAAc,gCAAgC,KAA9C,CAAN;AACD,CALD;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI,iBAAiB,CAArB;;AAEA;AACA,IAAI,WAAW,KAAK,cAApB;;AAEA;AACA,IAAI,gBAAgB,WAAW,CAA/B;;AAEA;AACA,IAAI,uBAAuB,QAA3B;;AAEA;;;;;;AAMA,SAAS,WAAT,CAAqB,MAArB,EAA6B;AAC3B,SAAO,SAAS,CAAT,GACH,CAAE,CAAC,MAAF,IAAa,CAAd,IAAmB,CADhB,GAEH,CAAC,UAAU,CAAX,IAAgB,CAFpB;AAGD;;AAED;;;;;;AAMA,SAAS,aAAT,CAAuB,MAAvB,EAA+B;AAC7B,MAAI,aAAa,CAAC,SAAS,CAAV,MAAiB,CAAlC;AACA,MAAI,UAAU,UAAU,CAAxB;AACA,SAAO,aACH,CAAC,OADE,GAEH,OAFJ;AAGD;;AAED;;;AAGA,QAAQ,MAAR,GAAiB,SAAS,gBAAT,CAA0B,MAA1B,EAAkC;AACjD,MAAI,UAAU,EAAd;AACA,MAAI,KAAJ;;AAEA,MAAI,MAAM,YAAY,MAAZ,CAAV;;AAEA,KAAG;AACD,YAAQ,MAAM,aAAd;AACA,aAAS,cAAT;AACA,QAAI,MAAM,CAAV,EAAa;AACX;AACA;AACA,eAAS,oBAAT;AACD;AACD,eAAW,OAAO,MAAP,CAAc,KAAd,CAAX;AACD,GATD,QASS,MAAM,CATf;;AAWA,SAAO,OAAP;AACD,CAlBD;;AAoBA;;;;AAIA,QAAQ,MAAR,GAAiB,SAAS,gBAAT,CAA0B,IAA1B,EAAgC,SAAhC,EAA2C;AAC1D,MAAI,IAAI,CAAR;AACA,MAAI,SAAS,KAAK,MAAlB;AACA,MAAI,SAAS,CAAb;AACA,MAAI,QAAQ,CAAZ;AACA,MAAI,YAAJ,EAAkB,KAAlB;;AAEA,KAAG;AACD,QAAI,KAAK,MAAT,EAAiB;AACf,YAAM,IAAI,KAAJ,CAAU,4CAAV,CAAN;AACD;AACD,YAAQ,OAAO,MAAP,CAAc,KAAK,MAAL,CAAY,GAAZ,CAAd,CAAR;AACA,mBAAe,CAAC,EAAE,QAAQ,oBAAV,CAAhB;AACA,aAAS,aAAT;AACA,aAAS,UAAU,SAAS,KAAnB,CAAT;AACA,aAAS,cAAT;AACD,GATD,QASS,YATT;;AAWA,YAAU,KAAV,GAAkB,cAAc,MAAd,CAAlB;AACA,YAAU,IAAV,GAAiB,KAAK,KAAL,CAAW,CAAX,CAAjB;AACD,CApBD","file":"base64-vlq-compiled.js","sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n *\r\n * Based on the Base 64 VLQ implementation in Closure Compiler:\r\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\r\n *\r\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are\r\n * met:\r\n *\r\n *  * Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above\r\n *    copyright notice, this list of conditions and the following\r\n *    disclaimer in the documentation and/or other materials provided\r\n *    with the distribution.\r\n *  * Neither the name of Google Inc. nor the names of its\r\n *    contributors may be used to endorse or promote products derived\r\n *    from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/*eslint no-bitwise:0,quotes:0,global-strict:0*/\r\n\r\nvar charToIntMap = {};\r\nvar intToCharMap = {};\r\n\r\n'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\n  .split('')\r\n  .forEach(function (ch, index) {\r\n    charToIntMap[ch] = index;\r\n    intToCharMap[index] = ch;\r\n  });\r\n\r\nvar base64 = {};\r\n/**\r\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\r\n */\r\nbase64.encode = function base64_encode(aNumber) {\r\n  if (aNumber in intToCharMap) {\r\n    return intToCharMap[aNumber];\r\n  }\r\n  throw new TypeError(\"Must be between 0 and 63: \" + aNumber);\r\n};\r\n\r\n/**\r\n * Decode a single base 64 digit to an integer.\r\n */\r\nbase64.decode = function base64_decode(aChar) {\r\n  if (aChar in charToIntMap) {\r\n    return charToIntMap[aChar];\r\n  }\r\n  throw new TypeError(\"Not a valid base 64 digit: \" + aChar);\r\n};\r\n\r\n\r\n\r\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\r\n// length quantities we use in the source map spec, the first bit is the sign,\r\n// the next four bits are the actual value, and the 6th bit is the\r\n// continuation bit. The continuation bit tells us whether there are more\r\n// digits in this value following this digit.\r\n//\r\n//   Continuation\r\n//   |    Sign\r\n//   |    |\r\n//   V    V\r\n//   101011\r\n\r\nvar VLQ_BASE_SHIFT = 5;\r\n\r\n// binary: 100000\r\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\r\n\r\n// binary: 011111\r\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\r\n\r\n// binary: 100000\r\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\r\n\r\n/**\r\n * Converts from a two-complement value to a value where the sign bit is\r\n * placed in the least significant bit.  For example, as decimals:\r\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\r\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\r\n */\r\nfunction toVLQSigned(aValue) {\r\n  return aValue < 0\r\n    ? ((-aValue) << 1) + 1\r\n    : (aValue << 1) + 0;\r\n}\r\n\r\n/**\r\n * Converts to a two-complement value from a value where the sign bit is\r\n * placed in the least significant bit.  For example, as decimals:\r\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\r\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\r\n */\r\nfunction fromVLQSigned(aValue) {\r\n  var isNegative = (aValue & 1) === 1;\r\n  var shifted = aValue >> 1;\r\n  return isNegative\r\n    ? -shifted\r\n    : shifted;\r\n}\r\n\r\n/**\r\n * Returns the base 64 VLQ encoded value.\r\n */\r\nexports.encode = function base64VLQ_encode(aValue) {\r\n  var encoded = \"\";\r\n  var digit;\r\n\r\n  var vlq = toVLQSigned(aValue);\r\n\r\n  do {\r\n    digit = vlq & VLQ_BASE_MASK;\r\n    vlq >>>= VLQ_BASE_SHIFT;\r\n    if (vlq > 0) {\r\n      // There are still more digits in this value, so we must make sure the\r\n      // continuation bit is marked.\r\n      digit |= VLQ_CONTINUATION_BIT;\r\n    }\r\n    encoded += base64.encode(digit);\r\n  } while (vlq > 0);\r\n\r\n  return encoded;\r\n};\r\n\r\n/**\r\n * Decodes the next base 64 VLQ value from the given string and returns the\r\n * value and the rest of the string via the out parameter.\r\n */\r\nexports.decode = function base64VLQ_decode(aStr, aOutParam) {\r\n  var i = 0;\r\n  var strLen = aStr.length;\r\n  var result = 0;\r\n  var shift = 0;\r\n  var continuation, digit;\r\n\r\n  do {\r\n    if (i >= strLen) {\r\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\r\n    }\r\n    digit = base64.decode(aStr.charAt(i++));\r\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\r\n    digit &= VLQ_BASE_MASK;\r\n    result = result + (digit << shift);\r\n    shift += VLQ_BASE_SHIFT;\r\n  } while (continuation);\r\n\r\n  aOutParam.value = fromVLQSigned(result);\r\n  aOutParam.rest = aStr.slice(i);\r\n};\r\n"]}