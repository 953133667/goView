{"version":3,"sources":["random-bytes.js"],"names":[],"mappings":"AAAA,IAAI,OAAO,QAAQ,MAAR,CAAX;AACA,IAAI,SAAS,QAAQ,KAAR,CAAb;;AAEA,KAAK,mBAAL,EAA0B,UAAU,CAAV,EAAa;;AAErC,MAAI;AACF,QAAI,IAAI,OAAO,WAAP,CAAmB,EAAnB,CAAR;AACA,MAAE,EAAF,CAAK,OAAO,QAAP,CAAgB,CAAhB,CAAL;AACA,MAAE,GAAF;AACD,GAJD,CAIE,OAAO,GAAP,EAAY;AACZ,MAAE,EAAF,CAAK,gBAAgB,IAAhB,CAAqB,IAAI,OAAzB,CAAL,EAAwC,sCAAxC;AACA,MAAE,GAAF;AACD;AAEF,CAXD;;AAaA,KAAK,aAAL,EAAoB,UAAU,CAAV,EAAa;AAC7B,IAAE,IAAF,CAAO,CAAP;AACA,IAAE,KAAF,CAAQ,OAAO,WAAP,CAAmB,EAAnB,EAAuB,MAA/B,EAAuC,EAAvC;AACA,IAAE,EAAF,CAAK,OAAO,QAAP,CAAgB,OAAO,WAAP,CAAmB,EAAnB,CAAhB,CAAL;AACA,SAAO,WAAP,CAAmB,EAAnB,EAAuB,UAAS,EAAT,EAAa,KAAb,EAAoB;AACvC,MAAE,KAAF,CAAQ,EAAR;AACA,MAAE,KAAF,CAAQ,MAAM,MAAd,EAAsB,EAAtB;AACA,MAAE,EAAF,CAAK,OAAO,QAAP,CAAgB,KAAhB,CAAL;AACA,MAAE,GAAF;AACL,GALC;AAMH,CAVD;;AAYA,KAAK,yBAAL,EAAgC,UAAU,CAAV,EAAa;;AAE3C,MAAI,IAAI,IAAR;AACA,MAAI,IAAI,OAAO,WAAP,CAAmB,CAAnB,CAAR;;AAEA,MAAI,OAAO,GAAG,MAAH,CAAU,IAAV,CAAe,CAAf,EAAkB,UAAU,CAAV,EAAa,CAAb,EAAgB;AAAE,WAAO,IAAI,CAAX;AAAa,GAAjD,EAAmD,CAAnD,IAAwD,CAAnE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,MAAI,WAAW,MAAI,CAAnB;AACA,MAAI,QAAQ,KAAK,IAAL,CAAU,IAAV,CAAZ;AACA;AACA,UAAQ,GAAR,CAAY,KAAK,SAAL,CAAe,CAAC,WAAW,KAAZ,EAAmB,IAAnB,EAAyB,WAAW,KAApC,CAAf,CAAZ;AACA,IAAE,EAAF,CAAK,OAAO,WAAW,KAAvB;AACA,IAAE,EAAF,CAAK,OAAO,WAAW,KAAvB;;AAEA,IAAE,GAAF;AAED,CAxBD","file":"random-bytes-compiled.js","sourcesContent":["var test = require('tape')\nvar crypto = require('../')\n\ntest('get error message', function (t) {\n\n  try {\n    var b = crypto.randomBytes(10)\n    t.ok(Buffer.isBuffer(b))\n    t.end()\n  } catch (err) {\n    t.ok(/not supported/.test(err.message), '\"not supported\"  is in error message')\n    t.end()\n  }\n\n})\n\ntest('randomBytes', function (t) {\n    t.plan(5);\n    t.equal(crypto.randomBytes(10).length, 10);\n    t.ok(Buffer.isBuffer(crypto.randomBytes(10)))\n    crypto.randomBytes(10, function(ex, bytes) {\n        t.error(ex);\n        t.equal(bytes.length, 10);\n        t.ok(Buffer.isBuffer(bytes))\n        t.end();\n  });\n});\n\ntest('randomBytes seem random', function (t) {\n\n  var L = 1000\n  var b = crypto.randomBytes(L)\n\n  var mean = [].reduce.call(b, function (a, b) { return a + b}, 0) / L\n\n  // test that the random numbers are plausably random.\n  // Math.random() will pass this, but this will catch\n  // terrible mistakes such as this blunder:\n  // https://github.com/dominictarr/crypto-browserify/commit/3267955e1df7edd1680e52aeede9a89506ed2464#commitcomment-7916835\n\n  // this doesn't check that the bytes are in a random *order*\n  // but it's better than nothing.\n\n  var expected = 256/2\n  var smean = Math.sqrt(mean)\n  //console.log doesn't work right on testling, *grumble grumble*\n  console.log(JSON.stringify([expected - smean, mean, expected + smean]))\n  t.ok(mean < expected + smean)\n  t.ok(mean > expected - smean)\n\n  t.end()\n\n})\n\n\n"]}