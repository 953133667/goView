{"version":3,"sources":["expression.js"],"names":[],"mappings":"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","file":"expression-compiled.js","sourcesContent":["// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nimport {types as tt} from \"./tokentype\"\nimport {Parser} from \"./state\"\nimport {DestructuringErrors} from \"./parseutil\"\n\nconst pp = Parser.prototype\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash —\n// either with each other or with an init property — and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp.checkPropClash = function(prop, propHash) {\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    return\n  let {key} = prop, name\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  let {kind} = prop\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\")\n      propHash.proto = true\n    }\n    return\n  }\n  name = \"$\" + name\n  let other = propHash[name]\n  if (other) {\n    let isGetSet = kind !== \"init\"\n    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init))\n      this.raiseRecoverable(key.start, \"Redefinition of property\")\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    }\n  }\n  other[kind] = true\n}\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp.parseExpression = function(noIn, refDestructuringErrors) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseMaybeAssign(noIn, refDestructuringErrors)\n  if (this.type === tt.comma) {\n    let node = this.startNodeAt(startPos, startLoc)\n    node.expressions = [expr]\n    while (this.eat(tt.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors))\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n}\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.inGenerator && this.isContextual(\"yield\")) return this.parseYield()\n\n  let ownDestructuringErrors = false\n  if (!refDestructuringErrors) {\n    refDestructuringErrors = new DestructuringErrors\n    ownDestructuringErrors = true\n  }\n  let startPos = this.start, startLoc = this.startLoc\n  if (this.type == tt.parenL || this.type == tt.name)\n    this.potentialArrowAt = this.start\n  let left = this.parseMaybeConditional(noIn, refDestructuringErrors)\n  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc)\n  if (this.type.isAssign) {\n    this.checkPatternErrors(refDestructuringErrors, true)\n    if (!ownDestructuringErrors) DestructuringErrors.call(refDestructuringErrors)\n    let node = this.startNodeAt(startPos, startLoc)\n    node.operator = this.value\n    node.left = this.type === tt.eq ? this.toAssignable(left) : left\n    refDestructuringErrors.shorthandAssign = 0 // reset because shorthand default was used correctly\n    this.checkLVal(left)\n    this.next()\n    node.right = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true)\n  }\n  return left\n}\n\n// Parse a ternary conditional (`?:`) operator.\n\npp.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseExprOps(noIn, refDestructuringErrors)\n  if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n  if (this.eat(tt.question)) {\n    let node = this.startNodeAt(startPos, startLoc)\n    node.test = expr\n    node.consequent = this.parseMaybeAssign()\n    this.expect(tt.colon)\n    node.alternate = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n}\n\n// Start the precedence parser.\n\npp.parseExprOps = function(noIn, refDestructuringErrors) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseMaybeUnary(refDestructuringErrors, false)\n  if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n  return this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n}\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  let prec = this.type.binop\n  if (prec != null && (!noIn || this.type !== tt._in)) {\n    if (prec > minPrec) {\n      let logical = this.type === tt.logicalOR || this.type === tt.logicalAND\n      let op = this.value\n      this.next()\n      let startPos = this.start, startLoc = this.startLoc\n      let right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn)\n      let node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical)\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n    }\n  }\n  return left\n}\n\npp.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n  let node = this.startNodeAt(startPos, startLoc)\n  node.left = left\n  node.operator = op\n  node.right = right\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n}\n\n// Parse unary operators, both prefix and postfix.\n\npp.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n  let startPos = this.start, startLoc = this.startLoc, expr\n  if (this.type.prefix) {\n    let node = this.startNode(), update = this.type === tt.incDec\n    node.operator = this.value\n    node.prefix = true\n    this.next()\n    node.argument = this.parseMaybeUnary(null, true)\n    this.checkExpressionErrors(refDestructuringErrors, true)\n    if (update) this.checkLVal(node.argument)\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\")\n    else sawUnary = true\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\")\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors)\n    if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.operator = this.value\n      node.prefix = false\n      node.argument = expr\n      this.checkLVal(expr)\n      this.next()\n      expr = this.finishNode(node, \"UpdateExpression\")\n    }\n  }\n\n  if (!sawUnary && this.eat(tt.starstar))\n    return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false)\n  else\n    return expr\n}\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp.parseExprSubscripts = function(refDestructuringErrors) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseExprAtom(refDestructuringErrors)\n  let skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\"\n  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr\n  return this.parseSubscripts(expr, startPos, startLoc)\n}\n\npp.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n  for (;;) {\n    if (this.eat(tt.dot)) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.object = base\n      node.property = this.parseIdent(true)\n      node.computed = false\n      base = this.finishNode(node, \"MemberExpression\")\n    } else if (this.eat(tt.bracketL)) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.object = base\n      node.property = this.parseExpression()\n      node.computed = true\n      this.expect(tt.bracketR)\n      base = this.finishNode(node, \"MemberExpression\")\n    } else if (!noCalls && this.eat(tt.parenL)) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.callee = base\n      node.arguments = this.parseExprList(tt.parenR, false)\n      base = this.finishNode(node, \"CallExpression\")\n    } else if (this.type === tt.backQuote) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.tag = base\n      node.quasi = this.parseTemplate()\n      base = this.finishNode(node, \"TaggedTemplateExpression\")\n    } else {\n      return base\n    }\n  }\n}\n\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp.parseExprAtom = function(refDestructuringErrors) {\n  let node, canBeArrow = this.potentialArrowAt == this.start\n  switch (this.type) {\n  case tt._super:\n    if (!this.inFunction)\n      this.raise(this.start, \"'super' outside of function or class\")\n\n  case tt._this:\n    let type = this.type === tt._this ? \"ThisExpression\" : \"Super\"\n    node = this.startNode()\n    this.next()\n    return this.finishNode(node, type)\n\n  case tt.name:\n    let startPos = this.start, startLoc = this.startLoc\n    let id = this.parseIdent(this.type !== tt.name)\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow))\n      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id])\n    return id\n\n  case tt.regexp:\n    let value = this.value\n    node = this.parseLiteral(value.value)\n    node.regex = {pattern: value.pattern, flags: value.flags}\n    return node\n\n  case tt.num: case tt.string:\n    return this.parseLiteral(this.value)\n\n  case tt._null: case tt._true: case tt._false:\n    node = this.startNode()\n    node.value = this.type === tt._null ? null : this.type === tt._true\n    node.raw = this.type.keyword\n    this.next()\n    return this.finishNode(node, \"Literal\")\n\n  case tt.parenL:\n    return this.parseParenAndDistinguishExpression(canBeArrow)\n\n  case tt.bracketL:\n    node = this.startNode()\n    this.next()\n    node.elements = this.parseExprList(tt.bracketR, true, true, refDestructuringErrors)\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case tt.braceL:\n    return this.parseObj(false, refDestructuringErrors)\n\n  case tt._function:\n    node = this.startNode()\n    this.next()\n    return this.parseFunction(node, false)\n\n  case tt._class:\n    return this.parseClass(this.startNode(), false)\n\n  case tt._new:\n    return this.parseNew()\n\n  case tt.backQuote:\n    return this.parseTemplate()\n\n  default:\n    this.unexpected()\n  }\n}\n\npp.parseLiteral = function(value) {\n  let node = this.startNode()\n  node.value = value\n  node.raw = this.input.slice(this.start, this.end)\n  this.next()\n  return this.finishNode(node, \"Literal\")\n}\n\npp.parseParenExpression = function() {\n  this.expect(tt.parenL)\n  let val = this.parseExpression()\n  this.expect(tt.parenR)\n  return val\n}\n\npp.parseParenAndDistinguishExpression = function(canBeArrow) {\n  let startPos = this.start, startLoc = this.startLoc, val\n  if (this.options.ecmaVersion >= 6) {\n    this.next()\n\n    let innerStartPos = this.start, innerStartLoc = this.startLoc\n    let exprList = [], first = true\n    let refDestructuringErrors = new DestructuringErrors, spreadStart, innerParenStart\n    while (this.type !== tt.parenR) {\n      first ? first = false : this.expect(tt.comma)\n      if (this.type === tt.ellipsis) {\n        spreadStart = this.start\n        exprList.push(this.parseParenItem(this.parseRest()))\n        break\n      } else {\n        if (this.type === tt.parenL && !innerParenStart) {\n          innerParenStart = this.start\n        }\n        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem))\n      }\n    }\n    let innerEndPos = this.start, innerEndLoc = this.startLoc\n    this.expect(tt.parenR)\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, true)\n      if (innerParenStart) this.unexpected(innerParenStart)\n      return this.parseParenArrowList(startPos, startLoc, exprList)\n    }\n\n    if (!exprList.length) this.unexpected(this.lastTokStart)\n    if (spreadStart) this.unexpected(spreadStart)\n    this.checkExpressionErrors(refDestructuringErrors, true)\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc)\n      val.expressions = exprList\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc)\n    } else {\n      val = exprList[0]\n    }\n  } else {\n    val = this.parseParenExpression()\n  }\n\n  if (this.options.preserveParens) {\n    let par = this.startNodeAt(startPos, startLoc)\n    par.expression = val\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n}\n\npp.parseParenItem = function(item) {\n  return item\n}\n\npp.parseParenArrowList = function(startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n}\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call — at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nconst empty = []\n\npp.parseNew = function() {\n  let node = this.startNode()\n  let meta = this.parseIdent(true)\n  if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {\n    node.meta = meta\n    node.property = this.parseIdent(true)\n    if (node.property.name !== \"target\")\n      this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\")\n    if (!this.inFunction)\n      this.raiseRecoverable(node.start, \"new.target can only be used in functions\")\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  let startPos = this.start, startLoc = this.startLoc\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true)\n  if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, false)\n  else node.arguments = empty\n  return this.finishNode(node, \"NewExpression\")\n}\n\n// Parse template expression.\n\npp.parseTemplateElement = function() {\n  let elem = this.startNode()\n  elem.value = {\n    raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, '\\n'),\n    cooked: this.value\n  }\n  this.next()\n  elem.tail = this.type === tt.backQuote\n  return this.finishNode(elem, \"TemplateElement\")\n}\n\npp.parseTemplate = function() {\n  let node = this.startNode()\n  this.next()\n  node.expressions = []\n  let curElt = this.parseTemplateElement()\n  node.quasis = [curElt]\n  while (!curElt.tail) {\n    this.expect(tt.dollarBraceL)\n    node.expressions.push(this.parseExpression())\n    this.expect(tt.braceR)\n    node.quasis.push(curElt = this.parseTemplateElement())\n  }\n  this.next()\n  return this.finishNode(node, \"TemplateLiteral\")\n}\n\n// Parse an object literal or binding pattern.\n\npp.parseObj = function(isPattern, refDestructuringErrors) {\n  let node = this.startNode(), first = true, propHash = {}\n  node.properties = []\n  this.next()\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this.expect(tt.comma)\n      if (this.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    let prop = this.startNode(), isGenerator, startPos, startLoc\n    if (this.options.ecmaVersion >= 6) {\n      prop.method = false\n      prop.shorthand = false\n      if (isPattern || refDestructuringErrors) {\n        startPos = this.start\n        startLoc = this.startLoc\n      }\n      if (!isPattern)\n        isGenerator = this.eat(tt.star)\n    }\n    this.parsePropertyName(prop)\n    this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors)\n    this.checkPropClash(prop, propHash)\n    node.properties.push(this.finishNode(prop, \"Property\"))\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n}\n\npp.parsePropertyValue = function(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) {\n  if (this.eat(tt.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors)\n    prop.kind = \"init\"\n  } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {\n    if (isPattern) this.unexpected()\n    prop.kind = \"init\"\n    prop.method = true\n    prop.value = this.parseMethod(isGenerator)\n  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n             (this.type != tt.comma && this.type != tt.braceR)) {\n    if (isGenerator || isPattern) this.unexpected()\n    prop.kind = prop.key.name\n    this.parsePropertyName(prop)\n    prop.value = this.parseMethod(false)\n    let paramCount = prop.kind === \"get\" ? 0 : 1\n    if (prop.value.params.length !== paramCount) {\n      let start = prop.value.start\n      if (prop.kind === \"get\")\n        this.raiseRecoverable(start, \"getter should have no params\")\n      else\n        this.raiseRecoverable(start, \"setter should have exactly one param\")\n    }\n    if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n      this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\")\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    if (this.keywords.test(prop.key.name) ||\n        (this.strict ? this.reservedWordsStrictBind : this.reservedWords).test(prop.key.name) ||\n        (this.inGenerator && prop.key.name == \"yield\"))\n      this.raiseRecoverable(prop.key.start, \"'\" + prop.key.name + \"' can not be used as shorthand property\")\n    prop.kind = \"init\"\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n    } else if (this.type === tt.eq && refDestructuringErrors) {\n      if (!refDestructuringErrors.shorthandAssign)\n        refDestructuringErrors.shorthandAssign = this.start\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n    } else {\n      prop.value = prop.key\n    }\n    prop.shorthand = true\n  } else this.unexpected()\n}\n\npp.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(tt.bracketL)) {\n      prop.computed = true\n      prop.key = this.parseMaybeAssign()\n      this.expect(tt.bracketR)\n      return prop.key\n    } else {\n      prop.computed = false\n    }\n  }\n  return prop.key = this.type === tt.num || this.type === tt.string ? this.parseExprAtom() : this.parseIdent(true)\n}\n\n// Initialize empty function node.\n\npp.initFunction = function(node) {\n  node.id = null\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false\n    node.expression = false\n  }\n}\n\n// Parse object or class method.\n\npp.parseMethod = function(isGenerator) {\n  let node = this.startNode(), oldInGen = this.inGenerator\n  this.inGenerator = isGenerator\n  this.initFunction(node)\n  this.expect(tt.parenL)\n  node.params = this.parseBindingList(tt.parenR, false, false)\n  if (this.options.ecmaVersion >= 6)\n    node.generator = isGenerator\n  this.parseFunctionBody(node, false)\n  this.inGenerator = oldInGen\n  return this.finishNode(node, \"FunctionExpression\")\n}\n\n// Parse arrow function expression with given parameters.\n\npp.parseArrowExpression = function(node, params) {\n  let oldInGen = this.inGenerator\n  this.inGenerator = false\n  this.initFunction(node)\n  node.params = this.toAssignableList(params, true)\n  this.parseFunctionBody(node, true)\n  this.inGenerator = oldInGen\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n}\n\n// Parse function body and check parameters.\n\npp.parseFunctionBody = function(node, isArrowFunction) {\n  let isExpression = isArrowFunction && this.type !== tt.braceL\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign()\n    node.expression = true\n  } else {\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    let oldInFunc = this.inFunction, oldLabels = this.labels\n    this.inFunction = true; this.labels = []\n    node.body = this.parseBlock(true)\n    node.expression = false\n    this.inFunction = oldInFunc; this.labels = oldLabels\n  }\n\n  // If this is a strict mode function, verify that argument names\n  // are not repeated, and it does not try to bind the words `eval`\n  // or `arguments`.\n  if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {\n    let oldStrict = this.strict\n    this.strict = true\n    if (node.id)\n      this.checkLVal(node.id, true)\n    this.checkParams(node)\n    this.strict = oldStrict\n  } else if (isArrowFunction) {\n    this.checkParams(node)\n  }\n}\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp.checkParams = function(node) {\n    let nameHash = {}\n    for (let i = 0; i < node.params.length; i++)\n      this.checkLVal(node.params[i], true, nameHash)\n}\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  let elts = [], first = true\n  while (!this.eat(close)) {\n    if (!first) {\n      this.expect(tt.comma)\n      if (allowTrailingComma && this.afterTrailingComma(close)) break\n    } else first = false\n\n    let elt\n    if (allowEmpty && this.type === tt.comma)\n      elt = null\n    else if (this.type === tt.ellipsis) {\n      elt = this.parseSpread(refDestructuringErrors)\n      if (this.type === tt.comma && refDestructuringErrors && !refDestructuringErrors.trailingComma) {\n        refDestructuringErrors.trailingComma = this.lastTokStart\n      }\n    } else\n      elt = this.parseMaybeAssign(false, refDestructuringErrors)\n    elts.push(elt)\n  }\n  return elts\n}\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp.parseIdent = function(liberal) {\n  let node = this.startNode()\n  if (liberal && this.options.allowReserved == \"never\") liberal = false\n  if (this.type === tt.name) {\n    if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) &&\n        (this.options.ecmaVersion >= 6 ||\n         this.input.slice(this.start, this.end).indexOf(\"\\\\\") == -1))\n      this.raiseRecoverable(this.start, \"The keyword '\" + this.value + \"' is reserved\")\n    if (!liberal && this.inGenerator && this.value === \"yield\")\n      this.raiseRecoverable(this.start, \"Can not use 'yield' as identifier inside a generator\")\n    node.name = this.value\n  } else if (liberal && this.type.keyword) {\n    node.name = this.type.keyword\n  } else {\n    this.unexpected()\n  }\n  this.next()\n  return this.finishNode(node, \"Identifier\")\n}\n\n// Parses yield expression inside generator.\n\npp.parseYield = function() {\n  let node = this.startNode()\n  this.next()\n  if (this.type == tt.semi || this.canInsertSemicolon() || (this.type != tt.star && !this.type.startsExpr)) {\n    node.delegate = false\n    node.argument = null\n  } else {\n    node.delegate = this.eat(tt.star)\n    node.argument = this.parseMaybeAssign()\n  }\n  return this.finishNode(node, \"YieldExpression\")\n}\n"]}