{"version":3,"sources":["lval.js"],"names":[],"mappings":"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","file":"lval-compiled.js","sourcesContent":["import {types as tt} from \"./tokentype\"\nimport {Parser} from \"./state\"\nimport {has} from \"./util\"\n\nconst pp = Parser.prototype\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp.toAssignable = function(node, isBinding) {\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n    case \"Identifier\":\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\"\n      for (let i = 0; i < node.properties.length; i++) {\n        let prop = node.properties[i]\n        if (prop.kind !== \"init\") this.raise(prop.key.start, \"Object pattern can't contain getter or setter\")\n        this.toAssignable(prop.value, isBinding)\n      }\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\"\n      this.toAssignableList(node.elements, isBinding)\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator === \"=\") {\n        node.type = \"AssignmentPattern\"\n        delete node.operator\n        // falls through to AssignmentPattern\n      } else {\n        this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\")\n        break\n      }\n\n    case \"AssignmentPattern\":\n      if (node.right.type === \"YieldExpression\")\n        this.raise(node.right.start, \"Yield expression cannot be a default value\")\n      break\n\n    case \"ParenthesizedExpression\":\n      node.expression = this.toAssignable(node.expression, isBinding)\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) break\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\")\n    }\n  }\n  return node\n}\n\n// Convert list of expression atoms to binding list.\n\npp.toAssignableList = function(exprList, isBinding) {\n  let end = exprList.length\n  if (end) {\n    let last = exprList[end - 1]\n    if (last && last.type == \"RestElement\") {\n      --end\n    } else if (last && last.type == \"SpreadElement\") {\n      last.type = \"RestElement\"\n      let arg = last.argument\n      this.toAssignable(arg, isBinding)\n      if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\")\n        this.unexpected(arg.start)\n      --end\n    }\n\n    if (isBinding && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      this.unexpected(last.argument.start)\n  }\n  for (let i = 0; i < end; i++) {\n    let elt = exprList[i]\n    if (elt) this.toAssignable(elt, isBinding)\n  }\n  return exprList\n}\n\n// Parses spread element.\n\npp.parseSpread = function(refDestructuringErrors) {\n  let node = this.startNode()\n  this.next()\n  node.argument = this.parseMaybeAssign(refDestructuringErrors)\n  return this.finishNode(node, \"SpreadElement\")\n}\n\npp.parseRest = function(allowNonIdent) {\n  let node = this.startNode()\n  this.next()\n\n  // RestElement inside of a function parameter must be an identifier\n  if (allowNonIdent) node.argument = this.type === tt.name ? this.parseIdent() : this.unexpected()\n  else node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected()\n\n  return this.finishNode(node, \"RestElement\")\n}\n\n// Parses lvalue (assignable) atom.\n\npp.parseBindingAtom = function() {\n  if (this.options.ecmaVersion < 6) return this.parseIdent()\n  switch (this.type) {\n  case tt.name:\n    return this.parseIdent()\n\n  case tt.bracketL:\n    let node = this.startNode()\n    this.next()\n    node.elements = this.parseBindingList(tt.bracketR, true, true)\n    return this.finishNode(node, \"ArrayPattern\")\n\n  case tt.braceL:\n    return this.parseObj(true)\n\n  default:\n    this.unexpected()\n  }\n}\n\npp.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowNonIdent) {\n  let elts = [], first = true\n  while (!this.eat(close)) {\n    if (first) first = false\n    else this.expect(tt.comma)\n    if (allowEmpty && this.type === tt.comma) {\n      elts.push(null)\n    } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n      break\n    } else if (this.type === tt.ellipsis) {\n      let rest = this.parseRest(allowNonIdent)\n      this.parseBindingListItem(rest)\n      elts.push(rest)\n      if (this.type === tt.comma) this.raise(this.start, \"Comma is not permitted after the rest element\")\n      this.expect(close)\n      break\n    } else {\n      let elem = this.parseMaybeDefault(this.start, this.startLoc)\n      this.parseBindingListItem(elem)\n      elts.push(elem)\n    }\n  }\n  return elts\n}\n\npp.parseBindingListItem = function(param) {\n  return param\n}\n\n// Parses assignment pattern around given atom if possible.\n\npp.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom()\n  if (this.options.ecmaVersion < 6 || !this.eat(tt.eq)) return left\n  let node = this.startNodeAt(startPos, startLoc)\n  node.left = left\n  node.right = this.parseMaybeAssign()\n  return this.finishNode(node, \"AssignmentPattern\")\n}\n\n// Verify that a node is an lval — something that can be assigned\n// to.\n\npp.checkLVal = function(expr, isBinding, checkClashes) {\n  switch (expr.type) {\n  case \"Identifier\":\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      this.raiseRecoverable(expr.start, (isBinding ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\")\n    if (checkClashes) {\n      if (has(checkClashes, expr.name))\n        this.raiseRecoverable(expr.start, \"Argument name clash\")\n      checkClashes[expr.name] = true\n    }\n    break\n\n  case \"MemberExpression\":\n    if (isBinding) this.raiseRecoverable(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" member expression\")\n    break\n\n  case \"ObjectPattern\":\n    for (let i = 0; i < expr.properties.length; i++)\n      this.checkLVal(expr.properties[i].value, isBinding, checkClashes)\n    break\n\n  case \"ArrayPattern\":\n    for (let i = 0; i < expr.elements.length; i++) {\n      let elem = expr.elements[i]\n      if (elem) this.checkLVal(elem, isBinding, checkClashes)\n    }\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLVal(expr.left, isBinding, checkClashes)\n    break\n\n  case \"RestElement\":\n    this.checkLVal(expr.argument, isBinding, checkClashes)\n    break\n\n  case \"ParenthesizedExpression\":\n    this.checkLVal(expr.expression, isBinding, checkClashes)\n    break\n\n  default:\n    this.raise(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" rvalue\")\n  }\n}\n"]}