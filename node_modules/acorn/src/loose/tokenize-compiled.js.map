{"version":3,"sources":["tokenize.js"],"names":[],"mappings":"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","file":"tokenize-compiled.js","sourcesContent":["import {tokTypes as tt, Token, isNewLine, SourceLocation, getLineInfo, lineBreakG} from \"..\"\nimport {LooseParser} from \"./state\"\n\nconst lp = LooseParser.prototype\n\nfunction isSpace(ch) {\n  return (ch < 14 && ch > 8) || ch === 32 || ch === 160 || isNewLine(ch)\n}\n\nlp.next = function() {\n  this.last = this.tok\n  if (this.ahead.length)\n    this.tok = this.ahead.shift()\n  else\n    this.tok = this.readToken()\n\n  if (this.tok.start >= this.nextLineStart) {\n    while (this.tok.start >= this.nextLineStart) {\n      this.curLineStart = this.nextLineStart\n      this.nextLineStart = this.lineEnd(this.curLineStart) + 1\n    }\n    this.curIndent = this.indentationAfter(this.curLineStart)\n  }\n}\n\nlp.readToken = function() {\n  for (;;) {\n    try {\n      this.toks.next()\n      if (this.toks.type === tt.dot &&\n          this.input.substr(this.toks.end, 1) === \".\" &&\n          this.options.ecmaVersion >= 6) {\n        this.toks.end++\n        this.toks.type = tt.ellipsis\n      }\n      return new Token(this.toks)\n    } catch(e) {\n      if (!(e instanceof SyntaxError)) throw e\n\n      // Try to skip some text, based on the error message, and then continue\n      let msg = e.message, pos = e.raisedAt, replace = true\n      if (/unterminated/i.test(msg)) {\n        pos = this.lineEnd(e.pos + 1)\n        if (/string/.test(msg)) {\n          replace = {start: e.pos, end: pos, type: tt.string, value: this.input.slice(e.pos + 1, pos)}\n        } else if (/regular expr/i.test(msg)) {\n          let re = this.input.slice(e.pos, pos)\n          try { re = new RegExp(re) } catch(e) {}\n          replace = {start: e.pos, end: pos, type: tt.regexp, value: re}\n        } else if (/template/.test(msg)) {\n          replace = {start: e.pos, end: pos,\n                     type: tt.template,\n                     value: this.input.slice(e.pos, pos)}\n        } else {\n          replace = false\n        }\n      } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) {\n        while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) ++pos\n      } else if (/character escape|expected hexadecimal/i.test(msg)) {\n        while (pos < this.input.length) {\n          let ch = this.input.charCodeAt(pos++)\n          if (ch === 34 || ch === 39 || isNewLine(ch)) break\n        }\n      } else if (/unexpected character/i.test(msg)) {\n        pos++\n        replace = false\n      } else if (/regular expression/i.test(msg)) {\n        replace = true\n      } else {\n        throw e\n      }\n      this.resetTo(pos)\n      if (replace === true) replace = {start: pos, end: pos, type: tt.name, value: \"âœ–\"}\n      if (replace) {\n        if (this.options.locations)\n          replace.loc = new SourceLocation(\n            this.toks,\n            getLineInfo(this.input, replace.start),\n            getLineInfo(this.input, replace.end))\n        return replace\n      }\n    }\n  }\n}\n\nlp.resetTo = function(pos) {\n  this.toks.pos = pos\n  let ch = this.input.charAt(pos - 1)\n  this.toks.exprAllowed = !ch || /[\\[\\{\\(,;:?\\/*=+\\-~!|&%^<>]/.test(ch) ||\n    /[enwfd]/.test(ch) &&\n    /\\b(keywords|case|else|return|throw|new|in|(instance|type)of|delete|void)$/.test(this.input.slice(pos - 10, pos))\n\n  if (this.options.locations) {\n    this.toks.curLine = 1\n    this.toks.lineStart = lineBreakG.lastIndex = 0\n    let match\n    while ((match = lineBreakG.exec(this.input)) && match.index < pos) {\n      ++this.toks.curLine\n      this.toks.lineStart = match.index + match[0].length\n    }\n  }\n}\n\nlp.lookAhead = function(n) {\n  while (n > this.ahead.length)\n    this.ahead.push(this.readToken())\n  return this.ahead[n - 1]\n}\n"]}