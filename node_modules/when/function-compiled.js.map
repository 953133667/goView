{"version":3,"sources":["function.js"],"names":[],"mappings":"AAAA;;AAEA;;;;;;;;AAQA,CAAC,UAAS,MAAT,EAAiB;AAClB,QAAO,UAAS,OAAT,EAAkB;;AAExB,MAAI,OAAO,QAAQ,QAAR,CAAX;AACA,MAAI,UAAU,KAAK,KAAL,CAAd;AACA,MAAI,WAAW,QAAQ,eAAR,CAAf;AACA,MAAI,SAAS,QAAQ,aAAR,EAAuB,KAAK,OAA5B,CAAb;AACA,MAAI,QAAQ,MAAM,SAAN,CAAgB,KAA5B;;AAEA,SAAO;AACN,SAAM,IADA;AAEN,YAAS,OAFH;AAGN,SAAM,OAHA;AAIN,UAAO,KAJD;AAKN,YAAS;AALH,GAAP;;AAQA;;;;;;;;AAQA,WAAS,KAAT,CAAe,CAAf,EAAkB,IAAlB,EAAwB;AACvB;AACA,UAAO,OAAO,CAAP,EAAU,IAAV,EAAgB,QAAQ,IAAR,GAAe,EAAf,GAAoB,MAAM,IAAN,CAAW,IAAX,CAApC,CAAP;AACA;;AAED;;;;;;;;;;;;AAYA,WAAS,IAAT,CAAc,CAAd,CAAgB,cAAhB,EAAgC;AAC/B,OAAI,OAAO,UAAU,MAAV,GAAmB,CAAnB,GAAuB,MAAM,IAAN,CAAW,SAAX,EAAsB,CAAtB,CAAvB,GAAkD,EAA7D;AACA,UAAO,YAAW;AACjB,WAAO,OAAO,CAAP,EAAU,IAAV,EAAgB,KAAK,MAAL,CAAY,MAAM,IAAN,CAAW,SAAX,CAAZ,CAAhB,CAAP;AACA,IAFD;AAGA;;AAED;;;;;;;;;;;AAWA,WAAS,OAAT,CAAiB,GAAjB,EAAsB,OAAtB,EAA+B,GAA/B,EAAoC;AACnC,UAAO,SAAS,IAAT,EAAe,OAAf,EAAwB,GAAxB,EAA6B,GAA7B,CAAP;AACA;;AAED;;;;;;;;;;;;;AAaA,WAAS,OAAT,CAAiB,CAAjB,CAAmB,eAAnB,EAAoC;AACnC,OAAI,QAAQ,MAAM,IAAN,CAAW,SAAX,EAAsB,CAAtB,CAAZ;;AAEA,UAAO,YAAW;AACjB,QAAI,UAAU,IAAd;AACA,QAAI,OAAO,MAAM,IAAN,CAAW,SAAX,CAAX;AACA,QAAI,eAAe,QAAQ,KAAR,CAAc,OAAd,EAAuB,CAAC,CAAD,EAAI,MAAJ,CAAW,IAAX,CAAvB,CAAnB;;AAEA,WAAO,KAAK,MAAL,CAAY,KAAZ,EAAmB,UAAS,GAAT,EAAc,IAAd,EAAoB;AAC7C,YAAO,KAAK,IAAL,CAAU,OAAV,EAAmB,GAAnB,CAAP;AACA,KAFM,EAEJ,YAFI,CAAP;AAGA,IARD;AASA;AACD,EAzFD;AA0FC,CA3FD,EA2FG,OAAO,MAAP,KAAkB,UAAlB,IAAgC,OAAO,GAAvC,GAA6C,MAA7C,GAAsD,UAAU,OAAV,EAAmB;AAAE,QAAO,OAAP,GAAiB,QAAQ,OAAR,CAAjB;AAAoC,CA3FlH","file":"function-compiled.js","sourcesContent":["/** @license MIT License (c) copyright 2013-2014 original author or authors */\n\n/**\n * Collection of helper functions for wrapping and executing 'traditional'\n * synchronous functions in a promise interface.\n *\n * @author Brian Cavalier\n * @contributor Renato Zannon\n */\n\n(function(define) {\ndefine(function(require) {\n\n\tvar when = require('./when');\n\tvar attempt = when['try'];\n\tvar _liftAll = require('./lib/liftAll');\n\tvar _apply = require('./lib/apply')(when.Promise);\n\tvar slice = Array.prototype.slice;\n\n\treturn {\n\t\tlift: lift,\n\t\tliftAll: liftAll,\n\t\tcall: attempt,\n\t\tapply: apply,\n\t\tcompose: compose\n\t};\n\n\t/**\n\t * Takes a function and an optional array of arguments (that might be promises),\n\t * and calls the function. The return value is a promise whose resolution\n\t * depends on the value returned by the function.\n\t * @param {function} f function to be called\n\t * @param {Array} [args] array of arguments to func\n\t * @returns {Promise} promise for the return value of func\n\t */\n\tfunction apply(f, args) {\n\t\t// slice args just in case the caller passed an Arguments instance\n\t\treturn _apply(f, this, args == null ? [] : slice.call(args));\n\t}\n\n\t/**\n\t * Takes a 'regular' function and returns a version of that function that\n\t * returns a promise instead of a plain value, and handles thrown errors by\n\t * returning a rejected promise. Also accepts a list of arguments to be\n\t * prepended to the new function, as does Function.prototype.bind.\n\t *\n\t * The resulting function is promise-aware, in the sense that it accepts\n\t * promise arguments, and waits for their resolution.\n\t * @param {Function} f function to be bound\n\t * @param {...*} [args] arguments to be prepended for the new function @deprecated\n\t * @returns {Function} a promise-returning function\n\t */\n\tfunction lift(f /*, args... */) {\n\t\tvar args = arguments.length > 1 ? slice.call(arguments, 1) : [];\n\t\treturn function() {\n\t\t\treturn _apply(f, this, args.concat(slice.call(arguments)));\n\t\t};\n\t}\n\n\t/**\n\t * Lift all the functions/methods on src\n\t * @param {object|function} src source whose functions will be lifted\n\t * @param {function?} combine optional function for customizing the lifting\n\t *  process. It is passed dst, the lifted function, and the property name of\n\t *  the original function on src.\n\t * @param {(object|function)?} dst option destination host onto which to place lifted\n\t *  functions. If not provided, liftAll returns a new object.\n\t * @returns {*} If dst is provided, returns dst with lifted functions as\n\t *  properties.  If dst not provided, returns a new object with lifted functions.\n\t */\n\tfunction liftAll(src, combine, dst) {\n\t\treturn _liftAll(lift, combine, dst, src);\n\t}\n\n\t/**\n\t * Composes multiple functions by piping their return values. It is\n\t * transparent to whether the functions return 'regular' values or promises:\n\t * the piped argument is always a resolved value. If one of the functions\n\t * throws or returns a rejected promise, the composed promise will be also\n\t * rejected.\n\t *\n\t * The arguments (or promises to arguments) given to the returned function (if\n\t * any), are passed directly to the first function on the 'pipeline'.\n\t * @param {Function} f the function to which the arguments will be passed\n\t * @param {...Function} [funcs] functions that will be composed, in order\n\t * @returns {Function} a promise-returning composition of the functions\n\t */\n\tfunction compose(f /*, funcs... */) {\n\t\tvar funcs = slice.call(arguments, 1);\n\n\t\treturn function() {\n\t\t\tvar thisArg = this;\n\t\t\tvar args = slice.call(arguments);\n\t\t\tvar firstPromise = attempt.apply(thisArg, [f].concat(args));\n\n\t\t\treturn when.reduce(funcs, function(arg, func) {\n\t\t\t\treturn func.call(thisArg, arg);\n\t\t\t}, firstPromise);\n\t\t};\n\t}\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n\n\n"]}