{"version":3,"sources":["node.js"],"names":[],"mappings":"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","file":"node-compiled.js","sourcesContent":["/** @license MIT License (c) copyright 2013 original author or authors */\n\n/**\n * Collection of helpers for interfacing with node-style asynchronous functions\n * using promises.\n *\n * @author Brian Cavalier\n * @contributor Renato Zannon\n */\n\n(function(define) {\ndefine(function(require) {\n\n\tvar when = require('./when');\n\tvar _liftAll = require('./lib/liftAll');\n\tvar setTimer = require('./lib/env').setTimer;\n\tvar slice = Array.prototype.slice;\n\n\tvar _apply = require('./lib/apply')(when.Promise, dispatch);\n\n\treturn {\n\t\tlift: lift,\n\t\tliftAll: liftAll,\n\t\tapply: apply,\n\t\tcall: call,\n\t\tcreateCallback: createCallback,\n\t\tbindCallback: bindCallback,\n\t\tliftCallback: liftCallback\n\t};\n\n\t/**\n\t * Takes a node-style async function and calls it immediately (with an optional\n\t * array of arguments or promises for arguments). It returns a promise whose\n\t * resolution depends on whether the async functions calls its callback with the\n\t * conventional error argument or not.\n\t *\n\t * With this it becomes possible to leverage existing APIs while still reaping\n\t * the benefits of promises.\n\t *\n\t * @example\n\t *    function onlySmallNumbers(n, callback) {\n\t *\t\tif(n < 10) {\n\t *\t\t\tcallback(null, n + 10);\n\t *\t\t} else {\n\t *\t\t\tcallback(new Error(\"Calculation failed\"));\n\t *\t\t}\n\t *\t}\n\t *\n\t *    var nodefn = require(\"when/node/function\");\n\t *\n\t *    // Logs '15'\n\t *    nodefn.apply(onlySmallNumbers, [5]).then(console.log, console.error);\n\t *\n\t *    // Logs 'Calculation failed'\n\t *    nodefn.apply(onlySmallNumbers, [15]).then(console.log, console.error);\n\t *\n\t * @param {function} f node-style function that will be called\n\t * @param {Array} [args] array of arguments to func\n\t * @returns {Promise} promise for the value func passes to its callback\n\t */\n\tfunction apply(f, args) {\n\t\treturn _apply(f, this, args || []);\n\t}\n\n\tfunction dispatch(f, thisArg, args, h) {\n\t\tvar cb = createCallback(h);\n\t\ttry {\n\t\t\tswitch(args.length) {\n\t\t\t\tcase 2: f.call(thisArg, args[0], args[1], cb); break;\n\t\t\t\tcase 1: f.call(thisArg, args[0], cb); break;\n\t\t\t\tcase 0: f.call(thisArg, cb); break;\n\t\t\t\tdefault:\n\t\t\t\t\targs.push(cb);\n\t\t\t\t\tf.apply(thisArg, args);\n\t\t\t}\n\t\t} catch(e) {\n\t\t\th.reject(e);\n\t\t}\n\t}\n\n\t/**\n\t * Has the same behavior that {@link apply} has, with the difference that the\n\t * arguments to the function are provided individually, while {@link apply} accepts\n\t * a single array.\n\t *\n\t * @example\n\t *    function sumSmallNumbers(x, y, callback) {\n\t *\t\tvar result = x + y;\n\t *\t\tif(result < 10) {\n\t *\t\t\tcallback(null, result);\n\t *\t\t} else {\n\t *\t\t\tcallback(new Error(\"Calculation failed\"));\n\t *\t\t}\n\t *\t}\n\t *\n\t *    // Logs '5'\n\t *    nodefn.call(sumSmallNumbers, 2, 3).then(console.log, console.error);\n\t *\n\t *    // Logs 'Calculation failed'\n\t *    nodefn.call(sumSmallNumbers, 5, 10).then(console.log, console.error);\n\t *\n\t * @param {function} f node-style function that will be called\n\t * @param {...*} [args] arguments that will be forwarded to the function\n\t * @returns {Promise} promise for the value func passes to its callback\n\t */\n\tfunction call(f /*, args... */) {\n\t\treturn _apply(f, this, slice.call(arguments, 1));\n\t}\n\n\t/**\n\t * Takes a node-style function and returns new function that wraps the\n\t * original and, instead of taking a callback, returns a promise. Also, it\n\t * knows how to handle promises given as arguments, waiting for their\n\t * resolution before executing.\n\t *\n\t * Upon execution, the orginal function is executed as well. If it passes\n\t * a truthy value as the first argument to the callback, it will be\n\t * interpreted as an error condition, and the promise will be rejected\n\t * with it. Otherwise, the call is considered a resolution, and the promise\n\t * is resolved with the callback's second argument.\n\t *\n\t * @example\n\t *    var fs = require(\"fs\"), nodefn = require(\"when/node/function\");\n\t *\n\t *    var promiseRead = nodefn.lift(fs.readFile);\n\t *\n\t *    // The promise is resolved with the contents of the file if everything\n\t *    // goes ok\n\t *    promiseRead('exists.txt').then(console.log, console.error);\n\t *\n\t *    // And will be rejected if something doesn't work out\n\t *    // (e.g. the files does not exist)\n\t *    promiseRead('doesnt_exist.txt').then(console.log, console.error);\n\t *\n\t *\n\t * @param {Function} f node-style function to be lifted\n\t * @param {...*} [args] arguments to be prepended for the new function @deprecated\n\t * @returns {Function} a promise-returning function\n\t */\n\tfunction lift(f /*, args... */) {\n\t\tvar args1 = arguments.length > 1 ? slice.call(arguments, 1) : [];\n\t\treturn function() {\n\t\t\t// TODO: Simplify once partialing has been removed\n\t\t\tvar l = args1.length;\n\t\t\tvar al = arguments.length;\n\t\t\tvar args = new Array(al + l);\n\t\t\tvar i;\n\t\t\tfor(i=0; i<l; ++i) {\n\t\t\t\targs[i] = args1[i];\n\t\t\t}\n\t\t\tfor(i=0; i<al; ++i) {\n\t\t\t\targs[i+l] = arguments[i];\n\t\t\t}\n\t\t\treturn _apply(f, this, args);\n\t\t};\n\t}\n\n\t/**\n\t * Lift all the functions/methods on src\n\t * @param {object|function} src source whose functions will be lifted\n\t * @param {function?} combine optional function for customizing the lifting\n\t *  process. It is passed dst, the lifted function, and the property name of\n\t *  the original function on src.\n\t * @param {(object|function)?} dst option destination host onto which to place lifted\n\t *  functions. If not provided, liftAll returns a new object.\n\t * @returns {*} If dst is provided, returns dst with lifted functions as\n\t *  properties.  If dst not provided, returns a new object with lifted functions.\n\t */\n\tfunction liftAll(src, combine, dst) {\n\t\treturn _liftAll(lift, combine, dst, src);\n\t}\n\n\t/**\n\t * Takes an object that responds to the resolver interface, and returns\n\t * a function that will resolve or reject it depending on how it is called.\n\t *\n\t * @example\n\t *\tfunction callbackTakingFunction(callback) {\n\t *\t\tif(somethingWrongHappened) {\n\t *\t\t\tcallback(error);\n\t *\t\t} else {\n\t *\t\t\tcallback(null, interestingValue);\n\t *\t\t}\n\t *\t}\n\t *\n\t *\tvar when = require('when'), nodefn = require('when/node/function');\n\t *\n\t *\tvar deferred = when.defer();\n\t *\tcallbackTakingFunction(nodefn.createCallback(deferred.resolver));\n\t *\n\t *\tdeferred.promise.then(function(interestingValue) {\n\t *\t\t// Use interestingValue\n\t *\t});\n\t *\n\t * @param {Resolver} resolver that will be 'attached' to the callback\n\t * @returns {Function} a node-style callback function\n\t */\n\tfunction createCallback(resolver) {\n\t\treturn function(err, value) {\n\t\t\tif(err) {\n\t\t\t\tresolver.reject(err);\n\t\t\t} else if(arguments.length > 2) {\n\t\t\t\tresolver.resolve(slice.call(arguments, 1));\n\t\t\t} else {\n\t\t\t\tresolver.resolve(value);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Attaches a node-style callback to a promise, ensuring the callback is\n\t * called for either fulfillment or rejection. Returns a promise with the same\n\t * state as the passed-in promise.\n\t *\n\t * @example\n\t *\tvar deferred = when.defer();\n\t *\n\t *\tfunction callback(err, value) {\n\t *\t\t// Handle err or use value\n\t *\t}\n\t *\n\t *\tbindCallback(deferred.promise, callback);\n\t *\n\t *\tdeferred.resolve('interesting value');\n\t *\n\t * @param {Promise} promise The promise to be attached to.\n\t * @param {Function} callback The node-style callback to attach.\n\t * @returns {Promise} A promise with the same state as the passed-in promise.\n\t */\n\tfunction bindCallback(promise, callback) {\n\t\tpromise = when(promise);\n\n\t\tif (callback) {\n\t\t\tpromise.then(success, wrapped);\n\t\t}\n\n\t\treturn promise;\n\n\t\tfunction success(value) {\n\t\t\twrapped(null, value);\n\t\t}\n\n\t\tfunction wrapped(err, value) {\n\t\t\tsetTimer(function () {\n\t\t\t\tcallback(err, value);\n\t\t\t}, 0);\n\t\t}\n\t}\n\n\t/**\n\t * Takes a node-style callback and returns new function that accepts a\n\t * promise, calling the original callback when the promise is either\n\t * fulfilled or rejected with the appropriate arguments.\n\t *\n\t * @example\n\t *\tvar deferred = when.defer();\n\t *\n\t *\tfunction callback(err, value) {\n\t *\t\t// Handle err or use value\n\t *\t}\n\t *\n\t *\tvar wrapped = liftCallback(callback);\n\t *\n\t *\t// `wrapped` can now be passed around at will\n\t *\twrapped(deferred.promise);\n\t *\n\t *\tdeferred.resolve('interesting value');\n\t *\n\t * @param {Function} callback The node-style callback to wrap.\n\t * @returns {Function} The lifted, promise-accepting function.\n\t */\n\tfunction liftCallback(callback) {\n\t\treturn function(promise) {\n\t\t\treturn bindCallback(promise, callback);\n\t\t};\n\t}\n});\n\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n\n\n\n"]}