{"version":3,"sources":["callbacks.js"],"names":[],"mappings":"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","file":"callbacks-compiled.js","sourcesContent":["/** @license MIT License (c) copyright 2013-2014 original author or authors */\n\n/**\n * Collection of helper functions for interacting with 'traditional',\n * callback-taking functions using a promise interface.\n *\n * @author Renato Zannon\n * @contributor Brian Cavalier\n */\n\n(function(define) {\ndefine(function(require) {\n\n\tvar when = require('./when');\n\tvar Promise = when.Promise;\n\tvar _liftAll = require('./lib/liftAll');\n\tvar slice = Array.prototype.slice;\n\n\tvar makeApply = require('./lib/apply');\n\tvar _apply = makeApply(Promise, dispatch);\n\n\treturn {\n\t\tlift: lift,\n\t\tliftAll: liftAll,\n\t\tapply: apply,\n\t\tcall: call,\n\t\tpromisify: promisify\n\t};\n\n\t/**\n\t * Takes a `traditional` callback-taking function and returns a promise for its\n\t * result, accepting an optional array of arguments (that might be values or\n\t * promises). It assumes that the function takes its callback and errback as\n\t * the last two arguments. The resolution of the promise depends on whether the\n\t * function will call its callback or its errback.\n\t *\n\t * @example\n\t *    var domIsLoaded = callbacks.apply($);\n\t *    domIsLoaded.then(function() {\n\t *\t\tdoMyDomStuff();\n\t *\t});\n\t *\n\t * @example\n\t *    function existingAjaxyFunction(url, callback, errback) {\n\t *\t\t// Complex logic you'd rather not change\n\t *\t}\n\t *\n\t *    var promise = callbacks.apply(existingAjaxyFunction, [\"/movies.json\"]);\n\t *\n\t *    promise.then(function(movies) {\n\t *\t\t// Work with movies\n\t *\t}, function(reason) {\n\t *\t\t// Handle error\n\t *\t});\n\t *\n\t * @param {function} asyncFunction function to be called\n\t * @param {Array} [extraAsyncArgs] array of arguments to asyncFunction\n\t * @returns {Promise} promise for the callback value of asyncFunction\n\t */\n\tfunction apply(asyncFunction, extraAsyncArgs) {\n\t\treturn _apply(asyncFunction, this, extraAsyncArgs || []);\n\t}\n\n\t/**\n\t * Apply helper that allows specifying thisArg\n\t * @private\n\t */\n\tfunction dispatch(f, thisArg, args, h) {\n\t\targs.push(alwaysUnary(h.resolve, h), alwaysUnary(h.reject, h));\n\t\ttryCatchResolve(f, thisArg, args, h);\n\t}\n\n\tfunction tryCatchResolve(f, thisArg, args, resolver) {\n\t\ttry {\n\t\t\tf.apply(thisArg, args);\n\t\t} catch(e) {\n\t\t\tresolver.reject(e);\n\t\t}\n\t}\n\n\t/**\n\t * Works as `callbacks.apply` does, with the difference that the arguments to\n\t * the function are passed individually, instead of as an array.\n\t *\n\t * @example\n\t *    function sumInFiveSeconds(a, b, callback) {\n\t *\t\tsetTimeout(function() {\n\t *\t\t\tcallback(a + b);\n\t *\t\t}, 5000);\n\t *\t}\n\t *\n\t *    var sumPromise = callbacks.call(sumInFiveSeconds, 5, 10);\n\t *\n\t *    // Logs '15' 5 seconds later\n\t *    sumPromise.then(console.log);\n\t *\n\t * @param {function} asyncFunction function to be called\n\t * @param {...*} args arguments that will be forwarded to the function\n\t * @returns {Promise} promise for the callback value of asyncFunction\n\t */\n\tfunction call(asyncFunction/*, arg1, arg2...*/) {\n\t\treturn _apply(asyncFunction, this, slice.call(arguments, 1));\n\t}\n\n\t/**\n\t * Takes a 'traditional' callback/errback-taking function and returns a function\n\t * that returns a promise instead. The resolution/rejection of the promise\n\t * depends on whether the original function will call its callback or its\n\t * errback.\n\t *\n\t * If additional arguments are passed to the `lift` call, they will be prepended\n\t * on the calls to the original function, much like `Function.prototype.bind`.\n\t *\n\t * The resulting function is also \"promise-aware\", in the sense that, if given\n\t * promises as arguments, it will wait for their resolution before executing.\n\t *\n\t * @example\n\t *    function traditionalAjax(method, url, callback, errback) {\n\t *\t\tvar xhr = new XMLHttpRequest();\n\t *\t\txhr.open(method, url);\n\t *\n\t *\t\txhr.onload = callback;\n\t *\t\txhr.onerror = errback;\n\t *\n\t *\t\txhr.send();\n\t *\t}\n\t *\n\t *    var promiseAjax = callbacks.lift(traditionalAjax);\n\t *    promiseAjax(\"GET\", \"/movies.json\").then(console.log, console.error);\n\t *\n\t *    var promiseAjaxGet = callbacks.lift(traditionalAjax, \"GET\");\n\t *    promiseAjaxGet(\"/movies.json\").then(console.log, console.error);\n\t *\n\t * @param {Function} f traditional async function to be decorated\n\t * @param {...*} [args] arguments to be prepended for the new function @deprecated\n\t * @returns {Function} a promise-returning function\n\t */\n\tfunction lift(f/*, args...*/) {\n\t\tvar args = arguments.length > 1 ? slice.call(arguments, 1) : [];\n\t\treturn function() {\n\t\t\treturn _apply(f, this, args.concat(slice.call(arguments)));\n\t\t};\n\t}\n\n\t/**\n\t * Lift all the functions/methods on src\n\t * @param {object|function} src source whose functions will be lifted\n\t * @param {function?} combine optional function for customizing the lifting\n\t *  process. It is passed dst, the lifted function, and the property name of\n\t *  the original function on src.\n\t * @param {(object|function)?} dst option destination host onto which to place lifted\n\t *  functions. If not provided, liftAll returns a new object.\n\t * @returns {*} If dst is provided, returns dst with lifted functions as\n\t *  properties.  If dst not provided, returns a new object with lifted functions.\n\t */\n\tfunction liftAll(src, combine, dst) {\n\t\treturn _liftAll(lift, combine, dst, src);\n\t}\n\n\t/**\n\t * `promisify` is a version of `lift` that allows fine-grained control over the\n\t * arguments that passed to the underlying function. It is intended to handle\n\t * functions that don't follow the common callback and errback positions.\n\t *\n\t * The control is done by passing an object whose 'callback' and/or 'errback'\n\t * keys, whose values are the corresponding 0-based indexes of the arguments on\n\t * the function. Negative values are interpreted as being relative to the end\n\t * of the arguments array.\n\t *\n\t * If arguments are given on the call to the 'promisified' function, they are\n\t * intermingled with the callback and errback. If a promise is given among them,\n\t * the execution of the function will only occur after its resolution.\n\t *\n\t * @example\n\t *    var delay = callbacks.promisify(setTimeout, {\n\t *\t\tcallback: 0\n\t *\t});\n\t *\n\t *    delay(100).then(function() {\n\t *\t\tconsole.log(\"This happens 100ms afterwards\");\n\t *\t});\n\t *\n\t * @example\n\t *    function callbackAsLast(errback, followsStandards, callback) {\n\t *\t\tif(followsStandards) {\n\t *\t\t\tcallback(\"well done!\");\n\t *\t\t} else {\n\t *\t\t\terrback(\"some programmers just want to watch the world burn\");\n\t *\t\t}\n\t *\t}\n\t *\n\t *    var promisified = callbacks.promisify(callbackAsLast, {\n\t *\t\tcallback: -1,\n\t *\t\terrback:   0,\n\t *\t});\n\t *\n\t *    promisified(true).then(console.log, console.error);\n\t *    promisified(false).then(console.log, console.error);\n\t *\n\t * @param {Function} asyncFunction traditional function to be decorated\n\t * @param {object} positions\n\t * @param {number} [positions.callback] index at which asyncFunction expects to\n\t *  receive a success callback\n\t * @param {number} [positions.errback] index at which asyncFunction expects to\n\t *  receive an error callback\n\t *  @returns {function} promisified function that accepts\n\t *\n\t * @deprecated\n\t */\n\tfunction promisify(asyncFunction, positions) {\n\n\t\treturn function() {\n\t\t\tvar thisArg = this;\n\t\t\treturn Promise.all(arguments).then(function(args) {\n\t\t\t\tvar p = Promise._defer();\n\n\t\t\t\tvar callbackPos, errbackPos;\n\n\t\t\t\tif(typeof positions.callback === 'number') {\n\t\t\t\t\tcallbackPos = normalizePosition(args, positions.callback);\n\t\t\t\t}\n\n\t\t\t\tif(typeof positions.errback === 'number') {\n\t\t\t\t\terrbackPos = normalizePosition(args, positions.errback);\n\t\t\t\t}\n\n\t\t\t\tif(errbackPos < callbackPos) {\n\t\t\t\t\tinsertCallback(args, errbackPos, p._handler.reject, p._handler);\n\t\t\t\t\tinsertCallback(args, callbackPos, p._handler.resolve, p._handler);\n\t\t\t\t} else {\n\t\t\t\t\tinsertCallback(args, callbackPos, p._handler.resolve, p._handler);\n\t\t\t\t\tinsertCallback(args, errbackPos, p._handler.reject, p._handler);\n\t\t\t\t}\n\n\t\t\t\tasyncFunction.apply(thisArg, args);\n\n\t\t\t\treturn p;\n\t\t\t});\n\t\t};\n\t}\n\n\tfunction normalizePosition(args, pos) {\n\t\treturn pos < 0 ? (args.length + pos + 2) : pos;\n\t}\n\n\tfunction insertCallback(args, pos, callback, thisArg) {\n\t\tif(typeof pos === 'number') {\n\t\t\targs.splice(pos, 0, alwaysUnary(callback, thisArg));\n\t\t}\n\t}\n\n\tfunction alwaysUnary(fn, thisArg) {\n\t\treturn function() {\n\t\t\tif (arguments.length > 1) {\n\t\t\t\tfn.call(thisArg, slice.call(arguments));\n\t\t\t} else {\n\t\t\t\tfn.apply(thisArg, arguments);\n\t\t\t}\n\t\t};\n\t}\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n"]}