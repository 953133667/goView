{"version":3,"sources":["error.js"],"names":[],"mappings":"AAAA;AACA;AACA;;AAEC,WAAS,MAAT,EAAiB;AAAE;;AACpB,QAAO,YAAW;;AAEjB,MAAI,KAAJ,EAAW,YAAX,EAAyB,MAAzB;;AAEA,MAAG,MAAM,iBAAT,EAA4B;AAC3B;AACA,WAAQ,UAAS,CAAT,EAAY;AACnB,WAAO,KAAK,EAAE,KAAP,IAAgB,EAAE,KAAF,CAAQ,KAAR,CAAc,IAAd,CAAvB;AACA,IAFD;;AAIA,YAAS,cAAT;AACA,kBAAe,MAAM,iBAArB;AAEA,GATD,MASO;AACN;AACA;AACA,WAAQ,UAAS,CAAT,EAAY;AACnB,QAAI,QAAQ,KAAK,EAAE,KAAP,IAAgB,EAAE,KAAF,CAAQ,KAAR,CAAc,IAAd,CAA5B;AACA,QAAG,SAAS,EAAE,OAAd,EAAuB;AACtB,WAAM,OAAN,CAAc,EAAE,OAAhB;AACA;AACD,WAAO,KAAP;AACA,IAND;;AAQC,gBAAW;AACX,QAAI,IAAI,IAAI,KAAJ,EAAR;AACA,QAAG,OAAO,EAAE,KAAT,KAAmB,QAAtB,EAAgC;AAC/B,cAAS,cAAT;AACA,oBAAe,wBAAf;AACA,KAHD,MAGO;AACN,cAAS,sBAAT;AACA,oBAAe,gBAAf;AACA;AACD,IATA,GAAD;AAUA;;AAED,WAAS,wBAAT,CAAkC,IAAlC,EAAwC;AACvC,OAAI;AACH,UAAM,IAAI,KAAJ,EAAN;AACA,IAFD,CAEE,OAAM,GAAN,EAAW;AACZ,SAAK,KAAL,GAAa,IAAI,KAAjB;AACA;AACD;;AAED,WAAS,gBAAT,CAA0B,IAA1B,EAAgC;AAC/B,QAAK,KAAL,GAAa,IAAI,KAAJ,GAAY,KAAzB;AACA;;AAED,WAAS,cAAT,CAAwB,SAAxB,EAAmC;AAClC,UAAO,KAAK,SAAL,CAAP;AACA;;AAED,WAAS,sBAAT,CAAgC,SAAhC,EAA2C;AAC1C,OAAI,IAAI,IAAI,KAAJ,EAAR;AACA,KAAE,KAAF,GAAU,eAAe,SAAf,CAAV;AACA,UAAO,CAAP;AACA;;AAED;AACA,WAAS,IAAT,CAAc,CAAd,EAAiB;AAChB,OAAI,MAAM,KAAV;AACA,OAAI,IAAI,EAAR;AACA,QAAI,IAAI,IAAE,CAAV,EAAa,IAAG,EAAE,MAAlB,EAA0B,EAAE,CAA5B,EAA+B;AAC9B,QAAG,GAAH,EAAQ;AACP,UAAK,OAAO,EAAE,CAAF,CAAZ;AACA,KAFD,MAEO;AACN,UAAI,EAAE,CAAF,CAAJ;AACA,WAAM,IAAN;AACA;AACD;AACD,UAAO,CAAP;AACA;;AAED,SAAO;AACN,UAAO,KADD;AAEN,WAAQ,MAFF;AAGN,iBAAc;AAHR,GAAP;AAMA,EA/ED;AAgFC,CAjFA,EAiFC,OAAO,MAAP,KAAkB,UAAlB,IAAgC,OAAO,GAAvC,GAA6C,MAA7C,GAAsD,UAAS,OAAT,EAAkB;AAAE,QAAO,OAAP,GAAiB,SAAjB;AAA6B,CAjFxG,CAAD","file":"error-compiled.js","sourcesContent":["/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\tvar parse, captureStack, format;\n\n\tif(Error.captureStackTrace) {\n\t\t// Use Error.captureStackTrace if available\n\t\tparse = function(e) {\n\t\t\treturn e && e.stack && e.stack.split('\\n');\n\t\t};\n\n\t\tformat = formatAsString;\n\t\tcaptureStack = Error.captureStackTrace;\n\n\t} else {\n\t\t// Otherwise, do minimal feature detection to determine\n\t\t// how to capture and format reasonable stacks.\n\t\tparse = function(e) {\n\t\t\tvar stack = e && e.stack && e.stack.split('\\n');\n\t\t\tif(stack && e.message) {\n\t\t\t\tstack.unshift(e.message);\n\t\t\t}\n\t\t\treturn stack;\n\t\t};\n\n\t\t(function() {\n\t\t\tvar e = new Error();\n\t\t\tif(typeof e.stack !== 'string') {\n\t\t\t\tformat = formatAsString;\n\t\t\t\tcaptureStack = captureSpiderMonkeyStack;\n\t\t\t} else {\n\t\t\t\tformat = formatAsErrorWithStack;\n\t\t\t\tcaptureStack = useStackDirectly;\n\t\t\t}\n\t\t}());\n\t}\n\n\tfunction captureSpiderMonkeyStack(host) {\n\t\ttry {\n\t\t\tthrow new Error();\n\t\t} catch(err) {\n\t\t\thost.stack = err.stack;\n\t\t}\n\t}\n\n\tfunction useStackDirectly(host) {\n\t\thost.stack = new Error().stack;\n\t}\n\n\tfunction formatAsString(longTrace) {\n\t\treturn join(longTrace);\n\t}\n\n\tfunction formatAsErrorWithStack(longTrace) {\n\t\tvar e = new Error();\n\t\te.stack = formatAsString(longTrace);\n\t\treturn e;\n\t}\n\n\t// About 5-10x faster than String.prototype.join o_O\n\tfunction join(a) {\n\t\tvar sep = false;\n\t\tvar s = '';\n\t\tfor(var i=0; i< a.length; ++i) {\n\t\t\tif(sep) {\n\t\t\t\ts += '\\n' + a[i];\n\t\t\t} else {\n\t\t\t\ts+= a[i];\n\t\t\t\tsep = true;\n\t\t\t}\n\t\t}\n\t\treturn s;\n\t}\n\n\treturn {\n\t\tparse: parse,\n\t\tformat: format,\n\t\tcaptureStack: captureStack\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n"]}