{"version":3,"sources":["guard.js"],"names":[],"mappings":"AAAA;;AAEA;;;;;;;;AAQC,WAAS,MAAT,EAAiB;AAClB,QAAO,UAAS,OAAT,EAAkB;;AAExB,MAAI,OAAO,QAAQ,QAAR,CAAX;AACA,MAAI,QAAQ,MAAM,SAAN,CAAgB,KAA5B;;AAEA,QAAM,CAAN,GAAU,CAAV;;AAEA,SAAO,KAAP;;AAEA;;;;;;;;AAQA,WAAS,KAAT,CAAe,SAAf,EAA0B,CAA1B,EAA6B;AAC5B,UAAO,YAAW;AACjB,QAAI,OAAO,MAAM,IAAN,CAAW,SAAX,CAAX;;AAEA,WAAO,KAAK,WAAL,EAAkB,QAAlB,CAA2B,IAA3B,EAAiC,IAAjC,CAAsC,UAAS,IAAT,EAAe;AAC3D,YAAO,KAAK,EAAE,KAAF,CAAQ,IAAR,EAAc,IAAd,CAAL,EAA0B,SAA1B,EAAqC,IAArC,CAAP;AACA,KAFM,CAAP;AAGA,IAND;AAOA;;AAED;;;;;;;;;AASA,WAAS,CAAT,CAAW,OAAX,EAAoB;AACnB,OAAI,QAAQ,CAAZ;AACA,OAAI,UAAU,EAAd;;AAEA,UAAO,SAAS,KAAT,GAAiB;AACvB,WAAO,KAAK,OAAL,CAAa,UAAS,OAAT,EAAkB;AACrC,SAAG,QAAQ,OAAX,EAAoB;AACnB,cAAQ,IAAR;AACA,MAFD,MAEO;AACN,cAAQ,IAAR,CAAa,OAAb;AACA;AACD,cAAS,CAAT;AACA,KAPM,CAAP;AAQA,IATD;;AAWA,YAAS,IAAT,GAAgB;AACf,YAAQ,KAAK,GAAL,CAAS,QAAQ,CAAjB,EAAoB,CAApB,CAAR;AACA,QAAG,QAAQ,MAAR,GAAiB,CAApB,EAAuB;AACtB,aAAQ,KAAR,GAAgB,IAAhB;AACA;AACD;AACD;AAED,EA3DD;AA4DC,CA7DA,EA6DC,OAAO,MAAP,KAAkB,UAAlB,IAAgC,OAAO,GAAvC,GAA6C,MAA7C,GAAsD,UAAS,OAAT,EAAkB;AAAE,QAAO,OAAP,GAAiB,QAAQ,OAAR,CAAjB;AAAoC,CA7D/G,CAAD","file":"guard-compiled.js","sourcesContent":["/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * Generalized promise concurrency guard\n * Adapted from original concept by Sakari Jokinen (Rocket Pack, Ltd.)\n *\n * @author Brian Cavalier\n * @author John Hann\n * @contributor Sakari Jokinen\n */\n(function(define) {\ndefine(function(require) {\n\n\tvar when = require('./when');\n\tvar slice = Array.prototype.slice;\n\n\tguard.n = n;\n\n\treturn guard;\n\n\t/**\n\t * Creates a guarded version of f that can only be entered when the supplied\n\t * condition allows.\n\t * @param {function} condition represents a critical section that may only\n\t *  be entered when allowed by the condition\n\t * @param {function} f function to guard\n\t * @returns {function} guarded version of f\n\t */\n\tfunction guard(condition, f) {\n\t\treturn function() {\n\t\t\tvar args = slice.call(arguments);\n\n\t\t\treturn when(condition()).withThis(this).then(function(exit) {\n\t\t\t\treturn when(f.apply(this, args))['finally'](exit);\n\t\t\t});\n\t\t};\n\t}\n\n\t/**\n\t * Creates a condition that allows only n simultaneous executions\n\t * of a guarded function\n\t * @param {number} allowed number of allowed simultaneous executions\n\t * @returns {function} condition function which returns a promise that\n\t *  fulfills when the critical section may be entered.  The fulfillment\n\t *  value is a function (\"notifyExit\") that must be called when the critical\n\t *  section has been exited.\n\t */\n\tfunction n(allowed) {\n\t\tvar count = 0;\n\t\tvar waiting = [];\n\n\t\treturn function enter() {\n\t\t\treturn when.promise(function(resolve) {\n\t\t\t\tif(count < allowed) {\n\t\t\t\t\tresolve(exit);\n\t\t\t\t} else {\n\t\t\t\t\twaiting.push(resolve);\n\t\t\t\t}\n\t\t\t\tcount += 1;\n\t\t\t});\n\t\t};\n\n\t\tfunction exit() {\n\t\t\tcount = Math.max(count - 1, 0);\n\t\t\tif(waiting.length > 0) {\n\t\t\t\twaiting.shift()(exit);\n\t\t\t}\n\t\t}\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n"]}