{"version":3,"sources":["flow.js"],"names":[],"mappings":"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","file":"flow-compiled.js","sourcesContent":["/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function flow(Promise) {\n\n\t\tvar resolve = Promise.resolve;\n\t\tvar reject = Promise.reject;\n\t\tvar origCatch = Promise.prototype['catch'];\n\n\t\t/**\n\t\t * Handle the ultimate fulfillment value or rejection reason, and assume\n\t\t * responsibility for all errors.  If an error propagates out of result\n\t\t * or handleFatalError, it will be rethrown to the host, resulting in a\n\t\t * loud stack track on most platforms and a crash on some.\n\t\t * @param {function?} onResult\n\t\t * @param {function?} onError\n\t\t * @returns {undefined}\n\t\t */\n\t\tPromise.prototype.done = function(onResult, onError) {\n\t\t\tthis._handler.visit(this._handler.receiver, onResult, onError);\n\t\t};\n\n\t\t/**\n\t\t * Add Error-type and predicate matching to catch.  Examples:\n\t\t * promise.catch(TypeError, handleTypeError)\n\t\t *   .catch(predicate, handleMatchedErrors)\n\t\t *   .catch(handleRemainingErrors)\n\t\t * @param onRejected\n\t\t * @returns {*}\n\t\t */\n\t\tPromise.prototype['catch'] = Promise.prototype.otherwise = function(onRejected) {\n\t\t\tif (arguments.length < 2) {\n\t\t\t\treturn origCatch.call(this, onRejected);\n\t\t\t}\n\n\t\t\tif(typeof onRejected !== 'function') {\n\t\t\t\treturn this.ensure(rejectInvalidPredicate);\n\t\t\t}\n\n\t\t\treturn origCatch.call(this, createCatchFilter(arguments[1], onRejected));\n\t\t};\n\n\t\t/**\n\t\t * Wraps the provided catch handler, so that it will only be called\n\t\t * if the predicate evaluates truthy\n\t\t * @param {?function} handler\n\t\t * @param {function} predicate\n\t\t * @returns {function} conditional catch handler\n\t\t */\n\t\tfunction createCatchFilter(handler, predicate) {\n\t\t\treturn function(e) {\n\t\t\t\treturn evaluatePredicate(e, predicate)\n\t\t\t\t\t? handler.call(this, e)\n\t\t\t\t\t: reject(e);\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Ensures that onFulfilledOrRejected will be called regardless of whether\n\t\t * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT\n\t\t * receive the promises' value or reason.  Any returned value will be disregarded.\n\t\t * onFulfilledOrRejected may throw or return a rejected promise to signal\n\t\t * an additional error.\n\t\t * @param {function} handler handler to be called regardless of\n\t\t *  fulfillment or rejection\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype['finally'] = Promise.prototype.ensure = function(handler) {\n\t\t\tif(typeof handler !== 'function') {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\treturn this.then(function(x) {\n\t\t\t\treturn runSideEffect(handler, this, identity, x);\n\t\t\t}, function(e) {\n\t\t\t\treturn runSideEffect(handler, this, reject, e);\n\t\t\t});\n\t\t};\n\n\t\tfunction runSideEffect (handler, thisArg, propagate, value) {\n\t\t\tvar result = handler.call(thisArg);\n\t\t\treturn maybeThenable(result)\n\t\t\t\t? propagateValue(result, propagate, value)\n\t\t\t\t: propagate(value);\n\t\t}\n\n\t\tfunction propagateValue (result, propagate, x) {\n\t\t\treturn resolve(result).then(function () {\n\t\t\t\treturn propagate(x);\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Recover from a failure by returning a defaultValue.  If defaultValue\n\t\t * is a promise, it's fulfillment value will be used.  If defaultValue is\n\t\t * a promise that rejects, the returned promise will reject with the\n\t\t * same reason.\n\t\t * @param {*} defaultValue\n\t\t * @returns {Promise} new promise\n\t\t */\n\t\tPromise.prototype['else'] = Promise.prototype.orElse = function(defaultValue) {\n\t\t\treturn this.then(void 0, function() {\n\t\t\t\treturn defaultValue;\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Shortcut for .then(function() { return value; })\n\t\t * @param  {*} value\n\t\t * @return {Promise} a promise that:\n\t\t *  - is fulfilled if value is not a promise, or\n\t\t *  - if value is a promise, will fulfill with its value, or reject\n\t\t *    with its reason.\n\t\t */\n\t\tPromise.prototype['yield'] = function(value) {\n\t\t\treturn this.then(function() {\n\t\t\t\treturn value;\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Runs a side effect when this promise fulfills, without changing the\n\t\t * fulfillment value.\n\t\t * @param {function} onFulfilledSideEffect\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype.tap = function(onFulfilledSideEffect) {\n\t\t\treturn this.then(onFulfilledSideEffect)['yield'](this);\n\t\t};\n\n\t\treturn Promise;\n\t};\n\n\tfunction rejectInvalidPredicate() {\n\t\tthrow new TypeError('catch predicate must be a function');\n\t}\n\n\tfunction evaluatePredicate(e, predicate) {\n\t\treturn isError(predicate) ? e instanceof predicate : predicate(e);\n\t}\n\n\tfunction isError(predicate) {\n\t\treturn predicate === Error\n\t\t\t|| (predicate != null && predicate.prototype instanceof Error);\n\t}\n\n\tfunction maybeThenable(x) {\n\t\treturn (typeof x === 'object' || typeof x === 'function') && x !== null;\n\t}\n\n\tfunction identity(x) {\n\t\treturn x;\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n"]}