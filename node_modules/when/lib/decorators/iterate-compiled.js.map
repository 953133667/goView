{"version":3,"sources":["iterate.js"],"names":[],"mappings":"AAAA;AACA;AACA;;AAEC,WAAS,MAAT,EAAiB;AAAE;;AACpB,QAAO,YAAW;;AAEjB,SAAO,SAAS,QAAT,CAAkB,OAAlB,EAA2B;;AAEjC,OAAI,UAAU,QAAQ,OAAtB;;AAEA,WAAQ,OAAR,GAAkB,OAAlB;AACA,WAAQ,MAAR,GAAiB,MAAjB;;AAEA,UAAO,OAAP;;AAEA;;;;;;;;;;;;AAYA,YAAS,OAAT,CAAiB,CAAjB,EAAoB,SAApB,EAA+B,OAA/B,EAAwC,CAAxC,EAA2C;AAC1C,WAAO,OAAO,UAAS,CAAT,EAAY;AACzB,YAAO,CAAC,CAAD,EAAI,EAAE,CAAF,CAAJ,CAAP;AACA,KAFM,EAEJ,SAFI,EAEO,OAFP,EAEgB,CAFhB,CAAP;AAGA;;AAED;;;;;;;;;;;;;;AAcA,YAAS,MAAT,CAAgB,OAAhB,EAAyB,SAAzB,EAAoC,OAApC,EAA6C,CAA7C,EAAgD;AAC/C,WAAO,QAAQ,CAAR,EAAW,IAAX,CAAgB,UAAS,IAAT,EAAe;AACrC,YAAO,QAAQ,UAAU,IAAV,CAAR,EAAyB,IAAzB,CAA8B,UAAS,IAAT,EAAe;AACnD,aAAO,OAAO,IAAP,GAAc,QAAQ,QAAQ,IAAR,CAAR,EAAuB,MAAvB,CAA8B,IAA9B,CAArB;AACA,MAFM,CAAP;AAGA,KAJM,CAAP;;AAMA,aAAS,IAAT,CAAc,IAAd,EAAoB,OAApB,EAA6B;AAC5B,YAAO,QAAQ,QAAQ,IAAR,CAAR,EAAuB,IAAvB,CAA4B,YAAW;AAC7C,aAAO,OAAO,OAAP,EAAgB,SAAhB,EAA2B,OAA3B,EAAoC,OAApC,CAAP;AACA,MAFM,CAAP;AAGA;AACD;AACD,GAtDD;AAwDA,EA1DD;AA2DC,CA5DA,EA4DC,OAAO,MAAP,KAAkB,UAAlB,IAAgC,OAAO,GAAvC,GAA6C,MAA7C,GAAsD,UAAS,OAAT,EAAkB;AAAE,QAAO,OAAP,GAAiB,SAAjB;AAA6B,CA5DxG,CAAD","file":"iterate-compiled.js","sourcesContent":["/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function generate(Promise) {\n\n\t\tvar resolve = Promise.resolve;\n\n\t\tPromise.iterate = iterate;\n\t\tPromise.unfold = unfold;\n\n\t\treturn Promise;\n\n\t\t/**\n\t\t * @deprecated Use github.com/cujojs/most streams and most.iterate\n\t\t * Generate a (potentially infinite) stream of promised values:\n\t\t * x, f(x), f(f(x)), etc. until condition(x) returns true\n\t\t * @param {function} f function to generate a new x from the previous x\n\t\t * @param {function} condition function that, given the current x, returns\n\t\t *  truthy when the iterate should stop\n\t\t * @param {function} handler function to handle the value produced by f\n\t\t * @param {*|Promise} x starting value, may be a promise\n\t\t * @return {Promise} the result of the last call to f before\n\t\t *  condition returns true\n\t\t */\n\t\tfunction iterate(f, condition, handler, x) {\n\t\t\treturn unfold(function(x) {\n\t\t\t\treturn [x, f(x)];\n\t\t\t}, condition, handler, x);\n\t\t}\n\n\t\t/**\n\t\t * @deprecated Use github.com/cujojs/most streams and most.unfold\n\t\t * Generate a (potentially infinite) stream of promised values\n\t\t * by applying handler(generator(seed)) iteratively until\n\t\t * condition(seed) returns true.\n\t\t * @param {function} unspool function that generates a [value, newSeed]\n\t\t *  given a seed.\n\t\t * @param {function} condition function that, given the current seed, returns\n\t\t *  truthy when the unfold should stop\n\t\t * @param {function} handler function to handle the value produced by unspool\n\t\t * @param x {*|Promise} starting value, may be a promise\n\t\t * @return {Promise} the result of the last value produced by unspool before\n\t\t *  condition returns true\n\t\t */\n\t\tfunction unfold(unspool, condition, handler, x) {\n\t\t\treturn resolve(x).then(function(seed) {\n\t\t\t\treturn resolve(condition(seed)).then(function(done) {\n\t\t\t\t\treturn done ? seed : resolve(unspool(seed)).spread(next);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tfunction next(item, newSeed) {\n\t\t\t\treturn resolve(handler(item)).then(function() {\n\t\t\t\t\treturn unfold(unspool, condition, handler, newSeed);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n"]}