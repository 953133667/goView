{"version":3,"sources":["Scheduler.js"],"names":[],"mappings":"AAAA;AACA;AACA;;AAEC,WAAS,MAAT,EAAiB;AAAE;;AACpB,QAAO,YAAW;;AAEjB;AACA;;AAEA;;;;;AAKA,WAAS,SAAT,CAAmB,KAAnB,EAA0B;AACzB,QAAK,MAAL,GAAc,KAAd;AACA,QAAK,QAAL,GAAgB,KAAhB;;AAEA,QAAK,MAAL,GAAc,IAAd;AACA,QAAK,SAAL,GAAiB,CAAjB;AACA,QAAK,WAAL,GAAmB,EAAnB;AACA,QAAK,cAAL,GAAsB,CAAtB;;AAEA,OAAI,OAAO,IAAX;AACA,QAAK,KAAL,GAAa,YAAW;AACvB,SAAK,MAAL;AACA,IAFD;AAGA;;AAED;;;;AAIA,YAAU,SAAV,CAAoB,OAApB,GAA8B,UAAS,IAAT,EAAe;AAC5C,QAAK,MAAL,CAAY,KAAK,SAAL,EAAZ,IAAgC,IAAhC;AACA,QAAK,GAAL;AACA,GAHD;;AAKA;;;;AAIA,YAAU,SAAV,CAAoB,UAApB,GAAiC,UAAS,IAAT,EAAe;AAC/C,QAAK,WAAL,CAAiB,KAAK,cAAL,EAAjB,IAA0C,IAA1C;AACA,QAAK,GAAL;AACA,GAHD;;AAKA,YAAU,SAAV,CAAoB,GAApB,GAA0B,YAAW;AACpC,OAAI,CAAC,KAAK,QAAV,EAAoB;AACnB,SAAK,QAAL,GAAgB,IAAhB;AACA,SAAK,MAAL,CAAY,KAAK,KAAjB;AACA;AACD,GALD;;AAOA;;;AAGA,YAAU,SAAV,CAAoB,MAApB,GAA6B,YAAW;AACvC,OAAI,IAAI,CAAR;AACA,UAAO,IAAI,KAAK,SAAhB,EAA2B,EAAE,CAA7B,EAAgC;AAC/B,SAAK,MAAL,CAAY,CAAZ,EAAe,GAAf;AACA,SAAK,MAAL,CAAY,CAAZ,IAAiB,KAAK,CAAtB;AACA;;AAED,QAAK,SAAL,GAAiB,CAAjB;AACA,QAAK,QAAL,GAAgB,KAAhB;;AAEA,QAAK,IAAI,CAAT,EAAY,IAAI,KAAK,cAArB,EAAqC,EAAE,CAAvC,EAA0C;AACzC,SAAK,WAAL,CAAiB,CAAjB,EAAoB,GAApB;AACA,SAAK,WAAL,CAAiB,CAAjB,IAAsB,KAAK,CAA3B;AACA;;AAED,QAAK,cAAL,GAAsB,CAAtB;AACA,GAhBD;;AAkBA,SAAO,SAAP;AAEA,EAzED;AA0EC,CA3EA,EA2EC,OAAO,MAAP,KAAkB,UAAlB,IAAgC,OAAO,GAAvC,GAA6C,MAA7C,GAAsD,UAAS,OAAT,EAAkB;AAAE,QAAO,OAAP,GAAiB,SAAjB;AAA6B,CA3ExG,CAAD","file":"Scheduler-compiled.js","sourcesContent":["/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\t// Credit to Twisol (https://github.com/Twisol) for suggesting\n\t// this type of extensible queue + trampoline approach for next-tick conflation.\n\n\t/**\n\t * Async task scheduler\n\t * @param {function} async function to schedule a single async function\n\t * @constructor\n\t */\n\tfunction Scheduler(async) {\n\t\tthis._async = async;\n\t\tthis._running = false;\n\n\t\tthis._queue = this;\n\t\tthis._queueLen = 0;\n\t\tthis._afterQueue = {};\n\t\tthis._afterQueueLen = 0;\n\n\t\tvar self = this;\n\t\tthis.drain = function() {\n\t\t\tself._drain();\n\t\t};\n\t}\n\n\t/**\n\t * Enqueue a task\n\t * @param {{ run:function }} task\n\t */\n\tScheduler.prototype.enqueue = function(task) {\n\t\tthis._queue[this._queueLen++] = task;\n\t\tthis.run();\n\t};\n\n\t/**\n\t * Enqueue a task to run after the main task queue\n\t * @param {{ run:function }} task\n\t */\n\tScheduler.prototype.afterQueue = function(task) {\n\t\tthis._afterQueue[this._afterQueueLen++] = task;\n\t\tthis.run();\n\t};\n\n\tScheduler.prototype.run = function() {\n\t\tif (!this._running) {\n\t\t\tthis._running = true;\n\t\t\tthis._async(this.drain);\n\t\t}\n\t};\n\n\t/**\n\t * Drain the handler queue entirely, and then the after queue\n\t */\n\tScheduler.prototype._drain = function() {\n\t\tvar i = 0;\n\t\tfor (; i < this._queueLen; ++i) {\n\t\t\tthis._queue[i].run();\n\t\t\tthis._queue[i] = void 0;\n\t\t}\n\n\t\tthis._queueLen = 0;\n\t\tthis._running = false;\n\n\t\tfor (i = 0; i < this._afterQueueLen; ++i) {\n\t\t\tthis._afterQueue[i].run();\n\t\t\tthis._afterQueue[i] = void 0;\n\t\t}\n\n\t\tthis._afterQueueLen = 0;\n\t};\n\n\treturn Scheduler;\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n"]}