{"version":3,"sources":["hash.js"],"names":[],"mappings":"AAAA,OAAO,OAAP,GAAiB,UAAU,MAAV,EAAkB;;AAEjC;AACA,WAAS,IAAT,CAAe,SAAf,EAA0B,SAA1B,EAAqC;AACnC,SAAK,MAAL,GAAc,IAAI,MAAJ,CAAW,SAAX,CAAd,CADmC,CACC;AACpC,SAAK,UAAL,GAAkB,SAAlB;AACA,SAAK,UAAL,GAAkB,SAAlB;AACA,SAAK,IAAL,GAAY,CAAZ;AACA,SAAK,EAAL,GAAU,CAAV;AACD;;AAED,OAAK,SAAL,CAAe,IAAf,GAAsB,YAAY;AAChC,SAAK,EAAL,GAAU,CAAV;AACA,SAAK,IAAL,GAAY,CAAZ;AACD,GAHD;;AAKA,OAAK,SAAL,CAAe,MAAf,GAAwB,UAAU,IAAV,EAAgB,GAAhB,EAAqB;AAC3C,QAAI,aAAa,OAAO,IAAxB,EAA8B;AAC5B,YAAM,OAAO,MAAb;AACA,aAAO,IAAI,MAAJ,CAAW,IAAX,EAAiB,GAAjB,CAAP;AACD;;AAED,QAAI,IAAI,KAAK,IAAL,IAAa,KAAK,MAA1B;AACA,QAAI,IAAI,KAAK,EAAL,GAAW,KAAK,EAAL,IAAW,CAA9B;AACA,QAAI,IAAI,CAAR;AACA,QAAI,SAAS,KAAK,MAAlB;;AAEA,WAAO,IAAI,CAAX,EAAc;AACZ,UAAI,IAAI,KAAK,GAAL,CAAS,KAAK,MAAd,EAAsB,IAAI,KAAK,UAAT,GAAuB,IAAI,KAAK,UAAtD,CAAR;AACA,UAAI,KAAM,IAAI,CAAd;;AAEA,WAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,EAApB,EAAwB,GAAxB,EAA6B;AAC3B,eAAQ,IAAI,KAAK,UAAV,GAAwB,CAA/B,IAAoC,KAAK,IAAI,CAAT,CAApC;AACD;;AAED,WAAK,EAAL;AACA,WAAK,EAAL;;AAEA,UAAK,IAAI,KAAK,UAAV,KAA0B,CAA9B,EAAiC;AAC/B,aAAK,OAAL,CAAa,MAAb;AACD;AACF;AACD,SAAK,EAAL,GAAU,CAAV;;AAEA,WAAO,IAAP;AACD,GA7BD;;AA+BA,OAAK,SAAL,CAAe,MAAf,GAAwB,UAAU,GAAV,EAAe;AACrC;AACA,QAAI,IAAI,KAAK,IAAL,GAAY,CAApB;;AAEA;AACA,SAAK,MAAL,CAAY,KAAK,IAAL,GAAY,KAAK,UAA7B,IAA2C,IAA3C;;AAEA;AACA,SAAK,MAAL,CAAY,IAAZ,CAAiB,CAAjB,EAAoB,KAAK,IAAL,GAAY,KAAK,UAAjB,GAA8B,CAAlD;;AAEA,QAAI,KAAK,KAAK,UAAL,GAAkB,CAAvB,KAA6B,KAAK,UAAL,GAAkB,CAAnD,EAAsD;AACpD,WAAK,OAAL,CAAa,KAAK,MAAlB;AACA,WAAK,MAAL,CAAY,IAAZ,CAAiB,CAAjB;AACD;;AAED;AACA;AACA,SAAK,MAAL,CAAY,YAAZ,CAAyB,CAAzB,EAA4B,KAAK,UAAL,GAAkB,CAA9C;;AAEA,QAAI,OAAO,KAAK,OAAL,CAAa,KAAK,MAAlB,KAA6B,KAAK,KAAL,EAAxC;;AAEA,WAAO,MAAM,KAAK,QAAL,CAAc,GAAd,CAAN,GAA2B,IAAlC;AACD,GAtBD;;AAwBA,OAAK,SAAL,CAAe,OAAf,GAAyB,YAAY;AACnC,UAAM,IAAI,KAAJ,CAAU,yCAAV,CAAN;AACD,GAFD;;AAIA,SAAO,IAAP;AACD,CA5ED","file":"hash-compiled.js","sourcesContent":["module.exports = function (Buffer) {\n\n  //prototype class for hash functions\n  function Hash (blockSize, finalSize) {\n    this._block = new Buffer(blockSize) //new Uint32Array(blockSize/4)\n    this._finalSize = finalSize\n    this._blockSize = blockSize\n    this._len = 0\n    this._s = 0\n  }\n\n  Hash.prototype.init = function () {\n    this._s = 0\n    this._len = 0\n  }\n\n  Hash.prototype.update = function (data, enc) {\n    if (\"string\" === typeof data) {\n      enc = enc || \"utf8\"\n      data = new Buffer(data, enc)\n    }\n\n    var l = this._len += data.length\n    var s = this._s = (this._s || 0)\n    var f = 0\n    var buffer = this._block\n\n    while (s < l) {\n      var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))\n      var ch = (t - f)\n\n      for (var i = 0; i < ch; i++) {\n        buffer[(s % this._blockSize) + i] = data[i + f]\n      }\n\n      s += ch\n      f += ch\n\n      if ((s % this._blockSize) === 0) {\n        this._update(buffer)\n      }\n    }\n    this._s = s\n\n    return this\n  }\n\n  Hash.prototype.digest = function (enc) {\n    // Suppose the length of the message M, in bits, is l\n    var l = this._len * 8\n\n    // Append the bit 1 to the end of the message\n    this._block[this._len % this._blockSize] = 0x80\n\n    // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize\n    this._block.fill(0, this._len % this._blockSize + 1)\n\n    if (l % (this._blockSize * 8) >= this._finalSize * 8) {\n      this._update(this._block)\n      this._block.fill(0)\n    }\n\n    // to this append the block which is equal to the number l written in binary\n    // TODO: handle case where l is > Math.pow(2, 29)\n    this._block.writeInt32BE(l, this._blockSize - 4)\n\n    var hash = this._update(this._block) || this._hash()\n\n    return enc ? hash.toString(enc) : hash\n  }\n\n  Hash.prototype._update = function () {\n    throw new Error('_update must be implemented by subclass')\n  }\n\n  return Hash\n}\n"]}