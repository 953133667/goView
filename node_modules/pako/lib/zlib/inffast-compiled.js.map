{"version":3,"sources":["inffast.js"],"names":[],"mappings":"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","file":"inffast-compiled.js","sourcesContent":["'use strict';\n\n// See state defs from inflate.js\nvar BAD = 30;       /* got a data error -- remain here until reset */\nvar TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nmodule.exports = function inflate_fast(strm, start) {\n  var state;\n  var _in;                    /* local strm.input */\n  var last;                   /* have enough input while in < last */\n  var _out;                   /* local strm.output */\n  var beg;                    /* inflate()'s initial strm.output */\n  var end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  var dmax;                   /* maximum distance from zlib header */\n//#endif\n  var wsize;                  /* window size or zero if not using window */\n  var whave;                  /* valid bytes in the window */\n  var wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  var s_window;               /* allocated sliding window, if wsize != 0 */\n  var hold;                   /* local strm.hold */\n  var bits;                   /* local strm.bits */\n  var lcode;                  /* local strm.lencode */\n  var dcode;                  /* local strm.distcode */\n  var lmask;                  /* mask for first level of length codes */\n  var dmask;                  /* mask for first level of distance codes */\n  var here;                   /* retrieved table entry */\n  var op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  var len;                    /* match length, unused bytes */\n  var dist;                   /* match distance */\n  var from;                   /* where to copy match from */\n  var from_source;\n\n\n  var input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defailts,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n"]}