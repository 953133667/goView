{"version":3,"sources":["pako_deflate.js"],"names":[],"mappings":"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","file":"pako_deflate-compiled.js","sourcesContent":["/* pako 0.2.9 nodeca/pako */(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.pako = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\n\nvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n                (typeof Uint16Array !== 'undefined') &&\n                (typeof Int32Array !== 'undefined');\n\n\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    var source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if (source.hasOwnProperty(p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) { return buf; }\n  if (buf.subarray) { return buf.subarray(0, size); }\n  buf.length = size;\n  return buf;\n};\n\n\nvar fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n      return;\n    }\n    // Fallback to ordinary array\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    var i, l, len, pos, chunk, result;\n\n    // calculate data length\n    len = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    result = new Uint8Array(len);\n    pos = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\n\nvar fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    return [].concat.apply([], chunks);\n  }\n};\n\n\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8  = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8  = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);\n\n},{}],2:[function(require,module,exports){\n// String encode/decode helpers\n'use strict';\n\n\nvar utils = require('./common');\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safary\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor (var q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nexports.string2buf = function (str) {\n  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new utils.Buf8(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n  // use fallback for big arrays to avoid stack overflow\n  if (len < 65537) {\n    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n    }\n  }\n\n  var result = '';\n  for (var i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n}\n\n\n// Convert byte array to binary string\nexports.buf2binstring = function (buf) {\n  return buf2binstring(buf, buf.length);\n};\n\n\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function (str) {\n  var buf = new utils.Buf8(str.length);\n  for (var i = 0, len = buf.length; i < len; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n};\n\n\n// convert array to string\nexports.buf2string = function (buf, max) {\n  var i, out, c, c_len;\n  var len = max || buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function (buf, max) {\n  var pos;\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Fuckup - very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means vuffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\n},{\"./common\":1}],3:[function(require,module,exports){\n'use strict';\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It doesn't worth to make additional optimizationa as in original.\n// Small size is preferable.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n\nmodule.exports = adler32;\n\n},{}],4:[function(require,module,exports){\n'use strict';\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n\n  crc ^= -1;\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n\nmodule.exports = crc32;\n\n},{}],5:[function(require,module,exports){\n'use strict';\n\nvar utils   = require('../utils/common');\nvar trees   = require('./trees');\nvar adler32 = require('./adler32');\nvar crc32   = require('./crc32');\nvar msg     = require('./messages');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n                );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n\n},{\"../utils/common\":1,\"./adler32\":3,\"./crc32\":4,\"./messages\":6,\"./trees\":7}],6:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n\n},{}],7:[function(require,module,exports){\n'use strict';\n\n\nvar utils = require('../utils/common');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defailts,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n\n},{\"../utils/common\":1}],8:[function(require,module,exports){\n'use strict';\n\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n\n},{}],\"/lib/deflate.js\":[function(require,module,exports){\n'use strict';\n\n\nvar zlib_deflate = require('./zlib/deflate');\nvar utils        = require('./utils/common');\nvar strings      = require('./utils/strings');\nvar msg          = require('./zlib/messages');\nvar ZStream      = require('./zlib/zstream');\n\nvar toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nvar Z_NO_FLUSH      = 0;\nvar Z_FINISH        = 4;\n\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_SYNC_FLUSH    = 2;\n\nvar Z_DEFAULT_COMPRESSION = -1;\n\nvar Z_DEFAULT_STRATEGY    = 0;\n\nvar Z_DEFLATED  = 8;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overriden.\n **/\n\n/**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate(options) {\n  if (!(this instanceof Deflate)) return new Deflate(options);\n\n  this.options = utils.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status = zlib_deflate.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  if (opt.header) {\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    var dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK) {\n      throw new Error(msg[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var status, _mode;\n\n  if (this.ended) { return false; }\n\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */\n\n    if (status !== Z_STREAM_END && status !== Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {\n      if (this.options.to === 'string') {\n        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n      } else {\n        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n      }\n    }\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\n  // Finalize on the last chunk.\n  if (_mode === Z_FINISH) {\n    status = zlib_deflate.deflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === Z_SYNC_FLUSH) {\n    this.onEnd(Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): ouput data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate(input, options) {\n  var deflator = new Deflate(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate(input, options);\n}\n\n\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n\n},{\"./utils/common\":1,\"./utils/strings\":2,\"./zlib/deflate\":5,\"./zlib/messages\":6,\"./zlib/zstream\":8}]},{},[])(\"/lib/deflate.js\")\n});"]}