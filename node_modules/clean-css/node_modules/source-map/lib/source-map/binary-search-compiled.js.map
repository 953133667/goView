{"version":3,"sources":["binary-search.js"],"names":[],"mappings":"AAAA;AACA;;;;;AAKA,IAAI,OAAO,MAAP,KAAkB,UAAtB,EAAkC;AAC9B,MAAI,SAAS,QAAQ,UAAR,EAAoB,MAApB,EAA4B,OAA5B,CAAb;AACH;AACD,OAAO,UAAU,OAAV,EAAmB,OAAnB,EAA4B,MAA5B,EAAoC;;AAEzC,UAAQ,oBAAR,GAA+B,CAA/B;AACA,UAAQ,iBAAR,GAA4B,CAA5B;;AAEA;;;;;;;;;;;;;AAaA,WAAS,eAAT,CAAyB,IAAzB,EAA+B,KAA/B,EAAsC,OAAtC,EAA+C,SAA/C,EAA0D,QAA1D,EAAoE,KAApE,EAA2E;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAI,MAAM,KAAK,KAAL,CAAW,CAAC,QAAQ,IAAT,IAAiB,CAA5B,IAAiC,IAA3C;AACA,QAAI,MAAM,SAAS,OAAT,EAAkB,UAAU,GAAV,CAAlB,EAAkC,IAAlC,CAAV;AACA,QAAI,QAAQ,CAAZ,EAAe;AACb;AACA,aAAO,GAAP;AACD,KAHD,MAIK,IAAI,MAAM,CAAV,EAAa;AAChB;AACA,UAAI,QAAQ,GAAR,GAAc,CAAlB,EAAqB;AACnB;AACA,eAAO,gBAAgB,GAAhB,EAAqB,KAArB,EAA4B,OAA5B,EAAqC,SAArC,EAAgD,QAAhD,EAA0D,KAA1D,CAAP;AACD;;AAED;AACA;AACA,UAAI,SAAS,QAAQ,iBAArB,EAAwC;AACtC,eAAO,QAAQ,UAAU,MAAlB,GAA2B,KAA3B,GAAmC,CAAC,CAA3C;AACD,OAFD,MAEO;AACL,eAAO,GAAP;AACD;AACF,KAdI,MAeA;AACH;AACA,UAAI,MAAM,IAAN,GAAa,CAAjB,EAAoB;AAClB;AACA,eAAO,gBAAgB,IAAhB,EAAsB,GAAtB,EAA2B,OAA3B,EAAoC,SAApC,EAA+C,QAA/C,EAAyD,KAAzD,CAAP;AACD;;AAED;AACA,UAAI,SAAS,QAAQ,iBAArB,EAAwC;AACtC,eAAO,GAAP;AACD,OAFD,MAEO;AACL,eAAO,OAAO,CAAP,GAAW,CAAC,CAAZ,GAAgB,IAAvB;AACD;AACF;AACF;;AAED;;;;;;;;;;;;;;;;;;AAkBA,UAAQ,MAAR,GAAiB,SAAS,MAAT,CAAgB,OAAhB,EAAyB,SAAzB,EAAoC,QAApC,EAA8C,KAA9C,EAAqD;AACpE,QAAI,UAAU,MAAV,KAAqB,CAAzB,EAA4B;AAC1B,aAAO,CAAC,CAAR;AACD;;AAED,QAAI,QAAQ,gBAAgB,CAAC,CAAjB,EAAoB,UAAU,MAA9B,EAAsC,OAAtC,EAA+C,SAA/C,EACgB,QADhB,EAC0B,SAAS,QAAQ,oBAD3C,CAAZ;AAEA,QAAI,QAAQ,CAAZ,EAAe;AACb,aAAO,CAAC,CAAR;AACD;;AAED;AACA;AACA;AACA,WAAO,QAAQ,CAAR,IAAa,CAApB,EAAuB;AACrB,UAAI,SAAS,UAAU,KAAV,CAAT,EAA2B,UAAU,QAAQ,CAAlB,CAA3B,EAAiD,IAAjD,MAA2D,CAA/D,EAAkE;AAChE;AACD;AACD,QAAE,KAAF;AACD;;AAED,WAAO,KAAP;AACD,GAtBD;AAwBD,CA3GD","file":"binary-search-compiled.js","sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n}\ndefine(function (require, exports, module) {\n\n  exports.GREATEST_LOWER_BOUND = 1;\n  exports.LEAST_UPPER_BOUND = 2;\n\n  /**\n   * Recursive implementation of binary search.\n   *\n   * @param aLow Indices here and lower do not contain the needle.\n   * @param aHigh Indices here and higher do not contain the needle.\n   * @param aNeedle The element being searched for.\n   * @param aHaystack The non-empty array being searched.\n   * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   */\n  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n    // This function terminates when one of the following is true:\n    //\n    //   1. We find the exact element we are looking for.\n    //\n    //   2. We did not find the exact element, but we can return the index of\n    //      the next-closest element.\n    //\n    //   3. We did not find the exact element, and there is no next-closest\n    //      element than the one we are searching for, so we return -1.\n    var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n    var cmp = aCompare(aNeedle, aHaystack[mid], true);\n    if (cmp === 0) {\n      // Found the element we are looking for.\n      return mid;\n    }\n    else if (cmp > 0) {\n      // Our needle is greater than aHaystack[mid].\n      if (aHigh - mid > 1) {\n        // The element is in the upper half.\n        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n      }\n\n      // The exact needle element was not found in this haystack. Determine if\n      // we are in termination case (3) or (2) and return the appropriate thing.\n      if (aBias == exports.LEAST_UPPER_BOUND) {\n        return aHigh < aHaystack.length ? aHigh : -1;\n      } else {\n        return mid;\n      }\n    }\n    else {\n      // Our needle is less than aHaystack[mid].\n      if (mid - aLow > 1) {\n        // The element is in the lower half.\n        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n      }\n\n      // we are in termination case (3) or (2) and return the appropriate thing.\n      if (aBias == exports.LEAST_UPPER_BOUND) {\n        return mid;\n      } else {\n        return aLow < 0 ? -1 : aLow;\n      }\n    }\n  }\n\n  /**\n   * This is an implementation of binary search which will always try and return\n   * the index of the closest element if there is no exact hit. This is because\n   * mappings between original and generated line/col pairs are single points,\n   * and there is an implicit region between each of them, so a miss just means\n   * that you aren't on the very start of a region.\n   *\n   * @param aNeedle The element you are looking for.\n   * @param aHaystack The array that is being searched.\n   * @param aCompare A function which takes the needle and an element in the\n   *     array and returns -1, 0, or 1 depending on whether the needle is less\n   *     than, equal to, or greater than the element, respectively.\n   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n   */\n  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n    if (aHaystack.length === 0) {\n      return -1;\n    }\n\n    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                                aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n    if (index < 0) {\n      return -1;\n    }\n\n    // We have found either the exact element, or the next-closest element than\n    // the one we are searching for. However, there may be more than one such\n    // element. Make sure we always return the smallest of these.\n    while (index - 1 >= 0) {\n      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n        break;\n      }\n      --index;\n    }\n\n    return index;\n  };\n\n});\n"]}