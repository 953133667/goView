{"version":3,"sources":["parser.js"],"names":[],"mappings":"AAAA,IAAI,YAAY,QAAQ,eAAR,CAAhB;AAAA,IACI,OAAO,QAAQ,SAAR,CADX;AAAA,IAEI,WAAW,QAAQ,aAAR,CAFf;AAAA,IAGI,iBAAiB,QAAQ,gBAAR,CAHrB;AAAA,IAII,QAAQ,QAAQ,UAAR,CAJZ;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,SAAS,SAAS,MAAT,CAAgB,OAAhB,EAAyB,OAAzB,EAAkC,QAAlC,EAA4C;AACrD,QAAI,OAAJ;AAAA,QACI,cAAc,gBADlB;;AAGA,aAAS,KAAT,CAAe,GAAf,EAAoB,IAApB,EAA0B;AACtB,cAAM,IAAI,SAAJ,CACF;AACI,mBAAO,YAAY,CADvB;AAEI,sBAAU,SAAS,QAFvB;AAGI,kBAAM,QAAQ,QAHlB;AAII,qBAAS;AAJb,SADE,EAOF,OAPE,CAAN;AASH;;AAED,aAAS,MAAT,CAAgB,GAAhB,EAAqB,GAArB,EAA0B,KAA1B,EAAiC;AAC7B;AACA,YAAI,SAAU,eAAe,QAAhB,GAA4B,IAAI,IAAJ,CAAS,OAAT,CAA5B,GAAgD,YAAY,GAAZ,CAAgB,GAAhB,CAA7D;AACA,YAAI,MAAJ,EAAY;AACR,mBAAO,MAAP;AACH;AACD,cAAM,QAAQ,OAAO,GAAP,KAAe,QAAf,GAA0B,eAAe,GAAf,GAAqB,SAArB,GAAiC,YAAY,WAAZ,EAAjC,GAA6D,GAAvF,GAC2B,kBADnC,CAAN;AAEH;;AAED;AACA,aAAS,UAAT,CAAoB,GAApB,EAAyB,GAAzB,EAA8B;AAC1B,YAAI,YAAY,KAAZ,CAAkB,GAAlB,CAAJ,EAA4B;AACxB,mBAAO,GAAP;AACH;AACD,cAAM,OAAO,eAAe,GAAf,GAAqB,SAArB,GAAiC,YAAY,WAAZ,EAAjC,GAA6D,GAA1E;AACH;;AAED,aAAS,YAAT,CAAsB,KAAtB,EAA6B;AACzB,YAAI,WAAW,SAAS,QAAxB;;AAEA,eAAO;AACH,wBAAY,MAAM,WAAN,CAAkB,KAAlB,EAAyB,YAAY,QAAZ,EAAzB,EAAiD,IAAjD,GAAwD,CADjE;AAEH,sBAAU;AAFP,SAAP;AAIH;;AAED;AACA;AACA;AACA,WAAO;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,eAAO,UAAU,GAAV,EAAe,QAAf,EAAyB,cAAzB,EAAyC;AAC5C,gBAAI,IAAJ;AAAA,gBAAU,QAAQ,IAAlB;AAAA,gBAAwB,UAAxB;AAAA,gBAAoC,UAApC;AAAA,gBAAgD,OAAhD;AAAA,gBAAyD,UAAU,EAAnE;;AAEA,yBAAc,kBAAkB,eAAe,UAAlC,GAAgD,OAAO,aAAP,CAAqB,eAAe,UAApC,IAAkD,IAAlG,GAAyG,EAAtH;AACA,yBAAc,kBAAkB,eAAe,UAAlC,GAAgD,OAAO,OAAO,aAAP,CAAqB,eAAe,UAApC,CAAvD,GAAyG,EAAtH;;AAEA,gBAAI,QAAQ,aAAZ,EAA2B;AACvB,oBAAI,gBAAgB,QAAQ,aAAR,CAAsB,gBAAtB,EAApB;AACA,qBAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,cAAc,MAAlC,EAA0C,GAA1C,EAA+C;AAC3C,0BAAM,cAAc,CAAd,EAAiB,OAAjB,CAAyB,GAAzB,EAA8B,EAAE,SAAS,OAAX,EAAoB,SAAS,OAA7B,EAAsC,UAAU,QAAhD,EAA9B,CAAN;AACH;AACJ;;AAED,gBAAI,cAAe,kBAAkB,eAAe,MAApD,EAA6D;AACzD,0BAAU,CAAE,kBAAkB,eAAe,MAAlC,GAA4C,eAAe,MAA3D,GAAoE,EAArE,IAA2E,UAArF;AACA,0BAAU,QAAQ,oBAAlB;AACA,wBAAQ,SAAS,QAAjB,IAA6B,QAAQ,SAAS,QAAjB,KAA8B,CAA3D;AACA,wBAAQ,SAAS,QAAjB,KAA8B,QAAQ,MAAtC;AACH;;AAED,kBAAM,IAAI,OAAJ,CAAY,QAAZ,EAAsB,IAAtB,CAAN;AACA;AACA,kBAAM,UAAU,IAAI,OAAJ,CAAY,SAAZ,EAAuB,EAAvB,CAAV,GAAuC,UAA7C;AACA,oBAAQ,QAAR,CAAiB,SAAS,QAA1B,IAAsC,GAAtC;;AAEA;AACA;AACA;AACA;AACA,gBAAI;AACA,4BAAY,KAAZ,CAAkB,GAAlB,EAAuB,QAAQ,UAA/B,EAA2C,SAAS,IAAT,CAAc,GAAd,EAAmB,KAAnB,EAA0B;AACjE,0BAAM,IAAI,SAAJ,CAAc;AAChB,+BAAO,KADS;AAEhB,8BAAM,OAFU;AAGhB,iCAAS,GAHO;AAIhB,kCAAU,SAAS;AAJH,qBAAd,EAKH,OALG,CAAN;AAMH,iBAPD;;AASA,uBAAO,IAAI,KAAK,OAAT,CAAkB,IAAlB,EAAwB,KAAK,OAAL,CAAa,OAAb,EAAxB,CAAP;AACA,qBAAK,IAAL,GAAY,IAAZ;AACA,qBAAK,SAAL,GAAiB,IAAjB;AACH,aAbD,CAaE,OAAO,CAAP,EAAU;AACR,uBAAO,SAAS,IAAI,SAAJ,CAAc,CAAd,EAAiB,OAAjB,EAA0B,SAAS,QAAnC,CAAT,CAAP;AACH;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAI,UAAU,YAAY,GAAZ,EAAd;AACA,gBAAI,CAAC,QAAQ,UAAb,EAAyB;;AAErB,oBAAI,UAAU,QAAQ,4BAAtB;;AAEA,oBAAI,CAAC,OAAL,EAAc;AACV,8BAAU,oBAAV;AACA,wBAAI,QAAQ,YAAR,KAAyB,GAA7B,EAAkC;AAC9B,mCAAW,gCAAX;AACH,qBAFD,MAEO,IAAI,QAAQ,YAAR,KAAyB,GAA7B,EAAkC;AACrC,mCAAW,gCAAX;AACH,qBAFM,MAEA,IAAI,QAAQ,kBAAZ,EAAgC;AACnC,mCAAW,8BAAX;AACH;AACJ;;AAED,wBAAQ,IAAI,SAAJ,CAAc;AAClB,0BAAM,OADY;AAElB,6BAAS,OAFS;AAGlB,2BAAO,QAAQ,QAHG;AAIlB,8BAAU,SAAS;AAJD,iBAAd,EAKL,OALK,CAAR;AAMH;;AAED,gBAAI,SAAS,UAAU,CAAV,EAAa;AACtB,oBAAI,SAAS,CAAT,IAAc,QAAQ,KAA1B;;AAEA,oBAAI,CAAJ,EAAO;AACH,wBAAI,EAAE,aAAa,SAAf,CAAJ,EAA+B;AAC3B,4BAAI,IAAI,SAAJ,CAAc,CAAd,EAAiB,OAAjB,EAA0B,SAAS,QAAnC,CAAJ;AACH;;AAED,2BAAO,SAAS,CAAT,CAAP;AACH,iBAND,MAOK;AACD,2BAAO,SAAS,IAAT,EAAe,IAAf,CAAP;AACH;AACJ,aAbD;;AAeA,gBAAI,QAAQ,cAAR,KAA2B,KAA/B,EAAsC;AAClC,oBAAI,SAAS,aAAb,CAA2B,OAA3B,EAAoC,MAApC,EACK,GADL,CACS,IADT;AAEH,aAHD,MAGO;AACH,uBAAO,QAAP;AACH;AACJ,SA3GE;;AA6GH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAS,UAAU;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAS,YAAY;AACjB,oBAAI,QAAQ,KAAK,KAAjB;AAAA,oBAAwB,OAAO,EAA/B;AAAA,oBAAmC,IAAnC;;AAEA,uBAAO,IAAP,EAAa;AACT,2BAAO,IAAP,EAAa;AACT,+BAAO,KAAK,OAAL,EAAP;AACA,4BAAI,CAAC,IAAL,EAAW;AAAE;AAAQ;AACrB,6BAAK,IAAL,CAAU,IAAV;AACH;AACD;AACA,wBAAI,YAAY,QAAhB,EAA0B;AACtB;AACH;AACD,wBAAI,YAAY,IAAZ,CAAiB,GAAjB,CAAJ,EAA2B;AACvB;AACH;;AAED,2BAAO,KAAK,UAAL,EAAP;AACA,wBAAI,IAAJ,EAAU;AACN,+BAAO,KAAK,MAAL,CAAY,IAAZ,CAAP;AACA;AACH;;AAED,2BAAO,MAAM,UAAN,MAAsB,KAAK,IAAL,EAAtB,IAAqC,KAAK,OAAL,EAArC,IACH,MAAM,IAAN,EADG,IACa,KAAK,WAAL,EADb,IACmC,KAAK,QAAL,CAAc,IAAd,EADnC,IAC2D,KAAK,SAAL,EADlE;AAEA,wBAAI,IAAJ,EAAU;AACN,6BAAK,IAAL,CAAU,IAAV;AACH,qBAFD,MAEO;AACH,4BAAI,iBAAiB,KAArB;AACA,+BAAO,YAAY,KAAZ,CAAkB,GAAlB,CAAP,EAA+B;AAC3B,6CAAiB,IAAjB;AACH;AACD,4BAAI,CAAC,cAAL,EAAqB;AACjB;AACH;AACJ;AACJ;;AAED,uBAAO,IAAP;AACH,aAvDc;;AAyDf;AACA;AACA,qBAAS,YAAY;AACjB,oBAAI,YAAY,YAAZ,CAAyB,MAA7B,EAAqC;AACjC,wBAAI,UAAU,YAAY,YAAZ,CAAyB,KAAzB,EAAd;AACA,2BAAO,IAAI,KAAK,OAAT,CAAkB,QAAQ,IAA1B,EAAgC,QAAQ,aAAxC,EAAuD,QAAQ,KAA/D,EAAsE,QAAtE,CAAP;AACH;AACJ,aAhEc;;AAkEf;AACA;AACA;AACA,sBAAU;AACN;AACA;AACA;AACA;AACA;AACA,wBAAQ,YAAY;AAChB,wBAAI,GAAJ;AAAA,wBAAS,QAAQ,YAAY,CAA7B;AAAA,wBAAgC,YAAY,KAA5C;;AAEA,gCAAY,IAAZ;AACA,wBAAI,YAAY,KAAZ,CAAkB,GAAlB,CAAJ,EAA4B;AACxB,oCAAY,IAAZ;AACH;AACD,0BAAM,YAAY,OAAZ,EAAN;AACA,wBAAI,CAAC,GAAL,EAAU;AACN,oCAAY,OAAZ;AACA;AACH;AACD,gCAAY,MAAZ;;AAEA,2BAAO,IAAI,KAAK,MAAT,CAAiB,IAAI,MAAJ,CAAW,CAAX,CAAjB,EAAgC,IAAI,MAAJ,CAAW,CAAX,EAAc,IAAI,MAAJ,GAAa,CAA3B,CAAhC,EAA+D,SAA/D,EAA0E,KAA1E,EAAiF,QAAjF,CAAP;AACH,iBArBK;;AAuBN;AACA;AACA;AACA;AACA;AACA,yBAAS,YAAY;AACjB,wBAAI,IAAI,YAAY,KAAZ,CAAkB,GAAlB,KAA0B,YAAY,GAAZ,CAAgB,2BAAhB,CAAlC;AACA,wBAAI,CAAJ,EAAO;AACH,+BAAO,KAAK,KAAL,CAAW,WAAX,CAAuB,CAAvB,KAA6B,IAAI,KAAK,OAAT,CAAkB,CAAlB,CAApC;AACH;AACJ,iBAjCK;;AAmCN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAM,YAAY;AACd,wBAAI,IAAJ;AAAA,wBAAU,MAAV;AAAA,wBAAkB,IAAlB;AAAA,wBAAwB,KAAxB;AAAA,wBAA+B,QAAQ,YAAY,CAAnD;;AAEA;AACA,wBAAI,YAAY,IAAZ,CAAiB,SAAjB,CAAJ,EAAiC;AAC7B;AACH;;AAED,gCAAY,IAAZ;;AAEA,2BAAO,YAAY,GAAZ,CAAgB,8BAAhB,CAAP;AACA,wBAAI,CAAC,IAAL,EAAW;AAAE,oCAAY,MAAZ,GAAsB;AAAS;;AAE5C,2BAAO,KAAK,CAAL,CAAP;AACA,6BAAS,KAAK,WAAL,EAAT;;AAEA,wBAAI,WAAW,OAAf,EAAwB;AACpB,gCAAQ,QAAQ,KAAR,EAAR;AACA,4BAAI,KAAJ,EAAW;AACP,wCAAY,MAAZ;AACA,mCAAO,KAAP;AACH;AACJ;;AAED,2BAAO,KAAK,SAAL,EAAP;;AAEA,wBAAI,CAAE,YAAY,KAAZ,CAAkB,GAAlB,CAAN,EAA8B;AAC1B,oCAAY,OAAZ,CAAoB,+CAApB;AACA;AACH;;AAED,gCAAY,MAAZ;AACA,2BAAO,IAAI,KAAK,IAAT,CAAe,IAAf,EAAqB,IAArB,EAA2B,KAA3B,EAAkC,QAAlC,CAAP;AACH,iBA9EK;AA+EN,2BAAW,YAAY;AACnB,wBAAI,gBAAgB,EAApB;AAAA,wBAAwB,YAAY,EAApC;AAAA,wBACI,cAAc,EADlB;AAAA,wBAEI,oBAFJ;AAAA,wBAE0B,KAF1B;AAAA,wBAEiC,GAFjC;;AAIA,gCAAY,IAAZ;;AAEA,2BAAO,IAAP,EAAa;;AAET,8BAAM,QAAQ,eAAR,MAA6B,KAAK,UAAL,EAA7B,IAAkD,QAAQ,UAAR,EAAxD;;AAEA,4BAAI,CAAC,GAAL,EAAU;AACN;AACH;;AAED,gCAAQ,GAAR;;AAEA,4BAAI,IAAI,KAAJ,IAAa,IAAI,KAAJ,CAAU,MAAV,IAAoB,CAArC,EAAwC;AACpC,oCAAQ,IAAI,KAAJ,CAAU,CAAV,CAAR;AACH;;AAED,4BAAI,KAAJ,EAAW;AACP,wCAAY,IAAZ,CAAiB,KAAjB;AACH;;AAED,kCAAU,IAAV,CAAe,KAAf;;AAEA,4BAAI,YAAY,KAAZ,CAAkB,GAAlB,CAAJ,EAA4B;AACxB;AACH;;AAED,4BAAI,YAAY,KAAZ,CAAkB,GAAlB,KAA0B,oBAA9B,EAAoD;;AAEhD,mDAAuB,IAAvB;;AAEA,gCAAI,YAAY,MAAZ,GAAqB,CAAzB,EAA4B;AACxB,wCAAQ,IAAI,KAAK,KAAT,CAAgB,WAAhB,CAAR;AACH;AACD,0CAAc,IAAd,CAAmB,KAAnB;;AAEA,0CAAc,EAAd;AACH;AACJ;;AAED,gCAAY,MAAZ;AACA,2BAAO,uBAAuB,aAAvB,GAAuC,SAA9C;AACH,iBA7HK;AA8HN,yBAAS,YAAY;AACjB,2BAAO,KAAK,SAAL,MACA,KAAK,KAAL,EADA,IAEA,KAAK,MAAL,EAFA,IAGA,KAAK,iBAAL,EAHP;AAIH,iBAnIK;;AAqIN;AACA;AACA;AACA;AACA;;AAEA,4BAAY,YAAY;AACpB,wBAAI,GAAJ,EAAS,KAAT;AACA,gCAAY,IAAZ;AACA,0BAAM,YAAY,GAAZ,CAAgB,eAAhB,CAAN;AACA,wBAAI,CAAC,GAAL,EAAU;AACN,oCAAY,OAAZ;AACA;AACH;AACD,wBAAI,CAAC,YAAY,KAAZ,CAAkB,GAAlB,CAAL,EAA6B;AACzB,oCAAY,OAAZ;AACA;AACH;AACD,4BAAQ,QAAQ,MAAR,EAAR;AACA,wBAAI,KAAJ,EAAW;AACP,oCAAY,MAAZ;AACA,+BAAO,IAAI,KAAK,UAAT,CAAqB,GAArB,EAA0B,KAA1B,CAAP;AACH,qBAHD,MAGO;AACH,oCAAY,OAAZ;AACH;AACJ,iBA9JK;;AAgKN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAK,YAAY;AACb,wBAAI,KAAJ;AAAA,wBAAW,QAAQ,YAAY,CAA/B;;AAEA,gCAAY,iBAAZ,GAAgC,KAAhC;;AAEA,wBAAI,CAAC,YAAY,IAAZ,CAAiB,MAAjB,CAAL,EAA+B;AAC3B,oCAAY,iBAAZ,GAAgC,IAAhC;AACA;AACH;;AAED,4BAAQ,KAAK,MAAL,MAAiB,KAAK,QAAL,EAAjB,IACA,YAAY,GAAZ,CAAgB,gCAAhB,CADA,IACqD,EAD7D;;AAGA,gCAAY,iBAAZ,GAAgC,IAAhC;;AAEA,+BAAW,GAAX;;AAEA,2BAAO,IAAI,KAAK,GAAT,CAAe,MAAM,KAAN,IAAe,IAAf,IAAuB,iBAAiB,KAAK,QAA9C,GACD,KADC,GACO,IAAI,KAAK,SAAT,CAAoB,KAApB,CADrB,EACiD,KADjD,EACwD,QADxD,CAAP;AAEH,iBA1LK;;AA4LN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAU,YAAY;AAClB,wBAAI,IAAJ;AAAA,wBAAU,QAAQ,YAAY,CAA9B;;AAEA,wBAAI,YAAY,WAAZ,OAA8B,GAA9B,KAAsC,OAAO,YAAY,GAAZ,CAAgB,YAAhB,CAA7C,CAAJ,EAAiF;AAC7E,+BAAO,IAAI,KAAK,QAAT,CAAmB,IAAnB,EAAyB,KAAzB,EAAgC,QAAhC,CAAP;AACH;AACJ,iBA1MK;;AA4MN;AACA,+BAAe,YAAY;AACvB,wBAAI,KAAJ;AAAA,wBAAW,QAAQ,YAAY,CAA/B;;AAEA,wBAAI,YAAY,WAAZ,OAA8B,GAA9B,KAAsC,QAAQ,YAAY,GAAZ,CAAgB,gBAAhB,CAA9C,CAAJ,EAAsF;AAClF,+BAAO,IAAI,KAAK,QAAT,CAAmB,MAAM,MAAM,CAAN,CAAzB,EAAmC,KAAnC,EAA0C,QAA1C,CAAP;AACH;AACJ,iBAnNK;;AAqNN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAO,YAAY;AACf,wBAAI,GAAJ;;AAEA,wBAAI,YAAY,WAAZ,OAA8B,GAA9B,KAAsC,MAAM,YAAY,GAAZ,CAAgB,mCAAhB,CAA5C,CAAJ,EAAuG;AACnG;AACA;AACA,4BAAI,uBAAuB,IAAI,KAAJ,CAAU,KAAV,CAAgB,aAAhB,CAA3B;AACA,+CAAuB,qBAAqB,CAArB,CAAvB;AACA,4BAAI,CAAC,qBAAqB,KAArB,CAA2B,gBAA3B,CAAL,EAAmD;AAAE;AACjD,kCAAM,wBAAN;AACH;AACD,+BAAO,IAAI,KAAK,KAAT,CAAgB,IAAI,CAAJ,CAAhB,EAAwB,SAAxB,EAAmC,MAAM,oBAAzC,CAAP;AACH;AACJ,iBAzOK;;AA2ON,8BAAc,YAAY;AACtB,gCAAY,IAAZ;AACA,wBAAI,oBAAoB,YAAY,iBAApC;AACA,gCAAY,iBAAZ,GAAgC,KAAhC;AACA,wBAAI,IAAI,YAAY,GAAZ,CAAgB,2BAAhB,CAAR;AACA,gCAAY,iBAAZ,GAAgC,iBAAhC;AACA,wBAAI,CAAC,CAAL,EAAQ;AACJ,oCAAY,MAAZ;AACA;AACH;AACD,gCAAY,OAAZ;AACA,wBAAI,QAAQ,KAAK,KAAL,CAAW,WAAX,CAAuB,CAAvB,CAAZ;AACA,wBAAI,KAAJ,EAAW;AACP,oCAAY,IAAZ,CAAiB,CAAjB;AACA,+BAAO,KAAP;AACH;AACJ,iBA3PK;;AA6PN;AACA;AACA;AACA;AACA;AACA,2BAAW,YAAY;AACnB,wBAAI,YAAY,cAAZ,EAAJ,EAAkC;AAC9B;AACH;;AAED,wBAAI,QAAQ,YAAY,GAAZ,CAAgB,gCAAhB,CAAZ;AACA,wBAAI,KAAJ,EAAW;AACP,+BAAO,IAAI,KAAK,SAAT,CAAoB,MAAM,CAAN,CAApB,EAA8B,MAAM,CAAN,CAA9B,CAAP;AACH;AACJ,iBA3QK;;AA6QN;AACA;AACA;AACA;AACA;AACA,mCAAmB,YAAY;AAC3B,wBAAI,EAAJ;;AAEA,yBAAK,YAAY,GAAZ,CAAgB,qCAAhB,CAAL;AACA,wBAAI,EAAJ,EAAQ;AACJ,+BAAO,IAAI,KAAK,iBAAT,CAA4B,GAAG,CAAH,CAA5B,CAAP;AACH;AACJ,iBAzRK;;AA2RN;AACA;AACA;AACA;AACA;AACA,4BAAY,YAAY;AACpB,wBAAI,EAAJ;AAAA,wBAAQ,QAAQ,YAAY,CAA5B;;AAEA,gCAAY,IAAZ;;AAEA,wBAAI,SAAS,YAAY,KAAZ,CAAkB,GAAlB,CAAb;AACA,wBAAI,UAAU,YAAY,KAAZ,CAAkB,GAAlB,CAAd;;AAEA,wBAAI,CAAC,OAAL,EAAc;AACV,oCAAY,OAAZ;AACA;AACH;;AAED,yBAAK,YAAY,GAAZ,CAAgB,SAAhB,CAAL;AACA,wBAAI,EAAJ,EAAQ;AACJ,oCAAY,MAAZ;AACA,+BAAO,IAAI,KAAK,UAAT,CAAqB,GAAG,MAAH,CAAU,CAAV,EAAa,GAAG,MAAH,GAAY,CAAzB,CAArB,EAAkD,QAAQ,MAAR,CAAlD,EAAmE,KAAnE,EAA0E,QAA1E,CAAP;AACH;AACD,gCAAY,OAAZ,CAAoB,+BAApB;AACH;AAnTK,aArEK;;AA2Xf;AACA;AACA;AACA;AACA;AACA,sBAAU,YAAY;AAClB,oBAAI,IAAJ;;AAEA,oBAAI,YAAY,WAAZ,OAA8B,GAA9B,KAAsC,OAAO,YAAY,GAAZ,CAAgB,gBAAhB,CAA7C,CAAJ,EAAqF;AAAE,2BAAO,KAAK,CAAL,CAAP;AAAiB;AAC3G,aApYc;;AAsYf;AACA;AACA;AACA;AACA;AACA,yBAAa,YAAY;AACrB,oBAAI,IAAJ;;AAEA,oBAAI,YAAY,WAAZ,OAA8B,GAA9B,KAAsC,OAAO,YAAY,GAAZ,CAAgB,uBAAhB,CAA7C,CAAJ,EAA4F;AACxF,2BAAO,IAAI,KAAK,WAAT,CAAqB,KAAK,CAAL,CAArB,CAAP;AACH;AACJ,aAjZc;;AAmZf;AACA;AACA;AACA,oBAAQ,UAAS,MAAT,EAAiB;AACrB,oBAAI,QAAJ;AAAA,oBAAc,CAAd;AAAA,oBAAiB,QAAQ,YAAY,CAArC;AAAA,oBAAwC,MAAxC;AAAA,oBAAgD,UAAhD;AAAA,oBAA4D,MAA5D;;AAEA,oBAAI,CAAC,YAAY,IAAZ,CAAiB,SAAS,WAAT,GAAuB,UAAxC,CAAL,EAA0D;AACtD;AACH;;AAED,mBAAG;AACC,6BAAS,IAAT;AACA,+BAAW,IAAX;AACA,2BAAO,EAAG,SAAS,YAAY,GAAZ,CAAgB,qBAAhB,CAAZ,CAAP,EAA4D;AACxD,4BAAI,KAAK,OAAL,EAAJ;AACA,4BAAI,CAAC,CAAL,EAAQ;AACJ;AACH;AACD,4BAAI,QAAJ,EAAc;AACV,qCAAS,IAAT,CAAc,CAAd;AACH,yBAFD,MAEO;AACH,uCAAW,CAAE,CAAF,CAAX;AACH;AACJ;;AAED,6BAAS,UAAU,OAAO,CAAP,CAAnB;AACA,wBAAI,CAAC,QAAL,EAAe;AACX,8BAAM,wCAAN;AACH;AACD,6BAAS,IAAI,KAAK,MAAT,CAAiB,IAAI,KAAK,QAAT,CAAmB,QAAnB,CAAjB,EAA+C,MAA/C,EAAuD,KAAvD,EAA8D,QAA9D,CAAT;AACA,wBAAI,UAAJ,EAAgB;AACZ,mCAAW,IAAX,CAAgB,MAAhB;AACH,qBAFD,MAEO;AACH,qCAAa,CAAE,MAAF,CAAb;AACH;AACJ,iBAzBD,QAyBS,YAAY,KAAZ,CAAkB,GAAlB,CAzBT;;AA2BA,uBAAO,KAAP;;AAEA,oBAAI,MAAJ,EAAY;AACR,2BAAO,IAAP;AACH;;AAED,uBAAO,UAAP;AACH,aA/bc;;AAicf;AACA;AACA;AACA,wBAAY,YAAW;AACnB,uBAAO,KAAK,MAAL,CAAY,IAAZ,CAAP;AACH,aAtcc;;AAwcf;AACA;AACA;AACA,mBAAO;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAM,YAAY;AACd,wBAAI,IAAI,YAAY,WAAZ,EAAR;AAAA,wBAAmC,YAAY,KAA/C;AAAA,wBAAsD,QAAQ,YAAY,CAA1E;AAAA,wBAA6E,SAA7E;AAAA,wBACI,QADJ;AAAA,wBACc,IADd;AAAA,wBACoB,CADpB;AAAA,wBACuB,CADvB;AAAA,wBAC0B,IAD1B;;AAGA,wBAAI,MAAM,GAAN,IAAa,MAAM,GAAvB,EAA4B;AAAE;AAAS;;AAEvC,gCAAY,IAAZ,GANc,CAMM;;AAEpB,2BAAO,IAAP,EAAa;AACT,oCAAY,YAAY,CAAxB;AACA,4BAAI,YAAY,GAAZ,CAAgB,uDAAhB,CAAJ;AACA,4BAAI,CAAC,CAAL,EAAQ;AACJ;AACH;AACD,+BAAO,IAAI,KAAK,OAAT,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,SAAxB,EAAmC,QAAnC,CAAP;AACA,4BAAI,QAAJ,EAAc;AACV,qCAAS,IAAT,CAAc,IAAd;AACH,yBAFD,MAEO;AACH,uCAAW,CAAE,IAAF,CAAX;AACH;AACD,4BAAI,YAAY,KAAZ,CAAkB,GAAlB,CAAJ;AACH;;AAED,wBAAI,QAAJ,EAAc;AACV,4BAAI,YAAY,KAAZ,CAAkB,GAAlB,CAAJ,EAA4B;AACxB,mCAAO,KAAK,IAAL,CAAU,IAAV,EAAgB,IAAvB;AACA,uCAAW,GAAX;AACH;;AAED,4BAAI,QAAQ,SAAR,EAAJ,EAAyB;AACrB,wCAAY,IAAZ;AACH;;AAED,4BAAI,QAAQ,GAAR,EAAJ,EAAmB;AACf,wCAAY,MAAZ;AACA,mCAAO,IAAI,KAAK,KAAL,CAAW,IAAf,CAAqB,QAArB,EAA+B,IAA/B,EAAqC,KAArC,EAA4C,QAA5C,EAAsD,SAAtD,CAAP;AACH;AACJ;;AAED,gCAAY,OAAZ;AACH,iBApDE;AAqDH,sBAAM,UAAU,MAAV,EAAkB;AACpB,wBAAI,WAAW,QAAQ,QAAvB;AAAA,wBACI,WAAW,EAAE,MAAK,IAAP,EAAa,UAAU,KAAvB,EADf;AAAA,wBAEI,cAAc,EAFlB;AAAA,wBAEsB,gBAAgB,EAFtC;AAAA,wBAE0C,YAAY,EAFtD;AAAA,wBAGI,oBAHJ;AAAA,wBAG0B,uBAH1B;AAAA,wBAGmD,IAHnD;AAAA,wBAGyD,QAHzD;AAAA,wBAII,KAJJ;AAAA,wBAIW,GAJX;AAAA,wBAIgB,MAJhB;;AAMA,gCAAY,IAAZ;;AAEA,2BAAO,IAAP,EAAa;AACT,4BAAI,MAAJ,EAAY;AACR,kCAAM,QAAQ,eAAR,MAA6B,QAAQ,UAAR,EAAnC;AACH,yBAFD,MAEO;AACH,wCAAY,YAAZ,CAAyB,MAAzB,GAAkC,CAAlC;AACA,gCAAI,YAAY,IAAZ,CAAiB,KAAjB,CAAJ,EAA6B;AACzB,yCAAS,QAAT,GAAoB,IAApB;AACA,oCAAI,YAAY,KAAZ,CAAkB,GAAlB,KAA0B,CAAC,oBAA/B,EAAqD;AACjD,2DAAuB,IAAvB;AACH;AACD,iCAAC,uBAAuB,aAAvB,GAAuC,SAAxC,EACK,IADL,CACU,EAAE,UAAU,IAAZ,EADV;AAEA;AACH;AACD,kCAAM,SAAS,QAAT,MAAuB,SAAS,OAAT,EAAvB,IAA6C,SAAS,OAAT,EAAnD;AACH;;AAED,4BAAI,CAAC,GAAL,EAAU;AACN;AACH;;AAED,mCAAW,IAAX;AACA,4BAAI,IAAI,iBAAR,EAA2B;AACvB,gCAAI,iBAAJ;AACH;AACD,gCAAQ,GAAR;AACA,4BAAI,MAAM,IAAV;;AAEA,4BAAI,MAAJ,EAAY;AACR;AACA,gCAAI,IAAI,KAAJ,IAAa,IAAI,KAAJ,CAAU,MAAV,IAAoB,CAArC,EAAwC;AACpC,sCAAM,IAAI,KAAJ,CAAU,CAAV,CAAN;AACH;AACJ,yBALD,MAKO;AACH,kCAAM,GAAN;AACH;;AAED,4BAAI,OAAO,eAAe,KAAK,QAA/B,EAAyC;AACrC,gCAAI,YAAY,KAAZ,CAAkB,GAAlB,CAAJ,EAA4B;AACxB,oCAAI,YAAY,MAAZ,GAAqB,CAAzB,EAA4B;AACxB,wCAAI,oBAAJ,EAA0B;AACtB,8CAAM,uCAAN;AACH;AACD,8DAA0B,IAA1B;AACH;;AAED,wCAAQ,QAAQ,eAAR,MAA6B,QAAQ,UAAR,EAArC;;AAEA,oCAAI,CAAC,KAAL,EAAY;AACR,wCAAI,MAAJ,EAAY;AACR,8CAAM,+CAAN;AACH,qCAFD,MAEO;AACH,oDAAY,OAAZ;AACA,iDAAS,IAAT,GAAgB,EAAhB;AACA,+CAAO,QAAP;AACH;AACJ;AACD,2CAAY,OAAO,IAAI,IAAvB;AACH,6BApBD,MAoBO,IAAI,YAAY,IAAZ,CAAiB,KAAjB,CAAJ,EAA6B;AAChC,oCAAI,CAAC,MAAL,EAAa;AACT,6CAAS,QAAT,GAAoB,IAApB;AACA,wCAAI,YAAY,KAAZ,CAAkB,GAAlB,KAA0B,CAAC,oBAA/B,EAAqD;AACjD,+DAAuB,IAAvB;AACH;AACD,qCAAC,uBAAuB,aAAvB,GAAuC,SAAxC,EACK,IADL,CACU,EAAE,MAAM,IAAI,IAAZ,EAAkB,UAAU,IAA5B,EADV;AAEA;AACH,iCARD,MAQO;AACH,6CAAS,IAAT;AACH;AACJ,6BAZM,MAYA,IAAI,CAAC,MAAL,EAAa;AAChB,uCAAO,WAAW,IAAI,IAAtB;AACA,wCAAQ,IAAR;AACH;AACJ;;AAED,4BAAI,KAAJ,EAAW;AACP,wCAAY,IAAZ,CAAiB,KAAjB;AACH;;AAED,kCAAU,IAAV,CAAe,EAAE,MAAK,QAAP,EAAiB,OAAM,KAAvB,EAA8B,QAAO,MAArC,EAAf;;AAEA,4BAAI,YAAY,KAAZ,CAAkB,GAAlB,CAAJ,EAA4B;AACxB;AACH;;AAED,4BAAI,YAAY,KAAZ,CAAkB,GAAlB,KAA0B,oBAA9B,EAAoD;;AAEhD,gCAAI,uBAAJ,EAA6B;AACzB,sCAAM,uCAAN;AACH;;AAED,mDAAuB,IAAvB;;AAEA,gCAAI,YAAY,MAAZ,GAAqB,CAAzB,EAA4B;AACxB,wCAAQ,IAAI,KAAK,KAAT,CAAgB,WAAhB,CAAR;AACH;AACD,0CAAc,IAAd,CAAmB,EAAE,MAAK,IAAP,EAAa,OAAM,KAAnB,EAA0B,QAAO,MAAjC,EAAnB;;AAEA,mCAAO,IAAP;AACA,0CAAc,EAAd;AACA,sDAA0B,KAA1B;AACH;AACJ;;AAED,gCAAY,MAAZ;AACA,6BAAS,IAAT,GAAgB,uBAAuB,aAAvB,GAAuC,SAAvD;AACA,2BAAO,QAAP;AACH,iBA1KE;AA2KH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAAY,YAAY;AACpB,wBAAI,IAAJ;AAAA,wBAAU,SAAS,EAAnB;AAAA,wBAAuB,KAAvB;AAAA,wBAA8B,OAA9B;AAAA,wBAAuC,IAAvC;AAAA,wBAA6C,WAAW,KAAxD;AACA,wBAAK,YAAY,WAAZ,OAA8B,GAA9B,IAAqC,YAAY,WAAZ,OAA8B,GAApE,IACA,YAAY,IAAZ,CAAiB,UAAjB,CADJ,EACkC;AAC9B;AACH;;AAED,gCAAY,IAAZ;;AAEA,4BAAQ,YAAY,GAAZ,CAAgB,8DAAhB,CAAR;AACA,wBAAI,KAAJ,EAAW;AACP,+BAAO,MAAM,CAAN,CAAP;;AAEA,4BAAI,UAAU,KAAK,IAAL,CAAU,KAAV,CAAd;AACA,iCAAS,QAAQ,IAAjB;AACA,mCAAW,QAAQ,QAAnB;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAAI,CAAC,YAAY,KAAZ,CAAkB,GAAlB,CAAL,EAA6B;AACzB,wCAAY,OAAZ,CAAoB,qBAApB;AACA;AACH;;AAED,oCAAY,YAAZ,CAAyB,MAAzB,GAAkC,CAAlC;;AAEA,4BAAI,YAAY,IAAZ,CAAiB,MAAjB,CAAJ,EAA8B;AAAE;AAC5B,mCAAO,OAAO,QAAQ,UAAf,EAA2B,oBAA3B,CAAP;AACH;;AAED,kCAAU,QAAQ,KAAR,EAAV;;AAEA,4BAAI,OAAJ,EAAa;AACT,wCAAY,MAAZ;AACA,mCAAO,IAAI,KAAK,KAAL,CAAW,UAAf,CAA2B,IAA3B,EAAiC,MAAjC,EAAyC,OAAzC,EAAkD,IAAlD,EAAwD,QAAxD,CAAP;AACH,yBAHD,MAGO;AACH,wCAAY,OAAZ;AACH;AACJ,qBA/BD,MA+BO;AACH,oCAAY,MAAZ;AACH;AACJ;AA1OE,aA3cQ;;AAwrBf;AACA;AACA;AACA;AACA,oBAAQ,YAAY;AAChB,oBAAI,WAAW,KAAK,QAApB;;AAEA,uBAAO,KAAK,OAAL,MAAkB,SAAS,OAAT,EAAlB,IAAwC,SAAS,QAAT,EAAxC,IAA+D,SAAS,GAAT,EAA/D,IACA,SAAS,IAAT,EADA,IACsB,SAAS,OAAT,EADtB,IAC6C,SAAS,UAAT,EADpD;AAEH,aAjsBc;;AAmsBf;AACA;AACA;AACA;AACA;AACA,iBAAK,YAAY;AACb,uBAAO,YAAY,KAAZ,CAAkB,GAAlB,KAA0B,YAAY,IAAZ,CAAiB,GAAjB,CAAjC;AACH,aA1sBc;;AA4sBf;AACA;AACA;AACA;AACA;AACA,mBAAO,YAAY;AACf,oBAAI,KAAJ;;AAEA;AACA,oBAAI,CAAE,YAAY,GAAZ,CAAgB,YAAhB,CAAN,EAAqC;AAAE;AAAS;AAChD,wBAAQ,YAAY,GAAZ,CAAgB,MAAhB,CAAR;AACA,oBAAI,CAAC,KAAL,EAAY;AACR,4BAAQ,OAAO,KAAK,QAAL,CAAc,QAArB,EAA+B,uBAA/B,CAAR;AACH;AACD,2BAAW,GAAX;AACA,uBAAO,IAAI,KAAK,KAAT,CAAgB,KAAhB,CAAP;AACH,aA5tBc;;AA8tBf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAS,YAAY;AACjB,oBAAI,CAAJ;AAAA,oBAAO,CAAP;AAAA,oBAAU,CAAV;AAAA,oBAAa,QAAQ,YAAY,CAAjC;;AAEA,oBAAI,KAAK,UAAL,EAAJ;;AAEA,oBAAI,YAAY,GAAZ,CAAgB,oBAAhB,KACA,YAAY,GAAZ,CAAgB,4EAAhB,CADA,IAEA,YAAY,KAAZ,CAAkB,GAAlB,CAFA,IAE0B,YAAY,KAAZ,CAAkB,GAAlB,CAF1B,IAEoD,KAAK,SAAL,EAFpD,IAGA,YAAY,GAAZ,CAAgB,eAAhB,CAHA,IAGqC,YAAY,GAAZ,CAAgB,cAAhB,CAHrC,IAIA,KAAK,QAAL,CAAc,aAAd,EAJJ;;AAMA,oBAAI,CAAE,CAAN,EAAS;AACL,gCAAY,IAAZ;AACA,wBAAI,YAAY,KAAZ,CAAkB,GAAlB,CAAJ,EAA4B;AACxB,4BAAI,CAAC,IAAI,KAAK,QAAL,EAAL,KAAyB,YAAY,KAAZ,CAAkB,GAAlB,CAA7B,EAAqD;AACjD,gCAAI,IAAI,KAAK,KAAT,CAAgB,CAAhB,CAAJ;AACA,wCAAY,MAAZ;AACH,yBAHD,MAGO;AACH,wCAAY,OAAZ,CAAoB,qBAApB;AACH;AACJ,qBAPD,MAOO;AACH,oCAAY,MAAZ;AACH;AACJ;;AAED,oBAAI,CAAJ,EAAO;AAAE,2BAAO,IAAI,KAAK,OAAT,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,KAAxB,EAA+B,QAA/B,CAAP;AAAkD;AAC9D,aApwBc;;AAswBf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAY,YAAY;AACpB,oBAAI,IAAI,YAAY,WAAZ,EAAR;;AAEA,oBAAI,MAAM,GAAV,EAAe;AACX,gCAAY,IAAZ;AACA,wBAAI,oBAAoB,YAAY,GAAZ,CAAgB,cAAhB,CAAxB;AACA,wBAAI,iBAAJ,EAAuB;AACnB,oCAAY,MAAZ;AACA,+BAAO,IAAI,KAAK,UAAT,CAAqB,iBAArB,CAAP;AACH;AACD,gCAAY,OAAZ;AACH;;AAED,oBAAI,MAAM,GAAN,IAAa,MAAM,GAAnB,IAA0B,MAAM,GAAhC,IAAuC,MAAM,GAA7C,IAAoD,MAAM,GAA9D,EAAmE;AAC/D,gCAAY,CAAZ;AACA,wBAAI,MAAM,GAAN,IAAa,YAAY,WAAZ,OAA8B,GAA/C,EAAoD;AAChD,4BAAI,IAAJ;AACA,oCAAY,CAAZ;AACH;AACD,2BAAO,YAAY,YAAZ,EAAP,EAAmC;AAAE,oCAAY,CAAZ;AAAkB;AACvD,2BAAO,IAAI,KAAK,UAAT,CAAqB,CAArB,CAAP;AACH,iBARD,MAQO,IAAI,YAAY,YAAZ,CAAyB,CAAC,CAA1B,CAAJ,EAAkC;AACrC,2BAAO,IAAI,KAAK,UAAT,CAAqB,GAArB,CAAP;AACH,iBAFM,MAEA;AACH,2BAAO,IAAI,KAAK,UAAT,CAAqB,IAArB,CAAP;AACH;AACJ,aAzyBc;AA0yBf;AACA;AACA;AACA;AACA,0BAAc,YAAY;AACtB,uBAAO,KAAK,QAAL,CAAc,IAAd,CAAP;AACH,aAhzBc;AAizBf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAU,UAAU,MAAV,EAAkB;AACxB,oBAAI,QAAQ,YAAY,CAAxB;AAAA,oBAA2B,QAA3B;AAAA,oBAAqC,UAArC;AAAA,oBAAiD,CAAjD;AAAA,oBAAoD,CAApD;AAAA,oBAAuD,UAAvD;AAAA,oBAAmE,IAAnE;AAAA,oBAAyE,SAAzE;;AAEA,uBAAQ,WAAW,aAAa,KAAK,MAAL,EAAxB,CAAD,IAA6C,WAAW,OAAO,YAAY,IAAZ,CAAiB,MAAjB,CAAlB,CAA7C,KAA8F,IAAI,KAAK,OAAL,EAAlG,CAAP,EAA0H;AACtH,wBAAI,IAAJ,EAAU;AACN,oCAAY,OAAO,KAAK,UAAZ,EAAwB,oBAAxB,CAAZ;AACH,qBAFD,MAEO,IAAI,SAAJ,EAAe;AAClB,8BAAM,mDAAN;AACH,qBAFM,MAEA,IAAI,UAAJ,EAAgB;AACnB,4BAAI,UAAJ,EAAgB;AACZ,yCAAa,WAAW,MAAX,CAAkB,UAAlB,CAAb;AACH,yBAFD,MAEO;AACH,yCAAa,UAAb;AACH;AACJ,qBANM,MAMA;AACH,4BAAI,UAAJ,EAAgB;AAAE,kCAAM,gDAAN;AAA0D;AAC5E,4BAAI,YAAY,WAAZ,EAAJ;AACA,4BAAI,QAAJ,EAAc;AACV,qCAAS,IAAT,CAAc,CAAd;AACH,yBAFD,MAEO;AACH,uCAAW,CAAE,CAAF,CAAX;AACH;AACD,4BAAI,IAAJ;AACH;AACD,wBAAI,MAAM,GAAN,IAAa,MAAM,GAAnB,IAA0B,MAAM,GAAhC,IAAuC,MAAM,GAA7C,IAAoD,MAAM,GAA9D,EAAmE;AAC/D;AACH;AACJ;;AAED,oBAAI,QAAJ,EAAc;AAAE,2BAAO,IAAI,KAAK,QAAT,CAAmB,QAAnB,EAA6B,UAA7B,EAAyC,SAAzC,EAAoD,KAApD,EAA2D,QAA3D,CAAP;AAA8E;AAC9F,oBAAI,UAAJ,EAAgB;AAAE,0BAAM,wEAAN;AAAkF;AACvG,aAx1Bc;AAy1Bf,uBAAW,YAAY;AACnB,oBAAI,CAAE,YAAY,KAAZ,CAAkB,GAAlB,CAAN,EAA8B;AAAE;AAAS;;AAEzC,oBAAI,WAAW,KAAK,QAApB;AAAA,oBACI,GADJ;AAAA,oBACS,GADT;AAAA,oBACc,EADd;;AAGA,oBAAI,EAAE,MAAM,SAAS,aAAT,EAAR,CAAJ,EAAuC;AACnC,0BAAM,OAAO,gDAAP,CAAN;AACH;;AAED,qBAAK,YAAY,GAAZ,CAAgB,YAAhB,CAAL;AACA,oBAAI,EAAJ,EAAQ;AACJ,0BAAM,SAAS,MAAT,MAAqB,YAAY,GAAZ,CAAgB,UAAhB,CAArB,IAAoD,YAAY,GAAZ,CAAgB,SAAhB,CAApD,IAAkF,SAAS,aAAT,EAAxF;AACH;;AAED,2BAAW,GAAX;;AAEA,uBAAO,IAAI,KAAK,SAAT,CAAoB,GAApB,EAAyB,EAAzB,EAA6B,GAA7B,CAAP;AACH,aA32Bc;;AA62Bf;AACA;AACA;AACA;AACA,mBAAO,YAAY;AACf,oBAAI,OAAJ;AACA,oBAAI,YAAY,KAAZ,CAAkB,GAAlB,MAA2B,UAAU,KAAK,OAAL,EAArC,KAAwD,YAAY,KAAZ,CAAkB,GAAlB,CAA5D,EAAoF;AAChF,2BAAO,OAAP;AACH;AACJ,aAt3Bc;;AAw3Bf,0BAAc,YAAW;AACrB,oBAAI,QAAQ,KAAK,KAAL,EAAZ;;AAEA,oBAAI,KAAJ,EAAW;AACP,4BAAQ,IAAI,KAAK,OAAT,CAAiB,IAAjB,EAAuB,KAAvB,CAAR;AACH;AACD,uBAAO,KAAP;AACH,aA/3Bc;;AAi4Bf,6BAAiB,YAAW;AACxB,oBAAI,eAAe,KAAK,YAAL,EAAnB;AACA,oBAAI,YAAJ,EAAkB;AACd,2BAAO,IAAI,KAAK,eAAT,CAAyB,YAAzB,CAAP;AACH;AACJ,aAt4Bc;;AAw4Bf;AACA;AACA;AACA,qBAAS,YAAY;AACjB,oBAAI,SAAJ,EAAe,CAAf,EAAkB,KAAlB,EAAyB,SAAzB;;AAEA,4BAAY,IAAZ;;AAEA,oBAAI,QAAQ,eAAZ,EAA6B;AACzB,gCAAY,aAAa,YAAY,CAAzB,CAAZ;AACH;;AAED,uBAAO,IAAP,EAAa;AACT,wBAAI,KAAK,YAAL,EAAJ;AACA,wBAAI,CAAC,CAAL,EAAQ;AACJ;AACH;AACD,wBAAI,SAAJ,EAAe;AACX,kCAAU,IAAV,CAAe,CAAf;AACH,qBAFD,MAEO;AACH,oCAAY,CAAE,CAAF,CAAZ;AACH;AACD,gCAAY,YAAZ,CAAyB,MAAzB,GAAkC,CAAlC;AACA,wBAAI,EAAE,SAAF,IAAe,UAAU,MAAV,GAAmB,CAAtC,EAAyC;AACrC,8BAAM,yDAAN;AACH;AACD,wBAAI,CAAE,YAAY,KAAZ,CAAkB,GAAlB,CAAN,EAA8B;AAAE;AAAQ;AACxC,wBAAI,EAAE,SAAN,EAAiB;AACb,8BAAM,yDAAN;AACH;AACD,gCAAY,YAAZ,CAAyB,MAAzB,GAAkC,CAAlC;AACH;;AAED,oBAAI,cAAc,QAAQ,KAAK,KAAL,EAAtB,CAAJ,EAAyC;AACrC,gCAAY,MAAZ;AACA,wBAAI,UAAU,IAAI,KAAK,OAAT,CAAkB,SAAlB,EAA6B,KAA7B,EAAoC,QAAQ,aAA5C,CAAd;AACA,wBAAI,QAAQ,eAAZ,EAA6B;AACzB,gCAAQ,SAAR,GAAoB,SAApB;AACH;AACD,2BAAO,OAAP;AACH,iBAPD,MAOO;AACH,gCAAY,OAAZ;AACH;AACJ,aAn7Bc;AAo7Bf,kBAAM,UAAU,YAAV,EAAwB;AAC1B,oBAAI,IAAJ;AAAA,oBAAU,KAAV;AAAA,oBAAiB,cAAc,YAAY,CAA3C;AAAA,oBAA8C,IAAI,YAAY,WAAZ,EAAlD;AAAA,oBAA6E,SAA7E;AAAA,oBAAwF,KAAxF;AAAA,oBAA+F,UAA/F;;AAEA,oBAAI,MAAM,GAAN,IAAa,MAAM,GAAnB,IAA0B,MAAM,GAAhC,IAAuC,MAAM,GAAjD,EAAsD;AAAE;AAAS;;AAEjE,4BAAY,IAAZ;;AAEA,uBAAO,KAAK,QAAL,MAAmB,KAAK,YAAL,EAA1B;AACA,oBAAI,IAAJ,EAAU;AACN,iCAAa,OAAO,IAAP,KAAgB,QAA7B;;AAEA,wBAAI,UAAJ,EAAgB;AACZ,gCAAQ,KAAK,eAAL,EAAR;AACH;;AAED,gCAAY,YAAZ,CAAyB,MAAzB,GAAkC,CAAlC;AACA,wBAAI,CAAC,KAAL,EAAY;AACR;AACA;AACA;AACA,gCAAQ,CAAC,UAAD,IAAe,KAAK,MAAL,GAAc,CAA7B,IAAkC,KAAK,GAAL,GAAW,KAArD;;AAEA;AACA;AACA,4BAAI,gBAAgB,CAAC,YAAD,KAAkB,QAAQ,QAAR,IAAoB,UAAtC,CAApB;;AAEA,4BAAI,aAAJ,EAAmB;AACf,oCAAQ,KAAK,KAAL,EAAR;AACH;AACD,4BAAI,CAAC,KAAL,EAAY;AACR,oCAAQ,KAAK,cAAL,EAAR;AACA,gCAAI,KAAJ,EAAW;AACP,4CAAY,MAAZ;AACA;AACA,uCAAO,IAAK,KAAK,IAAV,CAAgB,IAAhB,EAAsB,KAAtB,EAA6B,KAA7B,EAAoC,KAApC,EAA2C,WAA3C,EAAwD,QAAxD,CAAP;AACH;AACJ;AACD,4BAAI,CAAC,aAAD,IAAkB,CAAC,KAAvB,EAA8B;AAC1B,oCAAQ,KAAK,KAAL,EAAR;AACH;;AAED,oCAAY,KAAK,SAAL,EAAZ;AACH;;AAED,wBAAI,SAAS,KAAK,GAAL,EAAb,EAAyB;AACrB,oCAAY,MAAZ;AACA,+BAAO,IAAK,KAAK,IAAV,CAAgB,IAAhB,EAAsB,KAAtB,EAA6B,SAA7B,EAAwC,KAAxC,EAA+C,WAA/C,EAA4D,QAA5D,CAAP;AACH,qBAHD,MAGO;AACH,oCAAY,OAAZ;AACA,4BAAI,SAAS,CAAC,YAAd,EAA4B;AACxB,mCAAO,KAAK,IAAL,CAAU,IAAV,CAAP;AACH;AACJ;AACJ,iBA7CD,MA6CO;AACH,gCAAY,MAAZ;AACH;AACJ,aA5+Bc;AA6+Bf,4BAAgB,YAAY;AACxB,oBAAI,QAAQ,YAAY,GAAZ,CAAgB,uBAAhB,CAAZ;AACA,oBAAI,KAAJ,EAAW;AACP,2BAAO,IAAI,KAAK,SAAT,CAAoB,MAAM,CAAN,CAApB,CAAP;AACH;AACJ,aAl/Bc;;AAo/Bf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAU,YAAY;AAClB,oBAAI,IAAJ;AAAA,oBAAU,QAAV;AAAA,oBAAoB,QAAQ,YAAY,CAAxC;;AAEA,oBAAI,MAAM,YAAY,GAAZ,CAAgB,cAAhB,CAAV;;AAEA,oBAAI,GAAJ,EAAS;AACL,wBAAI,UAAU,CAAC,MAAM,KAAK,aAAL,EAAN,GAA6B,IAA9B,KAAuC,EAArD;;AAEA,wBAAK,OAAO,KAAK,QAAL,CAAc,MAAd,MAA0B,KAAK,QAAL,CAAc,GAAd,EAAtC,EAA4D;AACxD,mCAAW,KAAK,aAAL,EAAX;;AAEA,4BAAI,CAAC,YAAY,KAAZ,CAAkB,GAAlB,CAAL,EAA6B;AACzB,wCAAY,CAAZ,GAAgB,KAAhB;AACA,kCAAM,6DAAN;AACH;AACD,mCAAW,YAAY,IAAI,KAAK,KAAT,CAAgB,QAAhB,CAAvB;AACA,+BAAO,IAAI,KAAK,MAAT,CAAiB,IAAjB,EAAuB,QAAvB,EAAiC,OAAjC,EAA0C,KAA1C,EAAiD,QAAjD,CAAP;AACH,qBATD,MAUK;AACD,oCAAY,CAAZ,GAAgB,KAAhB;AACA,8BAAM,4BAAN;AACH;AACJ;AACJ,aArhCc;;AAuhCf,2BAAe,YAAW;AACtB,oBAAI,CAAJ;AAAA,oBAAO,UAAU,EAAjB;AAAA,oBAAqB,UAArB;AAAA,oBAAiC,KAAjC;;AAEA;AACA,oBAAI,CAAE,YAAY,KAAZ,CAAkB,GAAlB,CAAN,EAA8B;AAAE,2BAAO,IAAP;AAAc;AAC9C,mBAAG;AACC,wBAAI,KAAK,YAAL,EAAJ;AACA,wBAAI,CAAJ,EAAO;AACH,qCAAa,CAAb;AACA,gCAAQ,IAAR;AACA,gCAAO,UAAP;AACI,iCAAK,KAAL;AACI,6CAAa,MAAb;AACA,wCAAQ,KAAR;AACA;AACJ,iCAAK,MAAL;AACI,6CAAa,UAAb;AACA,wCAAQ,KAAR;AACA;AARR;AAUA,gCAAQ,UAAR,IAAsB,KAAtB;AACA,4BAAI,CAAE,YAAY,KAAZ,CAAkB,GAAlB,CAAN,EAA8B;AAAE;AAAQ;AAC3C;AACJ,iBAlBD,QAkBS,CAlBT;AAmBA,2BAAW,GAAX;AACA,uBAAO,OAAP;AACH,aAjjCc;;AAmjCf,0BAAc,YAAW;AACrB,oBAAI,MAAM,YAAY,GAAZ,CAAgB,qDAAhB,CAAV;AACA,oBAAI,GAAJ,EAAS;AACL,2BAAO,IAAI,CAAJ,CAAP;AACH;AACJ,aAxjCc;;AA0jCf,0BAAc,YAAY;AACtB,oBAAI,WAAW,KAAK,QAApB;AAAA,oBAA8B,QAAQ,EAAtC;AAAA,oBAA0C,CAA1C;AAAA,oBAA6C,CAA7C;AACA,4BAAY,IAAZ;AACA,mBAAG;AACC,wBAAI,SAAS,OAAT,MAAsB,SAAS,QAAT,EAA1B;AACA,wBAAI,CAAJ,EAAO;AACH,8BAAM,IAAN,CAAW,CAAX;AACH,qBAFD,MAEO,IAAI,YAAY,KAAZ,CAAkB,GAAlB,CAAJ,EAA4B;AAC/B,4BAAI,KAAK,QAAL,EAAJ;AACA,4BAAI,KAAK,KAAL,EAAJ;AACA,4BAAI,YAAY,KAAZ,CAAkB,GAAlB,CAAJ,EAA4B;AACxB,gCAAI,KAAK,CAAT,EAAY;AACR,sCAAM,IAAN,CAAW,IAAI,KAAK,KAAT,CAAgB,IAAI,KAAK,IAAT,CAAe,CAAf,EAAkB,CAAlB,EAAqB,IAArB,EAA2B,IAA3B,EAAiC,YAAY,CAA7C,EAAgD,QAAhD,EAA0D,IAA1D,CAAhB,CAAX;AACH,6BAFD,MAEO,IAAI,CAAJ,EAAO;AACV,sCAAM,IAAN,CAAW,IAAI,KAAK,KAAT,CAAgB,CAAhB,CAAX;AACH,6BAFM,MAEA;AACH,sCAAM,uCAAN;AACH;AACJ,yBARD,MAQO;AACH,kCAAM,qBAAN,EAA6B,OAA7B;AACH;AACJ;AACJ,iBAnBD,QAmBS,CAnBT;;AAqBA,4BAAY,MAAZ;AACA,oBAAI,MAAM,MAAN,GAAe,CAAnB,EAAsB;AAClB,2BAAO,IAAI,KAAK,UAAT,CAAqB,KAArB,CAAP;AACH;AACJ,aAtlCc;;AAwlCf,2BAAe,YAAY;AACvB,oBAAI,WAAW,KAAK,QAApB;AAAA,oBAA8B,WAAW,EAAzC;AAAA,oBAA6C,CAA7C;AACA,mBAAG;AACC,wBAAI,KAAK,YAAL,EAAJ;AACA,wBAAI,CAAJ,EAAO;AACH,iCAAS,IAAT,CAAc,CAAd;AACA,4BAAI,CAAE,YAAY,KAAZ,CAAkB,GAAlB,CAAN,EAA8B;AAAE;AAAQ;AAC3C,qBAHD,MAGO;AACH,4BAAI,SAAS,QAAT,EAAJ;AACA,4BAAI,CAAJ,EAAO;AACH,qCAAS,IAAT,CAAc,CAAd;AACA,gCAAI,CAAE,YAAY,KAAZ,CAAkB,GAAlB,CAAN,EAA8B;AAAE;AAAQ;AAC3C;AACJ;AACJ,iBAZD,QAYS,CAZT;;AAcA,uBAAO,SAAS,MAAT,GAAkB,CAAlB,GAAsB,QAAtB,GAAiC,IAAxC;AACH,aAzmCc;;AA2mCf,mBAAO,YAAY;AACf,oBAAI,QAAJ;AAAA,oBAAc,KAAd;AAAA,oBAAqB,KAArB;AAAA,oBAA4B,SAA5B;AAAA,oBAAuC,QAAQ,YAAY,CAA3D;;AAEA,oBAAI,QAAQ,eAAZ,EAA6B;AACzB,gCAAY,aAAa,KAAb,CAAZ;AACH;;AAED,4BAAY,IAAZ;;AAEA,oBAAI,YAAY,IAAZ,CAAiB,QAAjB,CAAJ,EAAgC;AAC5B,+BAAW,KAAK,aAAL,EAAX;;AAEA,4BAAQ,KAAK,KAAL,EAAR;;AAEA,wBAAI,CAAC,KAAL,EAAY;AACR,8BAAM,+DAAN;AACH;;AAED,gCAAY,MAAZ;;AAEA,4BAAQ,IAAI,KAAK,KAAT,CAAgB,KAAhB,EAAuB,QAAvB,EAAiC,KAAjC,EAAwC,QAAxC,CAAR;AACA,wBAAI,QAAQ,eAAZ,EAA6B;AACzB,8BAAM,SAAN,GAAkB,SAAlB;AACH;;AAED,2BAAO,KAAP;AACH;;AAED,4BAAY,OAAZ;AACH,aAxoCc;;AA0oCf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAQ,YAAY;AAChB,oBAAI,IAAJ;AAAA,oBACI,QAAQ,YAAY,CADxB;AAAA,oBAEI,MAAQ,YAAY,GAAZ,CAAgB,cAAhB,CAFZ;;AAIA,oBAAI,GAAJ,EAAS;AACL,wBAAI,UAAU,EAAE,QAAS,IAAX,EAAd;;AAEA,wBAAK,OAAO,KAAK,QAAL,CAAc,MAAd,MAA0B,KAAK,QAAL,CAAc,GAAd,EAAtC,EAA4D;;AAExD,4BAAI,CAAC,YAAY,KAAZ,CAAkB,GAAlB,CAAL,EAA6B;AACzB,wCAAY,CAAZ,GAAgB,KAAhB;AACA,kCAAM,8BAAN;AACH;;AAED,+BAAO,IAAI,KAAK,MAAT,CAAiB,IAAjB,EAAuB,IAAvB,EAA6B,OAA7B,EAAsC,KAAtC,EAA6C,QAA7C,CAAP;AACH,qBARD,MASK;AACD,oCAAY,CAAZ,GAAgB,KAAhB;AACA,8BAAM,4BAAN;AACH;AACJ;AACJ,aA1qCc;;AA4qCf;AACA;AACA;AACA;AACA;AACA,uBAAW,YAAY;AACnB,oBAAI,QAAQ,YAAY,CAAxB;AAAA,oBAA2B,IAA3B;AAAA,oBAAiC,KAAjC;AAAA,oBAAwC,KAAxC;AAAA,oBAA+C,qBAA/C;AAAA,oBACI,aADJ;AAAA,oBACmB,aADnB;AAAA,oBACkC,UADlC;AAAA,oBAC8C,WAAW,IADzD;AAAA,oBAC+D,WAAW,IAD1E;;AAGA,oBAAI,YAAY,WAAZ,OAA8B,GAAlC,EAAuC;AAAE;AAAS;;AAElD,wBAAQ,KAAK,QAAL,OAAoB,KAAK,MAAL,EAApB,IAAqC,KAAK,KAAL,EAA7C;AACA,oBAAI,KAAJ,EAAW;AACP,2BAAO,KAAP;AACH;;AAED,4BAAY,IAAZ;;AAEA,uBAAO,YAAY,GAAZ,CAAgB,WAAhB,CAAP;;AAEA,oBAAI,CAAC,IAAL,EAAW;AAAE;AAAS;;AAEtB,wCAAwB,IAAxB;AACA,oBAAI,KAAK,MAAL,CAAY,CAAZ,KAAkB,GAAlB,IAAyB,KAAK,OAAL,CAAa,GAAb,EAAkB,CAAlB,IAAuB,CAApD,EAAuD;AACnD,4CAAwB,MAAM,KAAK,KAAL,CAAW,KAAK,OAAL,CAAa,GAAb,EAAkB,CAAlB,IAAuB,CAAlC,CAA9B;AACH;;AAED,wBAAO,qBAAP;AACI,yBAAK,UAAL;AACI,wCAAgB,IAAhB;AACA,mCAAW,KAAX;AACA;AACJ,yBAAK,YAAL;AACI,wCAAgB,IAAhB;AACA,mCAAW,KAAX;AACA;AACJ,yBAAK,YAAL;AACA,yBAAK,gBAAL;AACI,wCAAgB,IAAhB;AACA;AACJ,yBAAK,WAAL;AACA,yBAAK,WAAL;AACI,qCAAa,IAAb;AACA,mCAAW,KAAX;AACA;AACJ;AACI,qCAAa,IAAb;AACA;AApBR;;AAuBA,4BAAY,YAAZ,CAAyB,MAAzB,GAAkC,CAAlC;;AAEA,oBAAI,aAAJ,EAAmB;AACf,4BAAQ,KAAK,MAAL,EAAR;AACA,wBAAI,CAAC,KAAL,EAAY;AACR,8BAAM,cAAc,IAAd,GAAqB,aAA3B;AACH;AACJ,iBALD,MAKO,IAAI,aAAJ,EAAmB;AACtB,4BAAQ,KAAK,UAAL,EAAR;AACA,wBAAI,CAAC,KAAL,EAAY;AACR,8BAAM,cAAc,IAAd,GAAqB,aAA3B;AACH;AACJ,iBALM,MAKA,IAAI,UAAJ,EAAgB;AACnB,4BAAQ,CAAC,YAAY,GAAZ,CAAgB,SAAhB,KAA8B,EAA/B,EAAmC,IAAnC,EAAR;AACA,+BAAY,YAAY,WAAZ,MAA6B,GAAzC;AACA,wBAAI,KAAJ,EAAW;AACP,gCAAQ,IAAI,KAAK,SAAT,CAAoB,KAApB,CAAR;AACH;AACJ;;AAED,oBAAI,QAAJ,EAAc;AACV,4BAAQ,KAAK,YAAL,EAAR;AACH;;AAED,oBAAI,SAAU,CAAC,QAAD,IAAa,KAAb,IAAsB,YAAY,KAAZ,CAAkB,GAAlB,CAApC,EAA6D;AACzD,gCAAY,MAAZ;AACA,2BAAO,IAAK,KAAK,SAAV,CAAqB,IAArB,EAA2B,KAA3B,EAAkC,KAAlC,EAAyC,KAAzC,EAAgD,QAAhD,EACH,QAAQ,eAAR,GAA0B,aAAa,KAAb,CAA1B,GAAgD,IAD7C,EAEH,QAFG,CAAP;AAIH;;AAED,4BAAY,OAAZ,CAAoB,kCAApB;AACH,aA/vCc;;AAiwCf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAO,YAAY;AACf,oBAAI,CAAJ;AAAA,oBAAO,cAAc,EAArB;;AAEA,mBAAG;AACC,wBAAI,KAAK,UAAL,EAAJ;AACA,wBAAI,CAAJ,EAAO;AACH,oCAAY,IAAZ,CAAiB,CAAjB;AACA,4BAAI,CAAE,YAAY,KAAZ,CAAkB,GAAlB,CAAN,EAA8B;AAAE;AAAQ;AAC3C;AACJ,iBAND,QAMS,CANT;;AAQA,oBAAI,YAAY,MAAZ,GAAqB,CAAzB,EAA4B;AACxB,2BAAO,IAAI,KAAK,KAAT,CAAgB,WAAhB,CAAP;AACH;AACJ,aAvxCc;AAwxCf,uBAAW,YAAY;AACnB,oBAAI,YAAY,WAAZ,OAA8B,GAAlC,EAAuC;AACnC,2BAAO,YAAY,GAAZ,CAAgB,eAAhB,CAAP;AACH;AACJ,aA5xCc;AA6xCf,iBAAK,YAAY;AACb,oBAAI,CAAJ,EAAO,CAAP;;AAEA,4BAAY,IAAZ;AACA,oBAAI,YAAY,KAAZ,CAAkB,GAAlB,CAAJ,EAA4B;AACxB,wBAAI,KAAK,QAAL,EAAJ;AACA,wBAAI,KAAK,YAAY,KAAZ,CAAkB,GAAlB,CAAT,EAAiC;AAC7B,oCAAY,MAAZ;AACA,4BAAI,IAAI,KAAK,UAAT,CAAqB,CAAC,CAAD,CAArB,CAAJ;AACA,0BAAE,MAAF,GAAW,IAAX;AACA,+BAAO,CAAP;AACH;AACD,gCAAY,OAAZ,CAAoB,cAApB;AACA;AACH;AACD,4BAAY,OAAZ;AACH,aA7yCc;AA8yCf,4BAAgB,YAAY;AACxB,oBAAI,CAAJ,EAAO,CAAP,EAAU,EAAV,EAAc,SAAd,EAAyB,QAAzB;AACA,oBAAI,KAAK,OAAL,EAAJ;AACA,oBAAI,CAAJ,EAAO;AACH,+BAAW,YAAY,YAAZ,CAAyB,CAAC,CAA1B,CAAX;AACA,2BAAO,IAAP,EAAa;AACT,4BAAI,YAAY,IAAZ,CAAiB,UAAjB,CAAJ,EAAkC;AAC9B;AACH;;AAED,oCAAY,IAAZ;;AAEA,6BAAK,YAAY,KAAZ,CAAkB,GAAlB,KAA0B,YAAY,KAAZ,CAAkB,GAAlB,CAA/B;;AAEA,4BAAI,CAAC,EAAL,EAAS;AAAE,wCAAY,MAAZ,GAAsB;AAAQ;;AAEzC,4BAAI,KAAK,OAAL,EAAJ;;AAEA,4BAAI,CAAC,CAAL,EAAQ;AAAE,wCAAY,OAAZ,GAAuB;AAAQ;AACzC,oCAAY,MAAZ;;AAEA,0BAAE,UAAF,GAAe,IAAf;AACA,0BAAE,UAAF,GAAe,IAAf;AACA,oCAAY,IAAI,KAAK,SAAT,CAAoB,EAApB,EAAwB,CAAC,aAAa,CAAd,EAAiB,CAAjB,CAAxB,EAA6C,QAA7C,CAAZ;AACA,mCAAW,YAAY,YAAZ,CAAyB,CAAC,CAA1B,CAAX;AACH;AACD,2BAAO,aAAa,CAApB;AACH;AACJ,aA10Cc;AA20Cf,sBAAU,YAAY;AAClB,oBAAI,CAAJ,EAAO,CAAP,EAAU,EAAV,EAAc,SAAd,EAAyB,QAAzB;AACA,oBAAI,KAAK,cAAL,EAAJ;AACA,oBAAI,CAAJ,EAAO;AACH,+BAAW,YAAY,YAAZ,CAAyB,CAAC,CAA1B,CAAX;AACA,2BAAO,IAAP,EAAa;AACT,6BAAK,YAAY,GAAZ,CAAgB,UAAhB,KAAgC,CAAC,QAAD,KAAc,YAAY,KAAZ,CAAkB,GAAlB,KAA0B,YAAY,KAAZ,CAAkB,GAAlB,CAAxC,CAArC;AACA,4BAAI,CAAC,EAAL,EAAS;AACL;AACH;AACD,4BAAI,KAAK,cAAL,EAAJ;AACA,4BAAI,CAAC,CAAL,EAAQ;AACJ;AACH;;AAED,0BAAE,UAAF,GAAe,IAAf;AACA,0BAAE,UAAF,GAAe,IAAf;AACA,oCAAY,IAAI,KAAK,SAAT,CAAoB,EAApB,EAAwB,CAAC,aAAa,CAAd,EAAiB,CAAjB,CAAxB,EAA6C,QAA7C,CAAZ;AACA,mCAAW,YAAY,YAAZ,CAAyB,CAAC,CAA1B,CAAX;AACH;AACD,2BAAO,aAAa,CAApB;AACH;AACJ,aAj2Cc;AAk2Cf,wBAAY,YAAY;AACpB,oBAAI,CAAJ;AAAA,oBAAO,CAAP;AAAA,oBAAU,QAAQ,YAAY,CAA9B;AAAA,oBAAiC,SAAjC;;AAEA,oBAAI,KAAK,SAAL,EAAJ;AACA,oBAAI,CAAJ,EAAO;AACH,2BAAO,IAAP,EAAa;AACT,4BAAI,CAAC,YAAY,IAAZ,CAAiB,kBAAjB,CAAD,IAAyC,CAAC,YAAY,KAAZ,CAAkB,GAAlB,CAA9C,EAAsE;AAClE;AACH;AACD,4BAAI,KAAK,SAAL,EAAJ;AACA,4BAAI,CAAC,CAAL,EAAQ;AACJ;AACH;AACD,oCAAY,IAAI,KAAK,SAAT,CAAoB,IAApB,EAA0B,aAAa,CAAvC,EAA0C,CAA1C,EAA6C,KAA7C,CAAZ;AACH;AACD,2BAAO,aAAa,CAApB;AACH;AACJ,aAn3Cc;AAo3Cf,uBAAW,YAAY;AACnB,oBAAI,MAAJ,EAAY,OAAZ,EAAqB,IAArB;AACA,yBAAS,EAAT,GAAc;AACV,2BAAO,YAAY,IAAZ,CAAiB,IAAjB,CAAP;AACH;;AAED,yBAAS,KAAK,YAAL,CAAkB,IAAlB,CAAT;AACA,oBAAI,CAAC,MAAL,EAAa;AACT;AACH;AACD,0BAAU,IAAV;AACA,oBAAI,OAAJ,EAAa;AACT,2BAAO,KAAK,SAAL,EAAP;AACA,wBAAI,IAAJ,EAAU;AACN,iCAAS,IAAI,KAAK,SAAT,CAAoB,OAApB,EAA6B,MAA7B,EAAqC,IAArC,CAAT;AACH,qBAFD,MAEO;AACH;AACH;AACJ;AACD,uBAAO,MAAP;AACH,aAx4Cc;AAy4Cf,0BAAc,YAAY;AACtB,oBAAI,MAAJ,EAAY,OAAZ,EAAqB,IAArB;AACA,yBAAS,eAAT,CAAyB,EAAzB,EAA6B;AACzB,2BAAO,GAAG,gBAAH,MAAyB,GAAG,oBAAH,EAAhC;AACH;AACD,yBAAS,GAAT,GAAe;AACX,2BAAO,YAAY,IAAZ,CAAiB,KAAjB,CAAP;AACH;;AAED,yBAAS,gBAAgB,IAAhB,CAAT;AACA,oBAAI,CAAC,MAAL,EAAa;AACT;AACH;AACD,0BAAU,KAAV;AACA,oBAAI,OAAJ,EAAa;AACT,2BAAO,KAAK,YAAL,EAAP;AACA,wBAAI,IAAJ,EAAU;AACN,iCAAS,IAAI,KAAK,SAAT,CAAoB,OAApB,EAA6B,MAA7B,EAAqC,IAArC,CAAT;AACH,qBAFD,MAEO;AACH;AACH;AACJ;AACD,uBAAO,MAAP;AACH,aAh6Cc;AAi6Cf,8BAAkB,YAAY;AAC1B,oBAAI,YAAY,IAAZ,CAAiB,KAAjB,CAAJ,EAA6B;AACzB,wBAAI,SAAS,KAAK,oBAAL,EAAb;AACA,wBAAI,MAAJ,EAAY;AACR,+BAAO,MAAP,GAAgB,CAAC,OAAO,MAAxB;AACH;AACD,2BAAO,MAAP;AACH;AACJ,aAz6Cc;AA06Cf,kCAAsB,YAAY;AAC9B,yBAAS,iCAAT,CAA2C,EAA3C,EAA+C;AAC3C,wBAAI,IAAJ;AACA,gCAAY,IAAZ;AACA,2BAAO,GAAG,SAAH,EAAP;AACA,wBAAI,CAAC,IAAL,EAAW;AACP,oCAAY,OAAZ;AACA;AACH;AACD,wBAAI,CAAC,YAAY,KAAZ,CAAkB,GAAlB,CAAL,EAA6B;AACzB,oCAAY,OAAZ;AACA;AACH;AACD,gCAAY,MAAZ;AACA,2BAAO,IAAP;AACH;;AAED,oBAAI,IAAJ;AACA,4BAAY,IAAZ;AACA,oBAAI,CAAC,YAAY,IAAZ,CAAiB,GAAjB,CAAL,EAA4B;AACxB,gCAAY,OAAZ;AACA;AACH;AACD,uBAAO,kCAAkC,IAAlC,CAAP;AACA,oBAAI,IAAJ,EAAU;AACN,gCAAY,MAAZ;AACA,2BAAO,IAAP;AACH;;AAED,uBAAO,KAAK,eAAL,EAAP;AACA,oBAAI,CAAC,IAAL,EAAW;AACP,gCAAY,OAAZ;AACA;AACH;AACD,oBAAI,CAAC,YAAY,KAAZ,CAAkB,GAAlB,CAAL,EAA6B;AACzB,gCAAY,OAAZ,CAAoB,uBAAuB,YAAY,WAAZ,EAAvB,GAAmD,GAAvE;AACA;AACH;AACD,4BAAY,MAAZ;AACA,uBAAO,IAAP;AACH,aAl9Cc;AAm9Cf,6BAAiB,YAAY;AACzB,oBAAI,WAAW,KAAK,QAApB;AAAA,oBAA8B,QAAQ,YAAY,CAAlD;AAAA,oBAAqD,CAArD;AAAA,oBAAwD,CAAxD;AAAA,oBAA2D,CAA3D;AAAA,oBAA8D,EAA9D;;AAEA,oBAAI,KAAK,QAAL,MAAmB,SAAS,OAAT,EAAnB,IAAyC,SAAS,MAAT,EAA7C;AACA,oBAAI,CAAJ,EAAO;AACH,wBAAI,YAAY,KAAZ,CAAkB,GAAlB,CAAJ,EAA4B;AACxB,4BAAI,YAAY,KAAZ,CAAkB,GAAlB,CAAJ,EAA4B;AACxB,iCAAK,IAAL;AACH,yBAFD,MAEO;AACH,iCAAK,GAAL;AACH;AACJ,qBAND,MAOA,IAAI,YAAY,KAAZ,CAAkB,GAAlB,CAAJ,EAA4B;AACxB,4BAAI,YAAY,KAAZ,CAAkB,GAAlB,CAAJ,EAA4B;AACxB,iCAAK,IAAL;AACH,yBAFD,MAEO;AACH,iCAAK,GAAL;AACH;AACJ,qBAND,MAOA,IAAI,YAAY,KAAZ,CAAkB,GAAlB,CAAJ,EAA4B;AACxB,4BAAI,YAAY,KAAZ,CAAkB,GAAlB,CAAJ,EAA4B;AACxB,iCAAK,IAAL;AACH,yBAFD,MAEO,IAAI,YAAY,KAAZ,CAAkB,GAAlB,CAAJ,EAA4B;AAC/B,iCAAK,IAAL;AACH,yBAFM,MAEA;AACH,iCAAK,GAAL;AACH;AACJ;AACD,wBAAI,EAAJ,EAAQ;AACJ,4BAAI,KAAK,QAAL,MAAmB,SAAS,OAAT,EAAnB,IAAyC,SAAS,MAAT,EAA7C;AACA,4BAAI,CAAJ,EAAO;AACH,gCAAI,IAAI,KAAK,SAAT,CAAoB,EAApB,EAAwB,CAAxB,EAA2B,CAA3B,EAA8B,KAA9B,EAAqC,KAArC,CAAJ;AACH,yBAFD,MAEO;AACH,kCAAM,qBAAN;AACH;AACJ,qBAPD,MAOO;AACH,4BAAI,IAAI,KAAK,SAAT,CAAoB,GAApB,EAAyB,CAAzB,EAA4B,IAAI,KAAK,OAAT,CAAkB,MAAlB,CAA5B,EAAuD,KAAvD,EAA8D,KAA9D,CAAJ;AACH;AACD,2BAAO,CAAP;AACH;AACJ,aA3/Cc;;AA6/Cf;AACA;AACA;AACA;AACA,qBAAS,YAAY;AACjB,oBAAI,WAAW,KAAK,QAApB;AAAA,oBAA8B,MAA9B;;AAEA,oBAAI,YAAY,IAAZ,CAAiB,SAAjB,CAAJ,EAAiC;AAC7B,6BAAS,YAAY,KAAZ,CAAkB,GAAlB,CAAT;AACH;;AAED,oBAAI,IAAI,KAAK,GAAL,MAAc,SAAS,SAAT,EAAd,IACA,SAAS,KAAT,EADA,IACoB,SAAS,QAAT,EADpB,IAEA,SAAS,IAAT,EAFA,IAEmB,SAAS,YAAT,EAF3B;;AAIA,oBAAI,MAAJ,EAAY;AACR,sBAAE,UAAF,GAAe,IAAf;AACA,wBAAI,IAAI,KAAK,QAAT,CAAmB,CAAnB,CAAJ;AACH;;AAED,uBAAO,CAAP;AACH,aAlhDc;;AAohDf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAY,YAAY;AACpB,oBAAI,WAAW,EAAf;AAAA,oBAAmB,CAAnB;AAAA,oBAAsB,KAAtB;;AAEA,mBAAG;AACC,wBAAI,KAAK,OAAL,EAAJ;AACA,wBAAI,CAAJ,EAAO;AACH,iCAAS,IAAT,CAAc,CAAd;AACA;AACH;AACD,wBAAI,KAAK,QAAL,MAAmB,KAAK,MAAL,EAAvB;AACA,wBAAI,CAAJ,EAAO;AACH,iCAAS,IAAT,CAAc,CAAd;AACA;AACA,4BAAI,CAAC,YAAY,IAAZ,CAAiB,UAAjB,CAAL,EAAmC;AAC/B,oCAAQ,YAAY,KAAZ,CAAkB,GAAlB,CAAR;AACA,gCAAI,KAAJ,EAAW;AACP,yCAAS,IAAT,CAAc,IAAI,KAAK,SAAT,CAAoB,KAApB,CAAd;AACH;AACJ;AACJ;AACJ,iBAjBD,QAiBS,CAjBT;AAkBA,oBAAI,SAAS,MAAT,GAAkB,CAAtB,EAAyB;AACrB,2BAAO,IAAI,KAAK,UAAT,CAAqB,QAArB,CAAP;AACH;AACJ,aAnjDc;AAojDf,sBAAU,YAAY;AAClB,oBAAI,OAAO,YAAY,GAAZ,CAAgB,4BAAhB,CAAX;AACA,oBAAI,IAAJ,EAAU;AACN,2BAAO,KAAK,CAAL,CAAP;AACH;AACJ,aAzjDc;AA0jDf,0BAAc,YAAY;AACtB,oBAAI,OAAO,EAAX;AAAA,oBAAe,QAAQ,EAAvB;AAAA,oBAA2B,CAA3B;AAAA,oBAA8B,CAA9B;;AAEA,4BAAY,IAAZ;;AAEA,oBAAI,iBAAiB,YAAY,GAAZ,CAAgB,uBAAhB,CAArB;AACA,oBAAI,cAAJ,EAAoB;AAChB,2BAAO,CAAC,IAAI,KAAK,OAAT,CAAkB,eAAe,CAAf,CAAlB,CAAD,CAAP;AACA,gCAAY,MAAZ;AACA,2BAAO,IAAP;AACH;;AAED,yBAAS,KAAT,CAAe,EAAf,EAAmB;AACf,wBAAI,IAAI,YAAY,CAApB;AAAA,wBACI,QAAQ,YAAY,GAAZ,CAAgB,EAAhB,CADZ;AAEA,wBAAI,KAAJ,EAAW;AACP,8BAAM,IAAN,CAAW,CAAX;AACA,+BAAO,KAAK,IAAL,CAAU,MAAM,CAAN,CAAV,CAAP;AACH;AACJ;;AAED,sBAAM,QAAN;AACA,uBAAO,IAAP,EAAa;AACT,wBAAI,CAAC,MAAM,+BAAN,CAAL,EAA6C;AACzC;AACH;AACJ;;AAED,oBAAK,KAAK,MAAL,GAAc,CAAf,IAAqB,MAAM,oBAAN,CAAzB,EAAsD;AAClD,gCAAY,MAAZ;;AAEA;AACA;AACA,wBAAI,KAAK,CAAL,MAAY,EAAhB,EAAoB;AAChB,6BAAK,KAAL;AACA,8BAAM,KAAN;AACH;AACD,yBAAK,IAAI,CAAT,EAAY,IAAI,KAAK,MAArB,EAA6B,GAA7B,EAAkC;AAC9B,4BAAI,KAAK,CAAL,CAAJ;AACA,6BAAK,CAAL,IAAW,EAAE,MAAF,CAAS,CAAT,MAAgB,GAAjB,GACN,IAAI,KAAK,OAAT,CAAkB,CAAlB,CADM,GAEN,IAAI,KAAK,QAAT,CAAmB,MAAM,EAAE,KAAF,CAAQ,CAAR,EAAW,CAAC,CAAZ,CAAzB,EACI,MAAM,CAAN,CADJ,EACc,QADd,CAFJ;AAIH;AACD,2BAAO,IAAP;AACH;AACD,4BAAY,OAAZ;AACH;AAzmDc;AA1IhB,KAAP;AAsvDH,CApyDD;AAqyDA,OAAO,aAAP,GAAuB,UAAS,IAAT,EAAe;AAClC,QAAI,IAAI,EAAR;;AAEA,SAAK,IAAI,IAAT,IAAiB,IAAjB,EAAuB;AACnB,YAAI,OAAO,cAAP,CAAsB,IAAtB,CAA2B,IAA3B,EAAiC,IAAjC,CAAJ,EAA4C;AACxC,gBAAI,QAAQ,KAAK,IAAL,CAAZ;AACA,iBAAK,CAAE,KAAK,CAAL,MAAY,GAAb,GAAoB,EAApB,GAAyB,GAA1B,IAAiC,IAAjC,GAAwC,IAAxC,GAA+C,KAA/C,IACC,OAAO,KAAP,EAAc,KAAd,CAAoB,CAAC,CAArB,MAA4B,GAA7B,GAAoC,EAApC,GAAyC,GADzC,CAAL;AAEH;AACJ;;AAED,WAAO,CAAP;AACH,CAZD;;AAcA,OAAO,OAAP,GAAiB,MAAjB","file":"parser-compiled.js","sourcesContent":["var LessError = require('../less-error'),\n    tree = require(\"../tree\"),\n    visitors = require(\"../visitors\"),\n    getParserInput = require(\"./parser-input\"),\n    utils = require(\"../utils\");\n\n//\n// less.js - parser\n//\n//    A relatively straight-forward predictive parser.\n//    There is no tokenization/lexing stage, the input is parsed\n//    in one sweep.\n//\n//    To make the parser fast enough to run in the browser, several\n//    optimization had to be made:\n//\n//    - Matching and slicing on a huge input is often cause of slowdowns.\n//      The solution is to chunkify the input into smaller strings.\n//      The chunks are stored in the `chunks` var,\n//      `j` holds the current chunk index, and `currentPos` holds\n//      the index of the current chunk in relation to `input`.\n//      This gives us an almost 4x speed-up.\n//\n//    - In many cases, we don't need to match individual tokens;\n//      for example, if a value doesn't hold any variables, operations\n//      or dynamic references, the parser can effectively 'skip' it,\n//      treating it as a literal.\n//      An example would be '1px solid #000' - which evaluates to itself,\n//      we don't need to know what the individual components are.\n//      The drawback, of course is that you don't get the benefits of\n//      syntax-checking on the CSS. This gives us a 50% speed-up in the parser,\n//      and a smaller speed-up in the code-gen.\n//\n//\n//    Token matching is done with the `$` function, which either takes\n//    a terminal string or regexp, or a non-terminal function to call.\n//    It also takes care of moving all the indices forwards.\n//`\n//\nvar Parser = function Parser(context, imports, fileInfo) {\n    var parsers,\n        parserInput = getParserInput();\n\n    function error(msg, type) {\n        throw new LessError(\n            {\n                index: parserInput.i,\n                filename: fileInfo.filename,\n                type: type || 'Syntax',\n                message: msg\n            },\n            imports\n        );\n    }\n\n    function expect(arg, msg, index) {\n        // some older browsers return typeof 'function' for RegExp\n        var result = (arg instanceof Function) ? arg.call(parsers) : parserInput.$re(arg);\n        if (result) {\n            return result;\n        }\n        error(msg || (typeof arg === 'string' ? \"expected '\" + arg + \"' got '\" + parserInput.currentChar() + \"'\"\n                                               : \"unexpected token\"));\n    }\n\n    // Specialization of expect()\n    function expectChar(arg, msg) {\n        if (parserInput.$char(arg)) {\n            return arg;\n        }\n        error(msg || \"expected '\" + arg + \"' got '\" + parserInput.currentChar() + \"'\");\n    }\n\n    function getDebugInfo(index) {\n        var filename = fileInfo.filename;\n\n        return {\n            lineNumber: utils.getLocation(index, parserInput.getInput()).line + 1,\n            fileName: filename\n        };\n    }\n\n    //\n    // The Parser\n    //\n    return {\n\n        //\n        // Parse an input string into an abstract syntax tree,\n        // @param str A string containing 'less' markup\n        // @param callback call `callback` when done.\n        // @param [additionalData] An optional map which can contains vars - a map (key, value) of variables to apply\n        //\n        parse: function (str, callback, additionalData) {\n            var root, error = null, globalVars, modifyVars, ignored, preText = \"\";\n\n            globalVars = (additionalData && additionalData.globalVars) ? Parser.serializeVars(additionalData.globalVars) + '\\n' : '';\n            modifyVars = (additionalData && additionalData.modifyVars) ? '\\n' + Parser.serializeVars(additionalData.modifyVars) : '';\n\n            if (context.pluginManager) {\n                var preProcessors = context.pluginManager.getPreProcessors();\n                for (var i = 0; i < preProcessors.length; i++) {\n                    str = preProcessors[i].process(str, { context: context, imports: imports, fileInfo: fileInfo });\n                }\n            }\n\n            if (globalVars || (additionalData && additionalData.banner)) {\n                preText = ((additionalData && additionalData.banner) ? additionalData.banner : \"\") + globalVars;\n                ignored = imports.contentsIgnoredChars;\n                ignored[fileInfo.filename] = ignored[fileInfo.filename] || 0;\n                ignored[fileInfo.filename] += preText.length;\n            }\n\n            str = str.replace(/\\r\\n?/g, '\\n');\n            // Remove potential UTF Byte Order Mark\n            str = preText + str.replace(/^\\uFEFF/, '') + modifyVars;\n            imports.contents[fileInfo.filename] = str;\n\n            // Start with the primary rule.\n            // The whole syntax tree is held under a Ruleset node,\n            // with the `root` property set to true, so no `{}` are\n            // output. The callback is called when the input is parsed.\n            try {\n                parserInput.start(str, context.chunkInput, function fail(msg, index) {\n                    throw new LessError({\n                        index: index,\n                        type: 'Parse',\n                        message: msg,\n                        filename: fileInfo.filename\n                    }, imports);\n                });\n\n                root = new(tree.Ruleset)(null, this.parsers.primary());\n                root.root = true;\n                root.firstRoot = true;\n            } catch (e) {\n                return callback(new LessError(e, imports, fileInfo.filename));\n            }\n\n            // If `i` is smaller than the `input.length - 1`,\n            // it means the parser wasn't able to parse the whole\n            // string, so we've got a parsing error.\n            //\n            // We try to extract a \\n delimited string,\n            // showing the line where the parse error occurred.\n            // We split it up into two parts (the part which parsed,\n            // and the part which didn't), so we can color them differently.\n            var endInfo = parserInput.end();\n            if (!endInfo.isFinished) {\n\n                var message = endInfo.furthestPossibleErrorMessage;\n\n                if (!message) {\n                    message = \"Unrecognised input\";\n                    if (endInfo.furthestChar === '}') {\n                        message += \". Possibly missing opening '{'\";\n                    } else if (endInfo.furthestChar === ')') {\n                        message += \". Possibly missing opening '('\";\n                    } else if (endInfo.furthestReachedEnd) {\n                        message += \". Possibly missing something\";\n                    }\n                }\n\n                error = new LessError({\n                    type: \"Parse\",\n                    message: message,\n                    index: endInfo.furthest,\n                    filename: fileInfo.filename\n                }, imports);\n            }\n\n            var finish = function (e) {\n                e = error || e || imports.error;\n\n                if (e) {\n                    if (!(e instanceof LessError)) {\n                        e = new LessError(e, imports, fileInfo.filename);\n                    }\n\n                    return callback(e);\n                }\n                else {\n                    return callback(null, root);\n                }\n            };\n\n            if (context.processImports !== false) {\n                new visitors.ImportVisitor(imports, finish)\n                    .run(root);\n            } else {\n                return finish();\n            }\n        },\n\n        //\n        // Here in, the parsing rules/functions\n        //\n        // The basic structure of the syntax tree generated is as follows:\n        //\n        //   Ruleset ->  Rule -> Value -> Expression -> Entity\n        //\n        // Here's some Less code:\n        //\n        //    .class {\n        //      color: #fff;\n        //      border: 1px solid #000;\n        //      width: @w + 4px;\n        //      > .child {...}\n        //    }\n        //\n        // And here's what the parse tree might look like:\n        //\n        //     Ruleset (Selector '.class', [\n        //         Rule (\"color\",  Value ([Expression [Color #fff]]))\n        //         Rule (\"border\", Value ([Expression [Dimension 1px][Keyword \"solid\"][Color #000]]))\n        //         Rule (\"width\",  Value ([Expression [Operation \" + \" [Variable \"@w\"][Dimension 4px]]]))\n        //         Ruleset (Selector [Element '>', '.child'], [...])\n        //     ])\n        //\n        //  In general, most rules will try to parse a token with the `$re()` function, and if the return\n        //  value is truly, will return a new node, of the relevant type. Sometimes, we need to check\n        //  first, before parsing, that's when we use `peek()`.\n        //\n        parsers: parsers = {\n            //\n            // The `primary` rule is the *entry* and *exit* point of the parser.\n            // The rules here can appear at any level of the parse tree.\n            //\n            // The recursive nature of the grammar is an interplay between the `block`\n            // rule, which represents `{ ... }`, the `ruleset` rule, and this `primary` rule,\n            // as represented by this simplified grammar:\n            //\n            //     primary  →  (ruleset | rule)+\n            //     ruleset  →  selector+ block\n            //     block    →  '{' primary '}'\n            //\n            // Only at one point is the primary rule not called from the\n            // block rule: at the root level.\n            //\n            primary: function () {\n                var mixin = this.mixin, root = [], node;\n\n                while (true) {\n                    while (true) {\n                        node = this.comment();\n                        if (!node) { break; }\n                        root.push(node);\n                    }\n                    // always process comments before deciding if finished\n                    if (parserInput.finished) {\n                        break;\n                    }\n                    if (parserInput.peek('}')) {\n                        break;\n                    }\n\n                    node = this.extendRule();\n                    if (node) {\n                        root = root.concat(node);\n                        continue;\n                    }\n\n                    node = mixin.definition() || this.rule() || this.ruleset() ||\n                        mixin.call() || this.rulesetCall() || this.entities.call() || this.directive();\n                    if (node) {\n                        root.push(node);\n                    } else {\n                        var foundSemiColon = false;\n                        while (parserInput.$char(\";\")) {\n                            foundSemiColon = true;\n                        }\n                        if (!foundSemiColon) {\n                            break;\n                        }\n                    }\n                }\n\n                return root;\n            },\n\n            // comments are collected by the main parsing mechanism and then assigned to nodes\n            // where the current structure allows it\n            comment: function () {\n                if (parserInput.commentStore.length) {\n                    var comment = parserInput.commentStore.shift();\n                    return new(tree.Comment)(comment.text, comment.isLineComment, comment.index, fileInfo);\n                }\n            },\n\n            //\n            // Entities are tokens which can be found inside an Expression\n            //\n            entities: {\n                //\n                // A string, which supports escaping \" and '\n                //\n                //     \"milky way\" 'he\\'s the one!'\n                //\n                quoted: function () {\n                    var str, index = parserInput.i, isEscaped = false;\n\n                    parserInput.save();\n                    if (parserInput.$char(\"~\")) {\n                        isEscaped = true;\n                    }\n                    str = parserInput.$quoted();\n                    if (!str) {\n                        parserInput.restore();\n                        return;\n                    }\n                    parserInput.forget();\n\n                    return new(tree.Quoted)(str.charAt(0), str.substr(1, str.length - 2), isEscaped, index, fileInfo);\n                },\n\n                //\n                // A catch-all word, such as:\n                //\n                //     black border-collapse\n                //\n                keyword: function () {\n                    var k = parserInput.$char(\"%\") || parserInput.$re(/^[_A-Za-z-][_A-Za-z0-9-]*/);\n                    if (k) {\n                        return tree.Color.fromKeyword(k) || new(tree.Keyword)(k);\n                    }\n                },\n\n                //\n                // A function call\n                //\n                //     rgb(255, 0, 255)\n                //\n                // We also try to catch IE's `alpha()`, but let the `alpha` parser\n                // deal with the details.\n                //\n                // The arguments are parsed with the `entities.arguments` parser.\n                //\n                call: function () {\n                    var name, nameLC, args, alpha, index = parserInput.i;\n\n                    // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18\n                    if (parserInput.peek(/^url\\(/i)) {\n                        return;\n                    }\n\n                    parserInput.save();\n\n                    name = parserInput.$re(/^([\\w-]+|%|progid:[\\w\\.]+)\\(/);\n                    if (!name) { parserInput.forget(); return; }\n\n                    name = name[1];\n                    nameLC = name.toLowerCase();\n\n                    if (nameLC === 'alpha') {\n                        alpha = parsers.alpha();\n                        if (alpha) {\n                            parserInput.forget();\n                            return alpha;\n                        }\n                    }\n\n                    args = this.arguments();\n\n                    if (! parserInput.$char(')')) {\n                        parserInput.restore(\"Could not parse call arguments or missing ')'\");\n                        return;\n                    }\n\n                    parserInput.forget();\n                    return new(tree.Call)(name, args, index, fileInfo);\n                },\n                arguments: function () {\n                    var argsSemiColon = [], argsComma = [],\n                        expressions = [],\n                        isSemiColonSeparated, value, arg;\n\n                    parserInput.save();\n\n                    while (true) {\n\n                        arg = parsers.detachedRuleset() || this.assignment() || parsers.expression();\n\n                        if (!arg) {\n                            break;\n                        }\n\n                        value = arg;\n\n                        if (arg.value && arg.value.length == 1) {\n                            value = arg.value[0];\n                        }\n\n                        if (value) {\n                            expressions.push(value);\n                        }\n\n                        argsComma.push(value);\n\n                        if (parserInput.$char(',')) {\n                            continue;\n                        }\n\n                        if (parserInput.$char(';') || isSemiColonSeparated) {\n\n                            isSemiColonSeparated = true;\n\n                            if (expressions.length > 1) {\n                                value = new(tree.Value)(expressions);\n                            }\n                            argsSemiColon.push(value);\n\n                            expressions = [];\n                        }\n                    }\n\n                    parserInput.forget();\n                    return isSemiColonSeparated ? argsSemiColon : argsComma;\n                },\n                literal: function () {\n                    return this.dimension() ||\n                           this.color() ||\n                           this.quoted() ||\n                           this.unicodeDescriptor();\n                },\n\n                // Assignments are argument entities for calls.\n                // They are present in ie filter properties as shown below.\n                //\n                //     filter: progid:DXImageTransform.Microsoft.Alpha( *opacity=50* )\n                //\n\n                assignment: function () {\n                    var key, value;\n                    parserInput.save();\n                    key = parserInput.$re(/^\\w+(?=\\s?=)/i);\n                    if (!key) {\n                        parserInput.restore();\n                        return;\n                    }\n                    if (!parserInput.$char('=')) {\n                        parserInput.restore();\n                        return;\n                    }\n                    value = parsers.entity();\n                    if (value) {\n                        parserInput.forget();\n                        return new(tree.Assignment)(key, value);\n                    } else {\n                        parserInput.restore();\n                    }\n                },\n\n                //\n                // Parse url() tokens\n                //\n                // We use a specific rule for urls, because they don't really behave like\n                // standard function calls. The difference is that the argument doesn't have\n                // to be enclosed within a string, so it can't be parsed as an Expression.\n                //\n                url: function () {\n                    var value, index = parserInput.i;\n\n                    parserInput.autoCommentAbsorb = false;\n\n                    if (!parserInput.$str(\"url(\")) {\n                        parserInput.autoCommentAbsorb = true;\n                        return;\n                    }\n\n                    value = this.quoted() || this.variable() ||\n                            parserInput.$re(/^(?:(?:\\\\[\\(\\)'\"])|[^\\(\\)'\"])+/) || \"\";\n\n                    parserInput.autoCommentAbsorb = true;\n\n                    expectChar(')');\n\n                    return new(tree.URL)((value.value != null || value instanceof tree.Variable) ?\n                                        value : new(tree.Anonymous)(value), index, fileInfo);\n                },\n\n                //\n                // A Variable entity, such as `@fink`, in\n                //\n                //     width: @fink + 2px\n                //\n                // We use a different parser for variable definitions,\n                // see `parsers.variable`.\n                //\n                variable: function () {\n                    var name, index = parserInput.i;\n\n                    if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^@@?[\\w-]+/))) {\n                        return new(tree.Variable)(name, index, fileInfo);\n                    }\n                },\n\n                // A variable entity using the protective {} e.g. @{var}\n                variableCurly: function () {\n                    var curly, index = parserInput.i;\n\n                    if (parserInput.currentChar() === '@' && (curly = parserInput.$re(/^@\\{([\\w-]+)\\}/))) {\n                        return new(tree.Variable)(\"@\" + curly[1], index, fileInfo);\n                    }\n                },\n\n                //\n                // A Hexadecimal color\n                //\n                //     #4F3C2F\n                //\n                // `rgb` and `hsl` colors are parsed through the `entities.call` parser.\n                //\n                color: function () {\n                    var rgb;\n\n                    if (parserInput.currentChar() === '#' && (rgb = parserInput.$re(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})/))) {\n                        // strip colons, brackets, whitespaces and other characters that should not\n                        // definitely be part of color string\n                        var colorCandidateString = rgb.input.match(/^#([\\w]+).*/);\n                        colorCandidateString = colorCandidateString[1];\n                        if (!colorCandidateString.match(/^[A-Fa-f0-9]+$/)) { // verify if candidate consists only of allowed HEX characters\n                            error(\"Invalid HEX color code\");\n                        }\n                        return new(tree.Color)(rgb[1], undefined, '#' + colorCandidateString);\n                    }\n                },\n\n                colorKeyword: function () {\n                    parserInput.save();\n                    var autoCommentAbsorb = parserInput.autoCommentAbsorb;\n                    parserInput.autoCommentAbsorb = false;\n                    var k = parserInput.$re(/^[_A-Za-z-][_A-Za-z0-9-]+/);\n                    parserInput.autoCommentAbsorb = autoCommentAbsorb;\n                    if (!k) {\n                        parserInput.forget();\n                        return;\n                    }\n                    parserInput.restore();\n                    var color = tree.Color.fromKeyword(k);\n                    if (color) {\n                        parserInput.$str(k);\n                        return color;\n                    }\n                },\n\n                //\n                // A Dimension, that is, a number and a unit\n                //\n                //     0.5em 95%\n                //\n                dimension: function () {\n                    if (parserInput.peekNotNumeric()) {\n                        return;\n                    }\n\n                    var value = parserInput.$re(/^([+-]?\\d*\\.?\\d+)(%|[a-z_]+)?/i);\n                    if (value) {\n                        return new(tree.Dimension)(value[1], value[2]);\n                    }\n                },\n\n                //\n                // A unicode descriptor, as is used in unicode-range\n                //\n                // U+0??  or U+00A1-00A9\n                //\n                unicodeDescriptor: function () {\n                    var ud;\n\n                    ud = parserInput.$re(/^U\\+[0-9a-fA-F?]+(\\-[0-9a-fA-F?]+)?/);\n                    if (ud) {\n                        return new(tree.UnicodeDescriptor)(ud[0]);\n                    }\n                },\n\n                //\n                // JavaScript code to be evaluated\n                //\n                //     `window.location.href`\n                //\n                javascript: function () {\n                    var js, index = parserInput.i;\n\n                    parserInput.save();\n\n                    var escape = parserInput.$char(\"~\");\n                    var jsQuote = parserInput.$char(\"`\");\n\n                    if (!jsQuote) {\n                        parserInput.restore();\n                        return;\n                    }\n\n                    js = parserInput.$re(/^[^`]*`/);\n                    if (js) {\n                        parserInput.forget();\n                        return new(tree.JavaScript)(js.substr(0, js.length - 1), Boolean(escape), index, fileInfo);\n                    }\n                    parserInput.restore(\"invalid javascript definition\");\n                }\n            },\n\n            //\n            // The variable part of a variable definition. Used in the `rule` parser\n            //\n            //     @fink:\n            //\n            variable: function () {\n                var name;\n\n                if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^(@[\\w-]+)\\s*:/))) { return name[1]; }\n            },\n\n            //\n            // The variable part of a variable definition. Used in the `rule` parser\n            //\n            //     @fink();\n            //\n            rulesetCall: function () {\n                var name;\n\n                if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^(@[\\w-]+)\\(\\s*\\)\\s*;/))) {\n                    return new tree.RulesetCall(name[1]);\n                }\n            },\n\n            //\n            // extend syntax - used to extend selectors\n            //\n            extend: function(isRule) {\n                var elements, e, index = parserInput.i, option, extendList, extend;\n\n                if (!parserInput.$str(isRule ? \"&:extend(\" : \":extend(\")) {\n                    return;\n                }\n\n                do {\n                    option = null;\n                    elements = null;\n                    while (! (option = parserInput.$re(/^(all)(?=\\s*(\\)|,))/))) {\n                        e = this.element();\n                        if (!e) {\n                            break;\n                        }\n                        if (elements) {\n                            elements.push(e);\n                        } else {\n                            elements = [ e ];\n                        }\n                    }\n\n                    option = option && option[1];\n                    if (!elements) {\n                        error(\"Missing target selector for :extend().\");\n                    }\n                    extend = new(tree.Extend)(new(tree.Selector)(elements), option, index, fileInfo);\n                    if (extendList) {\n                        extendList.push(extend);\n                    } else {\n                        extendList = [ extend ];\n                    }\n                } while (parserInput.$char(\",\"));\n\n                expect(/^\\)/);\n\n                if (isRule) {\n                    expect(/^;/);\n                }\n\n                return extendList;\n            },\n\n            //\n            // extendRule - used in a rule to extend all the parent selectors\n            //\n            extendRule: function() {\n                return this.extend(true);\n            },\n\n            //\n            // Mixins\n            //\n            mixin: {\n                //\n                // A Mixin call, with an optional argument list\n                //\n                //     #mixins > .square(#fff);\n                //     .rounded(4px, black);\n                //     .button;\n                //\n                // The `while` loop is there because mixins can be\n                // namespaced, but we only support the child and descendant\n                // selector for now.\n                //\n                call: function () {\n                    var s = parserInput.currentChar(), important = false, index = parserInput.i, elemIndex,\n                        elements, elem, e, c, args;\n\n                    if (s !== '.' && s !== '#') { return; }\n\n                    parserInput.save(); // stop us absorbing part of an invalid selector\n\n                    while (true) {\n                        elemIndex = parserInput.i;\n                        e = parserInput.$re(/^[#.](?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/);\n                        if (!e) {\n                            break;\n                        }\n                        elem = new(tree.Element)(c, e, elemIndex, fileInfo);\n                        if (elements) {\n                            elements.push(elem);\n                        } else {\n                            elements = [ elem ];\n                        }\n                        c = parserInput.$char('>');\n                    }\n\n                    if (elements) {\n                        if (parserInput.$char('(')) {\n                            args = this.args(true).args;\n                            expectChar(')');\n                        }\n\n                        if (parsers.important()) {\n                            important = true;\n                        }\n\n                        if (parsers.end()) {\n                            parserInput.forget();\n                            return new(tree.mixin.Call)(elements, args, index, fileInfo, important);\n                        }\n                    }\n\n                    parserInput.restore();\n                },\n                args: function (isCall) {\n                    var entities = parsers.entities,\n                        returner = { args:null, variadic: false },\n                        expressions = [], argsSemiColon = [], argsComma = [],\n                        isSemiColonSeparated, expressionContainsNamed, name, nameLoop,\n                        value, arg, expand;\n\n                    parserInput.save();\n\n                    while (true) {\n                        if (isCall) {\n                            arg = parsers.detachedRuleset() || parsers.expression();\n                        } else {\n                            parserInput.commentStore.length = 0;\n                            if (parserInput.$str(\"...\")) {\n                                returner.variadic = true;\n                                if (parserInput.$char(\";\") && !isSemiColonSeparated) {\n                                    isSemiColonSeparated = true;\n                                }\n                                (isSemiColonSeparated ? argsSemiColon : argsComma)\n                                    .push({ variadic: true });\n                                break;\n                            }\n                            arg = entities.variable() || entities.literal() || entities.keyword();\n                        }\n\n                        if (!arg) {\n                            break;\n                        }\n\n                        nameLoop = null;\n                        if (arg.throwAwayComments) {\n                            arg.throwAwayComments();\n                        }\n                        value = arg;\n                        var val = null;\n\n                        if (isCall) {\n                            // Variable\n                            if (arg.value && arg.value.length == 1) {\n                                val = arg.value[0];\n                            }\n                        } else {\n                            val = arg;\n                        }\n\n                        if (val && val instanceof tree.Variable) {\n                            if (parserInput.$char(':')) {\n                                if (expressions.length > 0) {\n                                    if (isSemiColonSeparated) {\n                                        error(\"Cannot mix ; and , as delimiter types\");\n                                    }\n                                    expressionContainsNamed = true;\n                                }\n\n                                value = parsers.detachedRuleset() || parsers.expression();\n\n                                if (!value) {\n                                    if (isCall) {\n                                        error(\"could not understand value for named argument\");\n                                    } else {\n                                        parserInput.restore();\n                                        returner.args = [];\n                                        return returner;\n                                    }\n                                }\n                                nameLoop = (name = val.name);\n                            } else if (parserInput.$str(\"...\")) {\n                                if (!isCall) {\n                                    returner.variadic = true;\n                                    if (parserInput.$char(\";\") && !isSemiColonSeparated) {\n                                        isSemiColonSeparated = true;\n                                    }\n                                    (isSemiColonSeparated ? argsSemiColon : argsComma)\n                                        .push({ name: arg.name, variadic: true });\n                                    break;\n                                } else {\n                                    expand = true;\n                                }\n                            } else if (!isCall) {\n                                name = nameLoop = val.name;\n                                value = null;\n                            }\n                        }\n\n                        if (value) {\n                            expressions.push(value);\n                        }\n\n                        argsComma.push({ name:nameLoop, value:value, expand:expand });\n\n                        if (parserInput.$char(',')) {\n                            continue;\n                        }\n\n                        if (parserInput.$char(';') || isSemiColonSeparated) {\n\n                            if (expressionContainsNamed) {\n                                error(\"Cannot mix ; and , as delimiter types\");\n                            }\n\n                            isSemiColonSeparated = true;\n\n                            if (expressions.length > 1) {\n                                value = new(tree.Value)(expressions);\n                            }\n                            argsSemiColon.push({ name:name, value:value, expand:expand });\n\n                            name = null;\n                            expressions = [];\n                            expressionContainsNamed = false;\n                        }\n                    }\n\n                    parserInput.forget();\n                    returner.args = isSemiColonSeparated ? argsSemiColon : argsComma;\n                    return returner;\n                },\n                //\n                // A Mixin definition, with a list of parameters\n                //\n                //     .rounded (@radius: 2px, @color) {\n                //        ...\n                //     }\n                //\n                // Until we have a finer grained state-machine, we have to\n                // do a look-ahead, to make sure we don't have a mixin call.\n                // See the `rule` function for more information.\n                //\n                // We start by matching `.rounded (`, and then proceed on to\n                // the argument list, which has optional default values.\n                // We store the parameters in `params`, with a `value` key,\n                // if there is a value, such as in the case of `@radius`.\n                //\n                // Once we've got our params list, and a closing `)`, we parse\n                // the `{...}` block.\n                //\n                definition: function () {\n                    var name, params = [], match, ruleset, cond, variadic = false;\n                    if ((parserInput.currentChar() !== '.' && parserInput.currentChar() !== '#') ||\n                        parserInput.peek(/^[^{]*\\}/)) {\n                        return;\n                    }\n\n                    parserInput.save();\n\n                    match = parserInput.$re(/^([#.](?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+)\\s*\\(/);\n                    if (match) {\n                        name = match[1];\n\n                        var argInfo = this.args(false);\n                        params = argInfo.args;\n                        variadic = argInfo.variadic;\n\n                        // .mixincall(\"@{a}\");\n                        // looks a bit like a mixin definition..\n                        // also\n                        // .mixincall(@a: {rule: set;});\n                        // so we have to be nice and restore\n                        if (!parserInput.$char(')')) {\n                            parserInput.restore(\"Missing closing ')'\");\n                            return;\n                        }\n\n                        parserInput.commentStore.length = 0;\n\n                        if (parserInput.$str(\"when\")) { // Guard\n                            cond = expect(parsers.conditions, 'expected condition');\n                        }\n\n                        ruleset = parsers.block();\n\n                        if (ruleset) {\n                            parserInput.forget();\n                            return new(tree.mixin.Definition)(name, params, ruleset, cond, variadic);\n                        } else {\n                            parserInput.restore();\n                        }\n                    } else {\n                        parserInput.forget();\n                    }\n                }\n            },\n\n            //\n            // Entities are the smallest recognized token,\n            // and can be found inside a rule's value.\n            //\n            entity: function () {\n                var entities = this.entities;\n\n                return this.comment() || entities.literal() || entities.variable() || entities.url() ||\n                       entities.call()    || entities.keyword()  || entities.javascript();\n            },\n\n            //\n            // A Rule terminator. Note that we use `peek()` to check for '}',\n            // because the `block` rule will be expecting it, but we still need to make sure\n            // it's there, if ';' was omitted.\n            //\n            end: function () {\n                return parserInput.$char(';') || parserInput.peek('}');\n            },\n\n            //\n            // IE's alpha function\n            //\n            //     alpha(opacity=88)\n            //\n            alpha: function () {\n                var value;\n\n                // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18\n                if (! parserInput.$re(/^opacity=/i)) { return; }\n                value = parserInput.$re(/^\\d+/);\n                if (!value) {\n                    value = expect(this.entities.variable, \"Could not parse alpha\");\n                }\n                expectChar(')');\n                return new(tree.Alpha)(value);\n            },\n\n            //\n            // A Selector Element\n            //\n            //     div\n            //     + h1\n            //     #socks\n            //     input[type=\"text\"]\n            //\n            // Elements are the building blocks for Selectors,\n            // they are made out of a `Combinator` (see combinator rule),\n            // and an element name, such as a tag a class, or `*`.\n            //\n            element: function () {\n                var e, c, v, index = parserInput.i;\n\n                c = this.combinator();\n\n                e = parserInput.$re(/^(?:\\d+\\.\\d+|\\d+)%/) ||\n                    parserInput.$re(/^(?:[.#]?|:*)(?:[\\w-]|[^\\x00-\\x9f]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/) ||\n                    parserInput.$char('*') || parserInput.$char('&') || this.attribute() ||\n                    parserInput.$re(/^\\([^&()@]+\\)/) ||  parserInput.$re(/^[\\.#:](?=@)/) ||\n                    this.entities.variableCurly();\n\n                if (! e) {\n                    parserInput.save();\n                    if (parserInput.$char('(')) {\n                        if ((v = this.selector()) && parserInput.$char(')')) {\n                            e = new(tree.Paren)(v);\n                            parserInput.forget();\n                        } else {\n                            parserInput.restore(\"Missing closing ')'\");\n                        }\n                    } else {\n                        parserInput.forget();\n                    }\n                }\n\n                if (e) { return new(tree.Element)(c, e, index, fileInfo); }\n            },\n\n            //\n            // Combinators combine elements together, in a Selector.\n            //\n            // Because our parser isn't white-space sensitive, special care\n            // has to be taken, when parsing the descendant combinator, ` `,\n            // as it's an empty space. We have to check the previous character\n            // in the input, to see if it's a ` ` character. More info on how\n            // we deal with this in *combinator.js*.\n            //\n            combinator: function () {\n                var c = parserInput.currentChar();\n\n                if (c === '/') {\n                    parserInput.save();\n                    var slashedCombinator = parserInput.$re(/^\\/[a-z]+\\//i);\n                    if (slashedCombinator) {\n                        parserInput.forget();\n                        return new(tree.Combinator)(slashedCombinator);\n                    }\n                    parserInput.restore();\n                }\n\n                if (c === '>' || c === '+' || c === '~' || c === '|' || c === '^') {\n                    parserInput.i++;\n                    if (c === '^' && parserInput.currentChar() === '^') {\n                        c = '^^';\n                        parserInput.i++;\n                    }\n                    while (parserInput.isWhitespace()) { parserInput.i++; }\n                    return new(tree.Combinator)(c);\n                } else if (parserInput.isWhitespace(-1)) {\n                    return new(tree.Combinator)(\" \");\n                } else {\n                    return new(tree.Combinator)(null);\n                }\n            },\n            //\n            // A CSS selector (see selector below)\n            // with less extensions e.g. the ability to extend and guard\n            //\n            lessSelector: function () {\n                return this.selector(true);\n            },\n            //\n            // A CSS Selector\n            //\n            //     .class > div + h1\n            //     li a:hover\n            //\n            // Selectors are made out of one or more Elements, see above.\n            //\n            selector: function (isLess) {\n                var index = parserInput.i, elements, extendList, c, e, allExtends, when, condition;\n\n                while ((isLess && (extendList = this.extend())) || (isLess && (when = parserInput.$str(\"when\"))) || (e = this.element())) {\n                    if (when) {\n                        condition = expect(this.conditions, 'expected condition');\n                    } else if (condition) {\n                        error(\"CSS guard can only be used at the end of selector\");\n                    } else if (extendList) {\n                        if (allExtends) {\n                            allExtends = allExtends.concat(extendList);\n                        } else {\n                            allExtends = extendList;\n                        }\n                    } else {\n                        if (allExtends) { error(\"Extend can only be used at the end of selector\"); }\n                        c = parserInput.currentChar();\n                        if (elements) {\n                            elements.push(e);\n                        } else {\n                            elements = [ e ];\n                        }\n                        e = null;\n                    }\n                    if (c === '{' || c === '}' || c === ';' || c === ',' || c === ')') {\n                        break;\n                    }\n                }\n\n                if (elements) { return new(tree.Selector)(elements, allExtends, condition, index, fileInfo); }\n                if (allExtends) { error(\"Extend must be used to extend a selector, it cannot be used on its own\"); }\n            },\n            attribute: function () {\n                if (! parserInput.$char('[')) { return; }\n\n                var entities = this.entities,\n                    key, val, op;\n\n                if (!(key = entities.variableCurly())) {\n                    key = expect(/^(?:[_A-Za-z0-9-\\*]*\\|)?(?:[_A-Za-z0-9-]|\\\\.)+/);\n                }\n\n                op = parserInput.$re(/^[|~*$^]?=/);\n                if (op) {\n                    val = entities.quoted() || parserInput.$re(/^[0-9]+%/) || parserInput.$re(/^[\\w-]+/) || entities.variableCurly();\n                }\n\n                expectChar(']');\n\n                return new(tree.Attribute)(key, op, val);\n            },\n\n            //\n            // The `block` rule is used by `ruleset` and `mixin.definition`.\n            // It's a wrapper around the `primary` rule, with added `{}`.\n            //\n            block: function () {\n                var content;\n                if (parserInput.$char('{') && (content = this.primary()) && parserInput.$char('}')) {\n                    return content;\n                }\n            },\n\n            blockRuleset: function() {\n                var block = this.block();\n\n                if (block) {\n                    block = new tree.Ruleset(null, block);\n                }\n                return block;\n            },\n\n            detachedRuleset: function() {\n                var blockRuleset = this.blockRuleset();\n                if (blockRuleset) {\n                    return new tree.DetachedRuleset(blockRuleset);\n                }\n            },\n\n            //\n            // div, .class, body > p {...}\n            //\n            ruleset: function () {\n                var selectors, s, rules, debugInfo;\n\n                parserInput.save();\n\n                if (context.dumpLineNumbers) {\n                    debugInfo = getDebugInfo(parserInput.i);\n                }\n\n                while (true) {\n                    s = this.lessSelector();\n                    if (!s) {\n                        break;\n                    }\n                    if (selectors) {\n                        selectors.push(s);\n                    } else {\n                        selectors = [ s ];\n                    }\n                    parserInput.commentStore.length = 0;\n                    if (s.condition && selectors.length > 1) {\n                        error(\"Guards are only currently allowed on a single selector.\");\n                    }\n                    if (! parserInput.$char(',')) { break; }\n                    if (s.condition) {\n                        error(\"Guards are only currently allowed on a single selector.\");\n                    }\n                    parserInput.commentStore.length = 0;\n                }\n\n                if (selectors && (rules = this.block())) {\n                    parserInput.forget();\n                    var ruleset = new(tree.Ruleset)(selectors, rules, context.strictImports);\n                    if (context.dumpLineNumbers) {\n                        ruleset.debugInfo = debugInfo;\n                    }\n                    return ruleset;\n                } else {\n                    parserInput.restore();\n                }\n            },\n            rule: function (tryAnonymous) {\n                var name, value, startOfRule = parserInput.i, c = parserInput.currentChar(), important, merge, isVariable;\n\n                if (c === '.' || c === '#' || c === '&' || c === ':') { return; }\n\n                parserInput.save();\n\n                name = this.variable() || this.ruleProperty();\n                if (name) {\n                    isVariable = typeof name === \"string\";\n\n                    if (isVariable) {\n                        value = this.detachedRuleset();\n                    }\n\n                    parserInput.commentStore.length = 0;\n                    if (!value) {\n                        // a name returned by this.ruleProperty() is always an array of the form:\n                        // [string-1, ..., string-n, \"\"] or [string-1, ..., string-n, \"+\"]\n                        // where each item is a tree.Keyword or tree.Variable\n                        merge = !isVariable && name.length > 1 && name.pop().value;\n\n                        // prefer to try to parse first if its a variable or we are compressing\n                        // but always fallback on the other one\n                        var tryValueFirst = !tryAnonymous && (context.compress || isVariable);\n\n                        if (tryValueFirst) {\n                            value = this.value();\n                        }\n                        if (!value) {\n                            value = this.anonymousValue();\n                            if (value) {\n                                parserInput.forget();\n                                // anonymous values absorb the end ';' which is required for them to work\n                                return new (tree.Rule)(name, value, false, merge, startOfRule, fileInfo);\n                            }\n                        }\n                        if (!tryValueFirst && !value) {\n                            value = this.value();\n                        }\n\n                        important = this.important();\n                    }\n\n                    if (value && this.end()) {\n                        parserInput.forget();\n                        return new (tree.Rule)(name, value, important, merge, startOfRule, fileInfo);\n                    } else {\n                        parserInput.restore();\n                        if (value && !tryAnonymous) {\n                            return this.rule(true);\n                        }\n                    }\n                } else {\n                    parserInput.forget();\n                }\n            },\n            anonymousValue: function () {\n                var match = parserInput.$re(/^([^@+\\/'\"*`(;{}-]*);/);\n                if (match) {\n                    return new(tree.Anonymous)(match[1]);\n                }\n            },\n\n            //\n            // An @import directive\n            //\n            //     @import \"lib\";\n            //\n            // Depending on our environment, importing is done differently:\n            // In the browser, it's an XHR request, in Node, it would be a\n            // file-system operation. The function used for importing is\n            // stored in `import`, which we pass to the Import constructor.\n            //\n            \"import\": function () {\n                var path, features, index = parserInput.i;\n\n                var dir = parserInput.$re(/^@import?\\s+/);\n\n                if (dir) {\n                    var options = (dir ? this.importOptions() : null) || {};\n\n                    if ((path = this.entities.quoted() || this.entities.url())) {\n                        features = this.mediaFeatures();\n\n                        if (!parserInput.$char(';')) {\n                            parserInput.i = index;\n                            error(\"missing semi-colon or unrecognised media features on import\");\n                        }\n                        features = features && new(tree.Value)(features);\n                        return new(tree.Import)(path, features, options, index, fileInfo);\n                    }\n                    else {\n                        parserInput.i = index;\n                        error(\"malformed import statement\");\n                    }\n                }\n            },\n\n            importOptions: function() {\n                var o, options = {}, optionName, value;\n\n                // list of options, surrounded by parens\n                if (! parserInput.$char('(')) { return null; }\n                do {\n                    o = this.importOption();\n                    if (o) {\n                        optionName = o;\n                        value = true;\n                        switch(optionName) {\n                            case \"css\":\n                                optionName = \"less\";\n                                value = false;\n                                break;\n                            case \"once\":\n                                optionName = \"multiple\";\n                                value = false;\n                                break;\n                        }\n                        options[optionName] = value;\n                        if (! parserInput.$char(',')) { break; }\n                    }\n                } while (o);\n                expectChar(')');\n                return options;\n            },\n\n            importOption: function() {\n                var opt = parserInput.$re(/^(less|css|multiple|once|inline|reference|optional)/);\n                if (opt) {\n                    return opt[1];\n                }\n            },\n\n            mediaFeature: function () {\n                var entities = this.entities, nodes = [], e, p;\n                parserInput.save();\n                do {\n                    e = entities.keyword() || entities.variable();\n                    if (e) {\n                        nodes.push(e);\n                    } else if (parserInput.$char('(')) {\n                        p = this.property();\n                        e = this.value();\n                        if (parserInput.$char(')')) {\n                            if (p && e) {\n                                nodes.push(new(tree.Paren)(new(tree.Rule)(p, e, null, null, parserInput.i, fileInfo, true)));\n                            } else if (e) {\n                                nodes.push(new(tree.Paren)(e));\n                            } else {\n                                error(\"badly formed media feature definition\");\n                            }\n                        } else {\n                            error(\"Missing closing ')'\", \"Parse\");\n                        }\n                    }\n                } while (e);\n\n                parserInput.forget();\n                if (nodes.length > 0) {\n                    return new(tree.Expression)(nodes);\n                }\n            },\n\n            mediaFeatures: function () {\n                var entities = this.entities, features = [], e;\n                do {\n                    e = this.mediaFeature();\n                    if (e) {\n                        features.push(e);\n                        if (! parserInput.$char(',')) { break; }\n                    } else {\n                        e = entities.variable();\n                        if (e) {\n                            features.push(e);\n                            if (! parserInput.$char(',')) { break; }\n                        }\n                    }\n                } while (e);\n\n                return features.length > 0 ? features : null;\n            },\n\n            media: function () {\n                var features, rules, media, debugInfo, index = parserInput.i;\n\n                if (context.dumpLineNumbers) {\n                    debugInfo = getDebugInfo(index);\n                }\n\n                parserInput.save();\n\n                if (parserInput.$str(\"@media\")) {\n                    features = this.mediaFeatures();\n\n                    rules = this.block();\n\n                    if (!rules) {\n                        error(\"media definitions require block statements after any features\");\n                    }\n\n                    parserInput.forget();\n\n                    media = new(tree.Media)(rules, features, index, fileInfo);\n                    if (context.dumpLineNumbers) {\n                        media.debugInfo = debugInfo;\n                    }\n\n                    return media;\n                }\n\n                parserInput.restore();\n            },\n\n            //\n            // A @plugin directive, used to import compiler extensions dynamically.\n            //\n            //     @plugin \"lib\";\n            //\n            // Depending on our environment, importing is done differently:\n            // In the browser, it's an XHR request, in Node, it would be a\n            // file-system operation. The function used for importing is\n            // stored in `import`, which we pass to the Import constructor.\n            //\n            plugin: function () {\n                var path,\n                    index = parserInput.i,\n                    dir   = parserInput.$re(/^@plugin?\\s+/);\n\n                if (dir) {\n                    var options = { plugin : true };\n\n                    if ((path = this.entities.quoted() || this.entities.url())) {\n\n                        if (!parserInput.$char(';')) {\n                            parserInput.i = index;\n                            error(\"missing semi-colon on plugin\");\n                        }\n\n                        return new(tree.Import)(path, null, options, index, fileInfo);\n                    }\n                    else {\n                        parserInput.i = index;\n                        error(\"malformed plugin statement\");\n                    }\n                }\n            },\n\n            //\n            // A CSS Directive\n            //\n            //     @charset \"utf-8\";\n            //\n            directive: function () {\n                var index = parserInput.i, name, value, rules, nonVendorSpecificName,\n                    hasIdentifier, hasExpression, hasUnknown, hasBlock = true, isRooted = true;\n\n                if (parserInput.currentChar() !== '@') { return; }\n\n                value = this['import']() || this.plugin() || this.media();\n                if (value) {\n                    return value;\n                }\n\n                parserInput.save();\n\n                name = parserInput.$re(/^@[a-z-]+/);\n\n                if (!name) { return; }\n\n                nonVendorSpecificName = name;\n                if (name.charAt(1) == '-' && name.indexOf('-', 2) > 0) {\n                    nonVendorSpecificName = \"@\" + name.slice(name.indexOf('-', 2) + 1);\n                }\n\n                switch(nonVendorSpecificName) {\n                    case \"@charset\":\n                        hasIdentifier = true;\n                        hasBlock = false;\n                        break;\n                    case \"@namespace\":\n                        hasExpression = true;\n                        hasBlock = false;\n                        break;\n                    case \"@keyframes\":\n                    case \"@counter-style\":\n                        hasIdentifier = true;\n                        break;\n                    case \"@document\":\n                    case \"@supports\":\n                        hasUnknown = true;\n                        isRooted = false;\n                        break;\n                    default:\n                        hasUnknown = true;\n                        break;\n                }\n\n                parserInput.commentStore.length = 0;\n\n                if (hasIdentifier) {\n                    value = this.entity();\n                    if (!value) {\n                        error(\"expected \" + name + \" identifier\");\n                    }\n                } else if (hasExpression) {\n                    value = this.expression();\n                    if (!value) {\n                        error(\"expected \" + name + \" expression\");\n                    }\n                } else if (hasUnknown) {\n                    value = (parserInput.$re(/^[^{;]+/) || '').trim();\n                    hasBlock = (parserInput.currentChar() == '{');\n                    if (value) {\n                        value = new(tree.Anonymous)(value);\n                    }\n                }\n\n                if (hasBlock) {\n                    rules = this.blockRuleset();\n                }\n\n                if (rules || (!hasBlock && value && parserInput.$char(';'))) {\n                    parserInput.forget();\n                    return new (tree.Directive)(name, value, rules, index, fileInfo,\n                        context.dumpLineNumbers ? getDebugInfo(index) : null,\n                        isRooted\n                    );\n                }\n\n                parserInput.restore(\"directive options not recognised\");\n            },\n\n            //\n            // A Value is a comma-delimited list of Expressions\n            //\n            //     font-family: Baskerville, Georgia, serif;\n            //\n            // In a Rule, a Value represents everything after the `:`,\n            // and before the `;`.\n            //\n            value: function () {\n                var e, expressions = [];\n\n                do {\n                    e = this.expression();\n                    if (e) {\n                        expressions.push(e);\n                        if (! parserInput.$char(',')) { break; }\n                    }\n                } while (e);\n\n                if (expressions.length > 0) {\n                    return new(tree.Value)(expressions);\n                }\n            },\n            important: function () {\n                if (parserInput.currentChar() === '!') {\n                    return parserInput.$re(/^! *important/);\n                }\n            },\n            sub: function () {\n                var a, e;\n\n                parserInput.save();\n                if (parserInput.$char('(')) {\n                    a = this.addition();\n                    if (a && parserInput.$char(')')) {\n                        parserInput.forget();\n                        e = new(tree.Expression)([a]);\n                        e.parens = true;\n                        return e;\n                    }\n                    parserInput.restore(\"Expected ')'\");\n                    return;\n                }\n                parserInput.restore();\n            },\n            multiplication: function () {\n                var m, a, op, operation, isSpaced;\n                m = this.operand();\n                if (m) {\n                    isSpaced = parserInput.isWhitespace(-1);\n                    while (true) {\n                        if (parserInput.peek(/^\\/[*\\/]/)) {\n                            break;\n                        }\n\n                        parserInput.save();\n\n                        op = parserInput.$char('/') || parserInput.$char('*');\n\n                        if (!op) { parserInput.forget(); break; }\n\n                        a = this.operand();\n\n                        if (!a) { parserInput.restore(); break; }\n                        parserInput.forget();\n\n                        m.parensInOp = true;\n                        a.parensInOp = true;\n                        operation = new(tree.Operation)(op, [operation || m, a], isSpaced);\n                        isSpaced = parserInput.isWhitespace(-1);\n                    }\n                    return operation || m;\n                }\n            },\n            addition: function () {\n                var m, a, op, operation, isSpaced;\n                m = this.multiplication();\n                if (m) {\n                    isSpaced = parserInput.isWhitespace(-1);\n                    while (true) {\n                        op = parserInput.$re(/^[-+]\\s+/) || (!isSpaced && (parserInput.$char('+') || parserInput.$char('-')));\n                        if (!op) {\n                            break;\n                        }\n                        a = this.multiplication();\n                        if (!a) {\n                            break;\n                        }\n\n                        m.parensInOp = true;\n                        a.parensInOp = true;\n                        operation = new(tree.Operation)(op, [operation || m, a], isSpaced);\n                        isSpaced = parserInput.isWhitespace(-1);\n                    }\n                    return operation || m;\n                }\n            },\n            conditions: function () {\n                var a, b, index = parserInput.i, condition;\n\n                a = this.condition();\n                if (a) {\n                    while (true) {\n                        if (!parserInput.peek(/^,\\s*(not\\s*)?\\(/) || !parserInput.$char(',')) {\n                            break;\n                        }\n                        b = this.condition();\n                        if (!b) {\n                            break;\n                        }\n                        condition = new(tree.Condition)('or', condition || a, b, index);\n                    }\n                    return condition || a;\n                }\n            },\n            condition: function () {\n                var result, logical, next;\n                function or() {\n                    return parserInput.$str(\"or\");\n                }\n\n                result = this.conditionAnd(this);\n                if (!result) {\n                    return ;\n                }\n                logical = or();\n                if (logical) {\n                    next = this.condition();\n                    if (next) {\n                        result = new(tree.Condition)(logical, result, next);\n                    } else {\n                        return ;\n                    }\n                }\n                return result;\n            },\n            conditionAnd: function () {\n                var result, logical, next;\n                function insideCondition(me) {\n                    return me.negatedCondition() || me.parenthesisCondition();\n                }\n                function and() {\n                    return parserInput.$str(\"and\");\n                }\n\n                result = insideCondition(this);\n                if (!result) {\n                    return ;\n                }\n                logical = and();\n                if (logical) {\n                    next = this.conditionAnd();\n                    if (next) {\n                        result = new(tree.Condition)(logical, result, next);\n                    } else {\n                        return ;\n                    }\n                }\n                return result;\n            },\n            negatedCondition: function () {\n                if (parserInput.$str(\"not\")) {\n                    var result = this.parenthesisCondition();\n                    if (result) {\n                        result.negate = !result.negate;\n                    }\n                    return result;\n                }\n            },\n            parenthesisCondition: function () {\n                function tryConditionFollowedByParenthesis(me) {\n                    var body;\n                    parserInput.save();\n                    body = me.condition();\n                    if (!body) {\n                        parserInput.restore();\n                        return ;\n                    }\n                    if (!parserInput.$char(')')) {\n                        parserInput.restore();\n                        return ;\n                    }\n                    parserInput.forget();\n                    return body;\n                }\n\n                var body;\n                parserInput.save();\n                if (!parserInput.$str(\"(\")) {\n                    parserInput.restore();\n                    return ;\n                }\n                body = tryConditionFollowedByParenthesis(this);\n                if (body) {\n                    parserInput.forget();\n                    return body;\n                }\n\n                body = this.atomicCondition();\n                if (!body) {\n                    parserInput.restore();\n                    return ;\n                }\n                if (!parserInput.$char(')')) {\n                    parserInput.restore(\"expected ')' got '\" + parserInput.currentChar() + \"'\");\n                    return ;\n                }\n                parserInput.forget();\n                return body;\n            },\n            atomicCondition: function () {\n                var entities = this.entities, index = parserInput.i, a, b, c, op;\n\n                a = this.addition() || entities.keyword() || entities.quoted();\n                if (a) {\n                    if (parserInput.$char('>')) {\n                        if (parserInput.$char('=')) {\n                            op = \">=\";\n                        } else {\n                            op = '>';\n                        }\n                    } else\n                    if (parserInput.$char('<')) {\n                        if (parserInput.$char('=')) {\n                            op = \"<=\";\n                        } else {\n                            op = '<';\n                        }\n                    } else\n                    if (parserInput.$char('=')) {\n                        if (parserInput.$char('>')) {\n                            op = \"=>\";\n                        } else if (parserInput.$char('<')) {\n                            op = '=<';\n                        } else {\n                            op = '=';\n                        }\n                    }\n                    if (op) {\n                        b = this.addition() || entities.keyword() || entities.quoted();\n                        if (b) {\n                            c = new(tree.Condition)(op, a, b, index, false);\n                        } else {\n                            error('expected expression');\n                        }\n                    } else {\n                        c = new(tree.Condition)('=', a, new(tree.Keyword)('true'), index, false);\n                    }\n                    return c;\n                }\n            },\n\n            //\n            // An operand is anything that can be part of an operation,\n            // such as a Color, or a Variable\n            //\n            operand: function () {\n                var entities = this.entities, negate;\n\n                if (parserInput.peek(/^-[@\\(]/)) {\n                    negate = parserInput.$char('-');\n                }\n\n                var o = this.sub() || entities.dimension() ||\n                        entities.color() || entities.variable() ||\n                        entities.call() || entities.colorKeyword();\n\n                if (negate) {\n                    o.parensInOp = true;\n                    o = new(tree.Negative)(o);\n                }\n\n                return o;\n            },\n\n            //\n            // Expressions either represent mathematical operations,\n            // or white-space delimited Entities.\n            //\n            //     1px solid black\n            //     @var * 2\n            //\n            expression: function () {\n                var entities = [], e, delim;\n\n                do {\n                    e = this.comment();\n                    if (e) {\n                        entities.push(e);\n                        continue;\n                    }\n                    e = this.addition() || this.entity();\n                    if (e) {\n                        entities.push(e);\n                        // operations do not allow keyword \"/\" dimension (e.g. small/20px) so we support that here\n                        if (!parserInput.peek(/^\\/[\\/*]/)) {\n                            delim = parserInput.$char('/');\n                            if (delim) {\n                                entities.push(new(tree.Anonymous)(delim));\n                            }\n                        }\n                    }\n                } while (e);\n                if (entities.length > 0) {\n                    return new(tree.Expression)(entities);\n                }\n            },\n            property: function () {\n                var name = parserInput.$re(/^(\\*?-?[_a-zA-Z0-9-]+)\\s*:/);\n                if (name) {\n                    return name[1];\n                }\n            },\n            ruleProperty: function () {\n                var name = [], index = [], s, k;\n\n                parserInput.save();\n\n                var simpleProperty = parserInput.$re(/^([_a-zA-Z0-9-]+)\\s*:/);\n                if (simpleProperty) {\n                    name = [new(tree.Keyword)(simpleProperty[1])];\n                    parserInput.forget();\n                    return name;\n                }\n\n                function match(re) {\n                    var i = parserInput.i,\n                        chunk = parserInput.$re(re);\n                    if (chunk) {\n                        index.push(i);\n                        return name.push(chunk[1]);\n                    }\n                }\n\n                match(/^(\\*?)/);\n                while (true) {\n                    if (!match(/^((?:[\\w-]+)|(?:@\\{[\\w-]+\\}))/)) {\n                        break;\n                    }\n                }\n\n                if ((name.length > 1) && match(/^((?:\\+_|\\+)?)\\s*:/)) {\n                    parserInput.forget();\n\n                    // at last, we have the complete match now. move forward,\n                    // convert name particles to tree objects and return:\n                    if (name[0] === '') {\n                        name.shift();\n                        index.shift();\n                    }\n                    for (k = 0; k < name.length; k++) {\n                        s = name[k];\n                        name[k] = (s.charAt(0) !== '@') ?\n                            new(tree.Keyword)(s) :\n                            new(tree.Variable)('@' + s.slice(2, -1),\n                                index[k], fileInfo);\n                    }\n                    return name;\n                }\n                parserInput.restore();\n            }\n        }\n    };\n};\nParser.serializeVars = function(vars) {\n    var s = '';\n\n    for (var name in vars) {\n        if (Object.hasOwnProperty.call(vars, name)) {\n            var value = vars[name];\n            s += ((name[0] === '@') ? '' : '@') + name + ': ' + value +\n                ((String(value).slice(-1) === ';') ? '' : ';');\n        }\n    }\n\n    return s;\n};\n\nmodule.exports = Parser;\n"]}