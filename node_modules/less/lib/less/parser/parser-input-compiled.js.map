{"version":3,"sources":["parser-input.js"],"names":[],"mappings":"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","file":"parser-input-compiled.js","sourcesContent":["var chunker = require('./chunker');\n\nmodule.exports = function() {\n    var input,       // LeSS input string\n        j,           // current chunk\n        saveStack = [],   // holds state for backtracking\n        furthest,    // furthest index the parser has gone to\n        furthestPossibleErrorMessage,// if this is furthest we got to, this is the probably cause\n        chunks,      // chunkified input\n        current,     // current chunk\n        currentPos,  // index of current chunk, in `input`\n        parserInput = {};\n\n    var CHARCODE_SPACE = 32,\n        CHARCODE_TAB = 9,\n        CHARCODE_LF = 10,\n        CHARCODE_CR = 13,\n        CHARCODE_PLUS = 43,\n        CHARCODE_COMMA = 44,\n        CHARCODE_FORWARD_SLASH = 47,\n        CHARCODE_9 = 57;\n\n    function skipWhitespace(length) {\n        var oldi = parserInput.i, oldj = j,\n            curr = parserInput.i - currentPos,\n            endIndex = parserInput.i + current.length - curr,\n            mem = (parserInput.i += length),\n            inp = input,\n            c, nextChar, comment;\n\n        for (; parserInput.i < endIndex; parserInput.i++) {\n            c = inp.charCodeAt(parserInput.i);\n\n            if (parserInput.autoCommentAbsorb && c === CHARCODE_FORWARD_SLASH) {\n                nextChar = inp.charAt(parserInput.i + 1);\n                if (nextChar === '/') {\n                    comment = {index: parserInput.i, isLineComment: true};\n                    var nextNewLine = inp.indexOf(\"\\n\", parserInput.i + 2);\n                    if (nextNewLine < 0) {\n                        nextNewLine = endIndex;\n                    }\n                    parserInput.i = nextNewLine;\n                    comment.text = inp.substr(comment.index, parserInput.i - comment.index);\n                    parserInput.commentStore.push(comment);\n                    continue;\n                } else if (nextChar === '*') {\n                    var nextStarSlash = inp.indexOf(\"*/\", parserInput.i + 2);\n                    if (nextStarSlash >= 0) {\n                        comment = {\n                            index: parserInput.i,\n                            text: inp.substr(parserInput.i, nextStarSlash + 2 - parserInput.i),\n                            isLineComment: false\n                        };\n                        parserInput.i += comment.text.length - 1;\n                        parserInput.commentStore.push(comment);\n                        continue;\n                    }\n                }\n                break;\n            }\n\n            if ((c !== CHARCODE_SPACE) && (c !== CHARCODE_LF) && (c !== CHARCODE_TAB) && (c !== CHARCODE_CR)) {\n                break;\n            }\n        }\n\n        current = current.slice(length + parserInput.i - mem + curr);\n        currentPos = parserInput.i;\n\n        if (!current.length) {\n            if (j < chunks.length - 1) {\n                current = chunks[++j];\n                skipWhitespace(0); // skip space at the beginning of a chunk\n                return true; // things changed\n            }\n            parserInput.finished = true;\n        }\n\n        return oldi !== parserInput.i || oldj !== j;\n    }\n\n    parserInput.save = function() {\n        currentPos = parserInput.i;\n        saveStack.push( { current: current, i: parserInput.i, j: j });\n    };\n    parserInput.restore = function(possibleErrorMessage) {\n\n        if (parserInput.i > furthest || (parserInput.i === furthest && possibleErrorMessage && !furthestPossibleErrorMessage)) {\n            furthest = parserInput.i;\n            furthestPossibleErrorMessage = possibleErrorMessage;\n        }\n        var state = saveStack.pop();\n        current = state.current;\n        currentPos = parserInput.i = state.i;\n        j = state.j;\n    };\n    parserInput.forget = function() {\n        saveStack.pop();\n    };\n    parserInput.isWhitespace = function (offset) {\n        var pos = parserInput.i + (offset || 0),\n            code = input.charCodeAt(pos);\n        return (code === CHARCODE_SPACE || code === CHARCODE_CR || code === CHARCODE_TAB || code === CHARCODE_LF);\n    };\n\n    // Specialization of $(tok)\n    parserInput.$re = function(tok) {\n        if (parserInput.i > currentPos) {\n            current = current.slice(parserInput.i - currentPos);\n            currentPos = parserInput.i;\n        }\n\n        var m = tok.exec(current);\n        if (!m) {\n            return null;\n        }\n\n        skipWhitespace(m[0].length);\n        if (typeof m === \"string\") {\n            return m;\n        }\n\n        return m.length === 1 ? m[0] : m;\n    };\n\n    parserInput.$char = function(tok) {\n        if (input.charAt(parserInput.i) !== tok) {\n            return null;\n        }\n        skipWhitespace(1);\n        return tok;\n    };\n\n    parserInput.$str = function(tok) {\n        var tokLength = tok.length;\n\n        // https://jsperf.com/string-startswith/21\n        for (var i = 0; i < tokLength; i++) {\n            if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {\n                return null;\n            }\n        }\n\n        skipWhitespace(tokLength);\n        return tok;\n    };\n\n    parserInput.$quoted = function() {\n\n        var startChar = input.charAt(parserInput.i);\n        if (startChar !== \"'\" && startChar !== '\"') {\n            return;\n        }\n        var length = input.length,\n            currentPosition = parserInput.i;\n\n        for (var i = 1; i + currentPosition < length; i++) {\n            var nextChar = input.charAt(i + currentPosition);\n            switch(nextChar) {\n                case \"\\\\\":\n                    i++;\n                    continue;\n                case \"\\r\":\n                case \"\\n\":\n                    break;\n                case startChar:\n                    var str = input.substr(currentPosition, i + 1);\n                    skipWhitespace(i + 1);\n                    return str;\n                default:\n            }\n        }\n        return null;\n    };\n\n    parserInput.autoCommentAbsorb = true;\n    parserInput.commentStore = [];\n    parserInput.finished = false;\n\n    // Same as $(), but don't change the state of the parser,\n    // just return the match.\n    parserInput.peek = function(tok) {\n        if (typeof tok === 'string') {\n            // https://jsperf.com/string-startswith/21\n            for (var i = 0; i < tok.length; i++) {\n                if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {\n                    return false;\n                }\n            }\n            return true;\n        } else {\n            return tok.test(current);\n        }\n    };\n\n    // Specialization of peek()\n    // TODO remove or change some currentChar calls to peekChar\n    parserInput.peekChar = function(tok) {\n        return input.charAt(parserInput.i) === tok;\n    };\n\n    parserInput.currentChar = function() {\n        return input.charAt(parserInput.i);\n    };\n\n    parserInput.getInput = function() {\n        return input;\n    };\n\n    parserInput.peekNotNumeric = function() {\n        var c = input.charCodeAt(parserInput.i);\n        //Is the first char of the dimension 0-9, '.', '+' or '-'\n        return (c > CHARCODE_9 || c < CHARCODE_PLUS) || c === CHARCODE_FORWARD_SLASH || c === CHARCODE_COMMA;\n    };\n\n    parserInput.start = function(str, chunkInput, failFunction) {\n        input = str;\n        parserInput.i = j = currentPos = furthest = 0;\n\n        // chunking apparently makes things quicker (but my tests indicate\n        // it might actually make things slower in node at least)\n        // and it is a non-perfect parse - it can't recognise\n        // unquoted urls, meaning it can't distinguish comments\n        // meaning comments with quotes or {}() in them get 'counted'\n        // and then lead to parse errors.\n        // In addition if the chunking chunks in the wrong place we might\n        // not be able to parse a parser statement in one go\n        // this is officially deprecated but can be switched on via an option\n        // in the case it causes too much performance issues.\n        if (chunkInput) {\n            chunks = chunker(str, failFunction);\n        } else {\n            chunks = [str];\n        }\n\n        current = chunks[0];\n\n        skipWhitespace(0);\n    };\n\n    parserInput.end = function() {\n        var message,\n            isFinished = parserInput.i >= input.length;\n\n        if (parserInput.i < furthest) {\n            message = furthestPossibleErrorMessage;\n            parserInput.i = furthest;\n        }\n        return {\n            isFinished: isFinished,\n            furthest: parserInput.i,\n            furthestPossibleErrorMessage: message,\n            furthestReachedEnd: parserInput.i >= input.length - 1,\n            furthestChar: input[parserInput.i]\n        };\n    };\n\n    return parserInput;\n};\n"]}