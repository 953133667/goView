{"version":3,"sources":["random.js"],"names":[],"mappings":"AAAA,IAAI,aAAa,QAAQ,eAAR,CAAjB;AAAA,IACI,iBAAiB,QAAQ,mBAAR,CADrB;AAAA,IAEI,WAAW,QAAQ,YAAR,CAFf;;AAIA;AACA,IAAI,iBAAiB,UAArB;;AAEA;AACA,IAAI,YAAY,KAAK,GAArB;AAAA,IACI,eAAe,KAAK,MADxB;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA,SAAS,MAAT,CAAgB,KAAhB,EAAuB,KAAvB,EAA8B,QAA9B,EAAwC;AACtC,MAAI,YAAY,OAAO,QAAP,IAAmB,SAA/B,IAA4C,eAAe,KAAf,EAAsB,KAAtB,EAA6B,QAA7B,CAAhD,EAAwF;AACtF,YAAQ,WAAW,SAAnB;AACD;AACD,MAAI,aAAa,SAAjB,EAA4B;AAC1B,QAAI,OAAO,KAAP,IAAgB,SAApB,EAA+B;AAC7B,iBAAW,KAAX;AACA,cAAQ,SAAR;AACD,KAHD,MAIK,IAAI,OAAO,KAAP,IAAgB,SAApB,EAA+B;AAClC,iBAAW,KAAX;AACA,cAAQ,SAAR;AACD;AACF;AACD,MAAI,UAAU,SAAV,IAAuB,UAAU,SAArC,EAAgD;AAC9C,YAAQ,CAAR;AACA,YAAQ,CAAR;AACD,GAHD,MAIK;AACH,YAAQ,SAAS,KAAT,KAAmB,CAA3B;AACA,QAAI,UAAU,SAAd,EAAyB;AACvB,cAAQ,KAAR;AACA,cAAQ,CAAR;AACD,KAHD,MAGO;AACL,cAAQ,SAAS,KAAT,KAAmB,CAA3B;AACD;AACF;AACD,MAAI,QAAQ,KAAZ,EAAmB;AACjB,QAAI,OAAO,KAAX;AACA,YAAQ,KAAR;AACA,YAAQ,IAAR;AACD;AACD,MAAI,YAAY,QAAQ,CAApB,IAAyB,QAAQ,CAArC,EAAwC;AACtC,QAAI,OAAO,cAAX;AACA,WAAO,UAAU,QAAS,QAAQ,QAAQ,KAAR,GAAgB,eAAe,SAAS,CAAC,OAAO,EAAR,EAAY,MAAZ,GAAqB,CAA9B,CAAf,CAAxB,CAAnB,EAA+F,KAA/F,CAAP;AACD;AACD,SAAO,WAAW,KAAX,EAAkB,KAAlB,CAAP;AACD;;AAED,OAAO,OAAP,GAAiB,MAAjB","file":"random-compiled.js","sourcesContent":["var baseRandom = require('./_baseRandom'),\n    isIterateeCall = require('./_isIterateeCall'),\n    toNumber = require('./toNumber');\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseFloat = parseFloat;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMin = Math.min,\n    nativeRandom = Math.random;\n\n/**\n * Produces a random number between the inclusive `lower` and `upper` bounds.\n * If only one argument is provided a number between `0` and the given number\n * is returned. If `floating` is `true`, or either `lower` or `upper` are\n * floats, a floating-point number is returned instead of an integer.\n *\n * **Note:** JavaScript follows the IEEE-754 standard for resolving\n * floating-point values which can produce unexpected results.\n *\n * @static\n * @memberOf _\n * @since 0.7.0\n * @category Number\n * @param {number} [lower=0] The lower bound.\n * @param {number} [upper=1] The upper bound.\n * @param {boolean} [floating] Specify returning a floating-point number.\n * @returns {number} Returns the random number.\n * @example\n *\n * _.random(0, 5);\n * // => an integer between 0 and 5\n *\n * _.random(5);\n * // => also an integer between 0 and 5\n *\n * _.random(5, true);\n * // => a floating-point number between 0 and 5\n *\n * _.random(1.2, 5.2);\n * // => a floating-point number between 1.2 and 5.2\n */\nfunction random(lower, upper, floating) {\n  if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {\n    upper = floating = undefined;\n  }\n  if (floating === undefined) {\n    if (typeof upper == 'boolean') {\n      floating = upper;\n      upper = undefined;\n    }\n    else if (typeof lower == 'boolean') {\n      floating = lower;\n      lower = undefined;\n    }\n  }\n  if (lower === undefined && upper === undefined) {\n    lower = 0;\n    upper = 1;\n  }\n  else {\n    lower = toNumber(lower) || 0;\n    if (upper === undefined) {\n      upper = lower;\n      lower = 0;\n    } else {\n      upper = toNumber(upper) || 0;\n    }\n  }\n  if (lower > upper) {\n    var temp = lower;\n    lower = upper;\n    upper = temp;\n  }\n  if (floating || lower % 1 || upper % 1) {\n    var rand = nativeRandom();\n    return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);\n  }\n  return baseRandom(lower, upper);\n}\n\nmodule.exports = random;\n"]}