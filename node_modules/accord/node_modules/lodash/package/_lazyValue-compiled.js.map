{"version":3,"sources":["_lazyValue.js"],"names":[],"mappings":"AAAA,IAAI,mBAAmB,QAAQ,qBAAR,CAAvB;AAAA,IACI,UAAU,QAAQ,YAAR,CADd;AAAA,IAEI,UAAU,QAAQ,WAAR,CAFd;;AAIA;AACA,IAAI,mBAAmB,GAAvB;;AAEA;AACA,IAAI,mBAAmB,CAAvB;AAAA,IACI,gBAAgB,CADpB;;AAGA;AACA,IAAI,YAAY,KAAK,GAArB;;AAEA;;;;;;;;AAQA,SAAS,SAAT,GAAqB;AACnB,MAAI,QAAQ,KAAK,WAAL,CAAiB,KAAjB,EAAZ;AAAA,MACI,MAAM,KAAK,OADf;AAAA,MAEI,QAAQ,QAAQ,KAAR,CAFZ;AAAA,MAGI,UAAU,MAAM,CAHpB;AAAA,MAII,YAAY,QAAQ,MAAM,MAAd,GAAuB,CAJvC;AAAA,MAKI,OAAO,QAAQ,CAAR,EAAW,SAAX,EAAsB,KAAK,SAA3B,CALX;AAAA,MAMI,QAAQ,KAAK,KANjB;AAAA,MAOI,MAAM,KAAK,GAPf;AAAA,MAQI,SAAS,MAAM,KARnB;AAAA,MASI,QAAQ,UAAU,GAAV,GAAiB,QAAQ,CATrC;AAAA,MAUI,YAAY,KAAK,aAVrB;AAAA,MAWI,aAAa,UAAU,MAX3B;AAAA,MAYI,WAAW,CAZf;AAAA,MAaI,YAAY,UAAU,MAAV,EAAkB,KAAK,aAAvB,CAbhB;;AAeA,MAAI,CAAC,KAAD,IAAU,YAAY,gBAAtB,IACC,aAAa,MAAb,IAAuB,aAAa,MADzC,EACkD;AAChD,WAAO,iBAAiB,KAAjB,EAAwB,KAAK,WAA7B,CAAP;AACD;AACD,MAAI,SAAS,EAAb;;AAEA,SACA,OAAO,YAAY,WAAW,SAA9B,EAAyC;AACvC,aAAS,GAAT;;AAEA,QAAI,YAAY,CAAC,CAAjB;AAAA,QACI,QAAQ,MAAM,KAAN,CADZ;;AAGA,WAAO,EAAE,SAAF,GAAc,UAArB,EAAiC;AAC/B,UAAI,OAAO,UAAU,SAAV,CAAX;AAAA,UACI,WAAW,KAAK,QADpB;AAAA,UAEI,OAAO,KAAK,IAFhB;AAAA,UAGI,WAAW,SAAS,KAAT,CAHf;;AAKA,UAAI,QAAQ,aAAZ,EAA2B;AACzB,gBAAQ,QAAR;AACD,OAFD,MAEO,IAAI,CAAC,QAAL,EAAe;AACpB,YAAI,QAAQ,gBAAZ,EAA8B;AAC5B,mBAAS,KAAT;AACD,SAFD,MAEO;AACL,gBAAM,KAAN;AACD;AACF;AACF;AACD,WAAO,UAAP,IAAqB,KAArB;AACD;AACD,SAAO,MAAP;AACD;;AAED,OAAO,OAAP,GAAiB,SAAjB","file":"_lazyValue-compiled.js","sourcesContent":["var baseWrapperValue = require('./_baseWrapperValue'),\n    getView = require('./_getView'),\n    isArray = require('./isArray');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to indicate the type of lazy iteratees. */\nvar LAZY_FILTER_FLAG = 1,\n    LAZY_MAP_FLAG = 2;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMin = Math.min;\n\n/**\n * Extracts the unwrapped value from its lazy wrapper.\n *\n * @private\n * @name value\n * @memberOf LazyWrapper\n * @returns {*} Returns the unwrapped value.\n */\nfunction lazyValue() {\n  var array = this.__wrapped__.value(),\n      dir = this.__dir__,\n      isArr = isArray(array),\n      isRight = dir < 0,\n      arrLength = isArr ? array.length : 0,\n      view = getView(0, arrLength, this.__views__),\n      start = view.start,\n      end = view.end,\n      length = end - start,\n      index = isRight ? end : (start - 1),\n      iteratees = this.__iteratees__,\n      iterLength = iteratees.length,\n      resIndex = 0,\n      takeCount = nativeMin(length, this.__takeCount__);\n\n  if (!isArr || arrLength < LARGE_ARRAY_SIZE ||\n      (arrLength == length && takeCount == length)) {\n    return baseWrapperValue(array, this.__actions__);\n  }\n  var result = [];\n\n  outer:\n  while (length-- && resIndex < takeCount) {\n    index += dir;\n\n    var iterIndex = -1,\n        value = array[index];\n\n    while (++iterIndex < iterLength) {\n      var data = iteratees[iterIndex],\n          iteratee = data.iteratee,\n          type = data.type,\n          computed = iteratee(value);\n\n      if (type == LAZY_MAP_FLAG) {\n        value = computed;\n      } else if (!computed) {\n        if (type == LAZY_FILTER_FLAG) {\n          continue outer;\n        } else {\n          break outer;\n        }\n      }\n    }\n    result[resIndex++] = value;\n  }\n  return result;\n}\n\nmodule.exports = lazyValue;\n"]}